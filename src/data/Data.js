export const data = {
  title: "All",
  children: [
    {
      title: "Web-technology",
      children: [
        {
          title: "Когда пользователь открывает страницу по ссылке",
          children: [
            {
              title: "1. Запрос по сети",
              type: "list",
              description: `
                <ul>
                  <li><strong>Клик по ссылке:</strong> Пользователь нажимает на ссылку, инициируя процесс загрузки страницы.</li>
                  <li><strong>DNS-запрос:</strong> Браузер запрашивает IP-адрес сервера, на котором размещён ресурс.</li>
                </ul>
              `,
            },
            {
              title: "2. Установление соединения",
              type: "list",
              description: `
                <ul>
                  <li><strong>TCP-соединение:</strong> Браузер устанавливает TCP-соединение с сервером.</li>
                  <li><strong>TLS/SSL:</strong> Устанавливается защищенное соединение, если используется HTTPS.</li>
                </ul>
              `,
            },
            {
              title: "3. Отправка HTTP-запроса",
              type: "list",
              description: `
                <ul>
                  <li><strong>HTTP-запрос:</strong> Браузер отправляет запрос на сервер для получения ресурса (HTML-документа).</li>
                </ul>
              `,
            },
            {
              title: "4. Получение ответа от сервера",
              type: "list",
              description: `
                <ul>
                  <li><strong>HTTP-ответ:</strong> Сервер обрабатывает запрос и отправляет обратно статус-код, заголовки и тело ответа.</li>
                </ul>
              `,
            },
            {
              title: "5. Обработка ответа",
              type: "list",
              description: `
                <ul>
                  <li><strong>Загрузка и парсинг HTML:</strong> Браузер начинает загружать и парсить HTML-документ, создавая DOM.</li>
                  <li><strong>Загрузка зависимостей:</strong> Браузер отправляет дополнительные запросы для внешних ресурсов (CSS, JavaScript, изображения).</li>
                </ul>
              `,
            },
            {
              title: "6. Обработка CSS и JavaScript",
              type: "list",
              description: `
                <ul>
                  <li><strong>Загрузка и парсинг CSS:</strong> Браузер загружает и парсит CSS, создавая CSSOM.</li>
                  <li><strong>Выполнение JavaScript:</strong> JavaScript-файлы выполняются и могут изменять структуру DOM и стили.</li>
                </ul>
              `,
            },
            {
              title: "7. Создание рендеринга",
              type: "list",
              description: `
                <ul>
                  <li><strong>Создание дерева рендеринга:</strong> Браузер объединяет DOM и CSSOM для создания визуального представления.</li>
                  <li><strong>Рендеринг:</strong> Страница отрисовывается на экране.</li>
                </ul>
              `,
            },
            {
              title: "8. Завершение загрузки",
              type: "list",
              description: `
                <ul>
                  <li><strong>Событие 'DOMContentLoaded':</strong> Срабатывает, когда HTML полностью загружен и разобран.</li>
                  <li><strong>Событие 'load':</strong> Срабатывает, когда вся страница и её зависимости полностью загружены.</li>
                  <li><strong>Событие 'beforeunload':</strong> Подготавливается для обработки при попытке пользователя покинуть страницу.</li>
                </ul>
              `,
            },
            {
              title: "9. Взаимодействие с пользователем",
              type: "list",
              description: `
                <p><strong>Интерактивность:</strong> Пользователь начинает взаимодействовать с загруженной страницей, и скрипты обрабатывают события.</p>
              `,
            },
          ],
        },
        {
          title: "JWT (JSON Web Token)",
          children: [
            {
              title: "Определение",
              type: "list",
              description: `
                <p>JWT (JSON Web Token) — это открытый стандарт (RFC 7519), который определяет компактный и автономный способ безопасной передачи информации между сторонами в виде JSON-объекта. Эта информация может быть проверена и доверена, так как она подписана цифровой подписью.</p>
              `,
            },
            {
              title: "Структура JWT",
              type: "list",
              description: `
                <p>JWT состоит из трех частей, разделенных точками:</p>
                <ul>
                  <li><strong>Header</strong>: Содержит информацию о типе токена (обычно "JWT") и алгоритме подписи (например, HMAC SHA256 или RSA).</li>
                  <li><strong>Payload</strong>: Содержит данные (т.Claims), которые будут переданы. Это может быть информация о пользователе, срок действия токена и т. д.</li>
                  <li><strong>Signature</strong>: Создается путем кодирования заголовка и полезной нагрузки, и последующей подписи с использованием секрета или закрытого ключа.</li>
                </ul>
              `,
            },
            {
              title: "Преимущества JWT",
              type: "list",
              description: `
                <p>Преимущества использования JWT:</p>
                <ul>
                  <li><strong>Самодостаточность</strong>: Токен содержит все необходимые данные, что позволяет избежать дополнительных запросов к серверу для проверки состояния сессии.</li>
                  <li><strong>Безопасность</strong>: JWT можно подписывать и шифровать, что обеспечивает защиту данных от подделки и несанкционированного доступа.</li>
                  <li><strong>Масштабируемость</strong>: JWT можно использовать в распределенных системах, где нет необходимости в хранилище состояния сессии на сервере.</li>
                </ul>
              `,
            },
            {
              title: "Недостатки JWT",
              type: "list",
              description: `
                <p>Недостатки использования JWT:</p>
                <ul>
                  <li><strong>Увеличение размера токена</strong>: Из-за включения дополнительных данных размер JWT может быть значительно больше, чем традиционные сессионные идентификаторы.</li>
                  <li><strong>Сложность управления сроком действия</strong>: После выдачи токена его нельзя отозвать, если он скомпрометирован, до истечения срока действия.</li>
                  <li><strong>Безопасность</strong>: Если секретный ключ, используемый для подписи токена, будет скомпрометирован, это может привести к серьезным угрозам безопасности.</li>
                </ul>
              `,
            },
            {
              title: "Использование JWT",
              type: "list",
              description: `
                <p>JWT часто используется для:</p>
                <ul>
                  <li><strong>Аутентификации</strong>: После успешного входа в систему пользователю выдается JWT, который он использует для доступа к защищенным ресурсам.</li>
                  <li><strong>Авторизации</strong>: JWT может содержать информацию о ролях и разрешениях пользователя, что позволяет контролировать доступ к различным ресурсам.</li>
                  <li><strong>Передачи данных</strong>: JWT может использоваться для обмена информацией между различными системами в распределенных приложениях.</li>
                </ul>
              `,
            },
          ],
        },
        {
          title: "Простые и сложные запросы",
          children: [
            {
              title: "Определение",
              type: "list",
              description: `
                <p>Простые и сложные запросы относятся к типам запросов, используемых в базах данных и системах управления данными для извлечения информации. Простые запросы выполняются с использованием одной таблицы, тогда как сложные запросы могут включать несколько таблиц и более сложные условия.</p>
              `,
            },
            {
              title: "Простые запросы",
              type: "list",
              description: `
                <p>Простые запросы обычно выполняют базовые операции извлечения данных и имеют следующую структуру:</p>
                <ul>
                  <li><strong>Выборка данных:</strong> Извлечение данных из одной таблицы.</li>
                  <li><strong>Пример:</strong> <code>SELECT * FROM users WHERE age > 18;</code></li>
                  <li><strong>Условия:</strong> Простые условия фильтрации, такие как равенство или сравнение.</li>
                </ul>
              `,
            },
            {
              title: "Сложные запросы",
              type: "list",
              description: `
                <p>Сложные запросы могут включать объединение нескольких таблиц, подзапросы и более сложные условия:</p>
                <ul>
                  <li><strong>Объединение таблиц:</strong> Использование операторов <code>JOIN</code> для получения данных из нескольких таблиц.</li>
                  <li><strong>Подзапросы:</strong> Вложенные запросы, которые позволяют использовать результаты одного запроса в другом.</li>
                  <li><strong>Пример:</strong> <code>SELECT u.name, o.amount FROM users u JOIN orders o ON u.id = o.user_id WHERE o.status = 'completed';</code></li>
                  <li><strong>Группировка и агрегация:</strong> Использование функций агрегации (например, <code>SUM</code>, <code>COUNT</code>) в сочетании с <code>GROUP BY</code>.</li>
                </ul>
              `,
            },
            {
              title: "Преимущества и недостатки",
              type: "list",
              description: `
                <p>Сравнение простых и сложных запросов:</p>
                <ul>
                  <li><strong>Простые запросы:</strong>
                    <ul>
                      <li>Преимущества: Быстрота выполнения, простота понимания и отладки.</li>
                      <li>Недостатки: Ограниченные возможности извлечения данных.</li>
                    </ul>
                  </li>
                  <li><strong>Сложные запросы:</strong>
                    <ul>
                      <li>Преимущества: Возможность получать более сложные и полные данные.</li>
                      <li>Недостатки: Долгое время выполнения, сложность в написании и отладке.</li>
                    </ul>
                  </li>
                </ul>
              `,
            },
            {
              title: "Примеры использования",
              type: "list",
              description: `
                <p>Примеры использования:</p>
                <ul>
                  <li><strong>Простые запросы:</strong> Извлечение списка пользователей, которые зарегистрированы на платформе.</li>
                  <li><strong>Сложные запросы:</strong> Получение данных о пользователях и их заказах для аналитики.</li>
                </ul>
              `,
            },
          ],
        },
        {
          title: "HTTP и HTTPS",
          children: [
            {
              title: "Определение",
              type: "list",
              description: `
                <p>HTTP (HyperText Transfer Protocol) — это протокол, используемый для передачи данных в интернете. HTTPS (HTTP Secure) — защищенная версия HTTP, использующая шифрование для обеспечения безопасности данных во время передачи.</p>
              `,
            },
            {
              title: "HTTP",
              type: "list",
              description: `
                <p>Основные характеристики HTTP:</p>
                <ul>
                  <li><strong>Протокол передачи:</strong> HTTP работает по принципу клиент-сервер, где клиент (например, веб-браузер) отправляет запросы, а сервер отвечает на них.</li>
                  <li><strong>Не защищенный:</strong> Данные передаются в открытом виде, что делает их уязвимыми для перехвата и атак.</li>
                  <li><strong>Методы:</strong> Включает методы, такие как GET, POST, PUT, DELETE и другие для взаимодействия с ресурсами.</li>
                </ul>
              `,
            },
            {
              title: "HTTPS",
              type: "list",
              description: `
                <p>Основные характеристики HTTPS:</p>
                <ul>
                  <li><strong>Шифрование:</strong> HTTPS использует протокол SSL/TLS для шифрования данных, что обеспечивает защиту от перехвата.</li>
                  <li><strong>Безопасность:</strong> Защищает конфиденциальность информации, передаваемой между клиентом и сервером.</li>
                  <li><strong>Аутентификация:</strong> HTTPS позволяет проверить подлинность сервера, что помогает предотвратить атаки типа "человек посередине".</li>
                </ul>
              `,
            },
            {
              title: "Преимущества HTTPS",
              type: "list",
              description: `
                <p>Преимущества использования HTTPS:</p>
                <ul>
                  <li><strong>Безопасность:</strong> Защита данных от перехвата и подделки.</li>
                  <li><strong>Доверие пользователей:</strong> HTTPS повышает доверие пользователей к веб-сайту, особенно на страницах с вводом личных данных.</li>
                  <li><strong>SEO:</strong> Поисковые системы, такие как Google, отдают предпочтение HTTPS-сайтам в результатах поиска.</li>
                </ul>
              `,
            },
            {
              title: "Недостатки и ограничения",
              type: "list",
              description: `
                <p>Недостатки и ограничения:</p>
                <ul>
                  <li><strong>Производительность:</strong> Шифрование может немного замедлить скорость передачи данных.</li>
                  <li><strong>Сложность настройки:</strong> Требует наличия SSL-сертификата и правильной конфигурации сервера.</li>
                </ul>
              `,
            },
            {
              title: "Рекомендации",
              type: "list",
              description: `
                <p>Рекомендации по использованию:</p>
                <ul>
                  <li><strong>Всегда используйте HTTPS:</strong> Особенно на сайтах, обрабатывающих личные и финансовые данные.</li>
                  <li><strong>Регулярно обновляйте SSL-сертификаты:</strong> Убедитесь, что сертификаты актуальны и правильно настроены.</li>
                  <li><strong>Переходите на HTTPS:</strong> Если ваш сайт еще использует HTTP, рассмотрите возможность перехода на защищенную версию.</li>
                </ul>
              `,
            },
          ],
        },
        {
          title: "Версии протокола HTTP",
          children: [
            {
              title: "HTTP/1.x",
              type: "list",
              description: `
                <p>HTTP/1.x включает в себя версии HTTP/1.0 и HTTP/1.1:</p>
                <ul>
                  <li><strong>HTTP/1.0:</strong>
                    <ul>
                      <li>Выпущен в 1996 году, был первой широко используемой версией протокола.</li>
                      <li>Каждый запрос открывает новое соединение, что может привести к значительным накладным расходам.</li>
                      <li>Не поддерживает кэширование, а также такие функции, как сжатие и многопоточность.</li>
                    </ul>
                  </li>
                  <li><strong>HTTP/1.1:</strong>
                    <ul>
                      <li>Выпущен в 1999 году, стал стандартом для большинства веб-приложений.</li>
                      <li>Поддерживает постоянные соединения (keep-alive), что позволяет использовать одно соединение для нескольких запросов.</li>
                      <li>Включает улучшения, такие как кэширование, сжатие и управление заголовками.</li>
                    </ul>
                  </li>
                </ul>
              `,
            },
            {
              title: "HTTP/2",
              type: "list",
              description: `
                <p>HTTP/2 был выпущен в 2015 году и включает в себя следующие улучшения:</p>
                <ul>
                  <li><strong>Мультиплексирование:</strong> Позволяет одновременно отправлять несколько запросов и ответов по одному соединению, что уменьшает задержки.</li>
                  <li><strong>Сжатие заголовков:</strong> Использует алгоритм HPACK для сжатия заголовков, что уменьшает объем передаваемых данных.</li>
                  <li><strong>Приоритетизация:</strong> Позволяет задавать приоритет для запросов, что улучшает производительность.</li>
                </ul>
              `,
            },
            {
              title: "HTTP/3",
              type: "list",
              description: `
                <p>HTTP/3 является последней версией протокола, находящейся в разработке и основанной на QUIC:</p>
                <ul>
                  <li><strong>Использование QUIC:</strong> Протокол QUIC обеспечивает шифрование и помогает снизить задержки при установлении соединения.</li>
                  <li><strong>Мультиплексирование без блокировки:</strong> HTTP/3 устраняет проблемы блокировки, связанные с TCP, позволяя более эффективное использование сетевых ресурсов.</li>
                  <li><strong>Улучшенная производительность:</strong> HTTP/3 обеспечивает более быструю загрузку страниц и улучшенное взаимодействие с пользователями.</li>
                </ul>
              `,
            },
            {
              title: "Сравнение версий",
              type: "list",
              description: `
                <p>Сравнение версий HTTP:</p>
                <ul>
                  <li><strong>Производительность:</strong> HTTP/1.1 менее эффективен из-за необходимости открывать новые соединения для каждого запроса, в то время как HTTP/2 и HTTP/3 используют мультиплексирование.</li>
                  <li><strong>Задержка:</strong> HTTP/2 и HTTP/3 значительно уменьшают задержку благодаря улучшенному управлению соединениями и сжатию заголовков.</li>
                  <li><strong>Безопасность:</strong> HTTP/2 и HTTP/3 более безопасны, поскольку предполагают использование TLS, а HTTP/3 использует QUIC, который изначально проектировался с учетом безопасности.</li>
                </ul>
              `,
            },
            {
              title: "Рекомендации",
              type: "list",
              description: `
                <p>Рекомендации по переходу на новые версии:</p>
                <ul>
                  <li><strong>Переходите на HTTP/2:</strong> Если ваше приложение поддерживает его, переход на HTTP/2 может значительно улучшить производительность.</li>
                  <li><strong>Следите за новыми разработками:</strong> HTTP/3 находится на стадии внедрения, и важно следить за его развитием для будущего улучшения.</li>
                </ul>
              `,
            },
          ],
        },
        {
          title: "Идемпотентные методы HTTP",
          children: [
            {
              title: "Определение",
              type: "list",
              description: `
                <p>Идемпотентные методы HTTP — это методы, которые могут быть выполнены несколько раз без изменения результата за пределами первоначального применения. Это означает, что повторный запрос с теми же параметрами не изменит состояние ресурса на сервере после первого запроса.</p>
              `,
            },
            {
              title: "Идемпотентные методы",
              type: "list",
              description: `
                <p>К основным идемпотентным методам HTTP относятся:</p>
                <ul>
                  <li><strong>GET:</strong> Используется для получения данных с сервера. Повторный запрос не изменяет состояние ресурса.</li>
                  <li><strong>PUT:</strong> Используется для обновления существующего ресурса или создания нового ресурса с определенным идентификатором. Повторный запрос с теми же данными не изменит состояние ресурса.</li>
                  <li><strong>DELETE:</strong> Используется для удаления ресурса. Повторный запрос на удаление уже удаленного ресурса может возвращать ошибку, но не изменяет состояние сервера.</li>
                  <li><strong>OPTIONS:</strong> Используется для получения информации о том, какие методы поддерживаются сервером для определенного ресурса. Не изменяет состояние ресурса.</li>
                </ul>
              `,
            },
            {
              title: "Неидемпотентные методы",
              type: "list",
              description: `
                <p>Неидемпотентные методы:</p>
                <ul>
                  <li><strong>POST:</strong> Используется для создания новых ресурсов. Повторный запрос может создать несколько одинаковых ресурсов, что изменит состояние сервера.</li>
                </ul>
              `,
            },
            {
              title: "Преимущества идемпотентности",
              type: "list",
              description: `
                <p>Преимущества использования идемпотентных методов:</p>
                <ul>
                  <li><strong>Устойчивость к ошибкам:</strong> Позволяет клиентам повторять запросы без опасений изменить состояние сервера.</li>
                  <li><strong>Упрощение обработки:</strong> Сервер может легко повторно обрабатывать запросы без необходимости отслеживать их состояние.</li>
                  <li><strong>Гарантия консистентности:</strong> Помогает поддерживать согласованность данных, особенно в распределенных системах.</li>
                </ul>
              `,
            },
            {
              title: "Применение идемпотентных методов",
              type: "list",
              description: `
                <p>Идемпотентные методы часто используются в следующих сценариях:</p>
                <ul>
                  <li><strong>RESTful API:</strong> Для обеспечения надежности и предсказуемости взаимодействия между клиентом и сервером.</li>
                  <li><strong>Обновления конфигураций:</strong> Для управления состоянием ресурсов без риска нежелательных изменений.</li>
                  <li><strong>Логирование операций:</strong> Для записи действий, которые могут быть безопасно повторены.</li>
                </ul>
              `,
            },
          ],
        },
        {
          title: "Протокол TCP и UDP",
          children: [
            {
              title: "Определение",
              type: "list",
              description: `
                <p>TCP (Transmission Control Protocol) и UDP (User Datagram Protocol) — это два основных протокола транспортного уровня в модели OSI, используемых для передачи данных по сети.</p>
              `,
            },
            {
              title: "TCP (Transmission Control Protocol)",
              type: "list",
              description: `
                <p>Характеристики TCP:</p>
                <ul>
                  <li><strong>Соединение:</strong> TCP устанавливает соединение между отправителем и получателем перед началом передачи данных (т.н. "трехстороннее рукопожатие").</li>
                  <li><strong>Надежность:</strong> Обеспечивает гарантированную доставку данных, проверку целостности и порядок их получения.</li>
                  <li><strong>Потоковая передача:</strong> Данные передаются в виде потока байтов, что позволяет обрабатывать большие объемы информации.</li>
                  <li><strong>Использование:</strong> Часто используется для приложений, требующих надежной передачи данных, таких как веб-сайты, электронная почта и FTP.</li>
                </ul>
              `,
            },
            {
              title: "UDP (User Datagram Protocol)",
              type: "list",
              description: `
                <p>Характеристики UDP:</p>
                <ul>
                  <li><strong>Без соединения:</strong> UDP не устанавливает соединение перед передачей данных, что снижает накладные расходы.</li>
                  <li><strong>Ненадежность:</strong> UDP не гарантирует доставку данных, их порядок или целостность. Потерянные пакеты не повторяются.</li>
                  <li><strong>Датаграммная передача:</strong> Данные передаются в виде отдельных пакетов (датаграмм), что может быть более эффективным для определенных приложений.</li>
                  <li><strong>Использование:</strong> Часто используется для приложений, требующих низкой задержки и скорости передачи, таких как потоковое видео, онлайн-игры и VoIP.</li>
                </ul>
              `,
            },
            {
              title: "Сравнение TCP и UDP",
              type: "list",
              description: `
                <p>Сравнение протоколов:</p>
                <ul>
                  <li><strong>Надежность:</strong> TCP — надежный, UDP — ненадежный.</li>
                  <li><strong>Скорость:</strong> UDP быстрее, поскольку нет накладных расходов на установление соединения и проверку целостности.</li>
                  <li><strong>Использование:</strong> TCP подходит для приложений, требующих надежности, тогда как UDP — для приложений, требующих скорости.</li>
                </ul>
              `,
            },
            {
              title: "Рекомендации",
              type: "list",
              description: `
                <p>Рекомендации по выбору протокола:</p>
                <ul>
                  <li><strong>Используйте TCP:</strong> Для приложений, где важна надежность, например, для передачи файлов и веб-трафика.</li>
                  <li><strong>Используйте UDP:</strong> Для приложений, где важна скорость и задержка, например, для видеоконференций и онлайн-игр.</li>
                </ul>
              `,
            },
          ],
        },
        {
          title: "Long Polling и Short Polling",
          children: [
            {
              title: "Определение",
              type: "list",
              description: `
                <p>Long Polling и Short Polling — это техники, используемые для получения данных с сервера в реальном времени, особенно в веб-приложениях.</p>
              `,
            },
            {
              title: "Short Polling",
              type: "list",
              description: `
                <p>Характеристики Short Polling:</p>
                <ul>
                  <li><strong>Метод:</strong> Клиент отправляет запрос к серверу через заданные интервалы времени (например, каждые 5 секунд).</li>
                  <li><strong>Ответ:</strong> Сервер обрабатывает запрос и сразу возвращает ответ, даже если нет новых данных.</li>
                  <li><strong>Эффективность:</strong> Может привести к излишним запросам и нагрузке на сервер, особенно если данные обновляются редко.</li>
                  <li><strong>Пример:</strong> Запросы на получение новых сообщений в чате каждые 5 секунд.</li>
                </ul>
              `,
            },
            {
              title: "Long Polling",
              type: "list",
              description: `
                <p>Характеристики Long Polling:</p>
                <ul>
                  <li><strong>Метод:</strong> Клиент отправляет запрос к серверу, и сервер удерживает соединение открытым до тех пор, пока не появятся новые данные.</li>
                  <li><strong>Ответ:</strong> Как только данные становятся доступны, сервер отправляет ответ клиенту, после чего клиент сразу же отправляет новый запрос.</li>
                  <li><strong>Эффективность:</strong> Более эффективен по сравнению с Short Polling, так как уменьшает количество запросов при отсутствии новых данных.</li>
                  <li><strong>Пример:</strong> Запросы на получение новых сообщений в реальном времени, где клиент ждет ответа от сервера до появления новых данных.</li>
                </ul>
              `,
            },
            {
              title: "Сравнение",
              type: "list",
              description: `
                <p>Сравнение Short Polling и Long Polling:</p>
                <ul>
                  <li><strong>Нагрузка на сервер:</strong> Short Polling может создавать избыточный трафик, в то время как Long Polling уменьшает количество запросов.</li>
                  <li><strong>Задержка:</strong> Long Polling обеспечивает более быструю реакцию на новые данные, так как сервер сразу отправляет ответ, когда они становятся доступны.</li>
                  <li><strong>Сложность реализации:</strong> Long Polling может быть сложнее в реализации, так как требует управления состоянием соединений.</li>
                </ul>
              `,
            },
            {
              title: "Рекомендации",
              type: "list",
              description: `
                <p>Рекомендации по выбору:</p>
                <ul>
                  <li><strong>Используйте Short Polling:</strong> В случаях, когда данные обновляются достаточно часто и сервер может справиться с нагрузкой.</li>
                  <li><strong>Используйте Long Polling:</strong> Когда необходимо получать данные в реальном времени с минимальными задержками и нагрузка на сервер должна быть снижена.</li>
                </ul>
              `,
            },
          ],
        },
        {
          title: "WebSocket и предшествующие технологии",
          children: [
            {
              title: "Определение WebSocket",
              type: "list",
              description: `
                <p>WebSocket — это протокол для двусторонней связи между клиентом и сервером через одно TCP-соединение. Он позволяет обмениваться данными в режиме реального времени без необходимости постоянно открывать и закрывать соединения.</p>
              `,
            },
            {
              title: "Предшествующие технологии",
              type: "list",
              description: `
                <p>До появления WebSocket использовались несколько технологий для реализации коммуникации в реальном времени:</p>
                <ul>
                  <li><strong>HTTP Polling:</strong>
                    <ul>
                      <li>Клиент периодически отправляет запросы к серверу, чтобы проверить наличие новых данных.</li>
                      <li>Неэффективно из-за постоянных запросов, даже если данных нет.</li>
                    </ul>
                  </li>
                  <li><strong>Long Polling:</strong>
                    <ul>
                      <li>Клиент отправляет запрос, и сервер удерживает соединение открытым до появления новых данных.</li>
                      <li>Когда данные доступны, сервер отправляет ответ, и клиент сразу же повторяет запрос.</li>
                    </ul>
                  </li>
                  <li><strong>Server-Sent Events (SSE):</strong>
                    <ul>
                      <li>Клиент устанавливает однонаправленное соединение с сервером, который может отправлять данные в реальном времени.</li>
                      <li>Использует стандартный HTTP, но не поддерживает двустороннюю связь.</li>
                    </ul>
                  </li>
                  <li><strong>AJAX:</strong>
                    <ul>
                      <li>Позволяет динамически загружать данные с сервера без перезагрузки страницы, но требует периодических запросов.</li>
                    </ul>
                  </li>
                </ul>
              `,
            },
            {
              title: "Преимущества WebSocket",
              type: "list",
              description: `
                <p>Преимущества использования WebSocket:</p>
                <ul>
                  <li><strong>Двусторонняя связь:</strong> Позволяет клиенту и серверу обмениваться данными в любое время без дополнительных запросов.</li>
                  <li><strong>Эффективность:</strong> Уменьшает накладные расходы на соединения, так как одно TCP-соединение используется для всего взаимодействия.</li>
                  <li><strong>Низкая задержка:</strong> Обеспечивает быструю передачу данных в реальном времени, что особенно важно для приложений, таких как чаты и онлайн-игры.</li>
                </ul>
              `,
            },
            {
              title: "Применение WebSocket",
              type: "list",
              description: `
                <p>WebSocket используется в различных приложениях:</p>
                <ul>
                  <li><strong>Чат-приложения:</strong> Обеспечивает мгновенную передачу сообщений между пользователями.</li>
                  <li><strong>Онлайн-игры:</strong> Позволяет игрокам взаимодействовать в реальном времени.</li>
                  <li><strong>Финансовые приложения:</strong> Для получения обновлений о ценах и торгах в реальном времени.</li>
                  <li><strong>Системы мониторинга:</strong> Обмен данными о состоянии систем и устройств в реальном времени.</li>
                </ul>
              `,
            },
          ],
        },
        {
          title: "Server-Sent Events (SSE)",
          children: [
            {
              title: "Определение",
              type: "list",
              description: `
                <p>Server-Sent Events (SSE) — это технология, позволяющая серверу отправлять обновления клиенту в режиме реального времени через однонаправленное HTTP-соединение.</p>
              `,
            },
            {
              title: "Основные характеристики",
              type: "list",
              description: `
                <p>Характеристики SSE:</p>
                <ul>
                  <li><strong>Однонаправленная связь:</strong> Сервер отправляет данные только клиенту, то есть от сервера к клиенту.</li>
                  <li><strong>HTTP-протокол:</strong> Использует стандартный HTTP, что облегчает интеграцию с существующими веб-приложениями.</li>
                  <li><strong>Поддержка текстовых данных:</strong> Данные отправляются в текстовом формате, обычно в формате JSON или простом тексте.</li>
                  <li><strong>Автоматическое восстановление соединения:</strong> Если соединение разрывается, клиент автоматически пытается переподключиться.</li>
                </ul>
              `,
            },
            {
              title: "Как работает SSE",
              type: "list",
              description: `
                <p>Процесс работы SSE:</p>
                <ul>
                  <li>Клиент отправляет запрос к серверу с заголовком <code>Accept: text/event-stream</code>.</li>
                  <li>Сервер устанавливает соединение и начинает отправлять данные в формате "event-stream".</li>
                  <li>Данные отправляются в виде текстовых сообщений, каждое из которых может содержать различные поля (например, <code>data:</code>, <code>event:</code>, <code>id:</code>).</li>
                  <li>Клиент обрабатывает полученные события и может обновлять интерфейс в реальном времени.</li>
                </ul>
              `,
            },
            {
              title: "Преимущества SSE",
              type: "list",
              description: `
                <p>Преимущества использования SSE:</p>
                <ul>
                  <li><strong>Простота реализации:</strong> Легко интегрируется с существующими веб-приложениями, так как использует стандартные HTTP-запросы.</li>
                  <li><strong>Поддержка браузеров:</strong> Большинство современных браузеров поддерживают SSE.</li>
                  <li><strong>Эффективность:</strong> Уменьшает накладные расходы на сетевые соединения по сравнению с регулярным опросом сервера.</li>
                </ul>
              `,
            },
            {
              title: "Недостатки SSE",
              type: "list",
              description: `
                <p>Недостатки SSE:</p>
                <ul>
                  <li><strong>Однонаправленная связь:</strong> Не поддерживает передачу данных от клиента к серверу, для этого необходимо использовать другие методы (например, AJAX).</li>
                  <li><strong>Ограниченная поддержка:</strong> Некоторые старые браузеры могут не поддерживать SSE.</li>
                  <li><strong>Задержки:</strong> В зависимости от реализации могут быть небольшие задержки в передаче данных.</li>
                </ul>
              `,
            },
            {
              title: "Применение SSE",
              type: "list",
              description: `
                <p>Ситуации, в которых используются SSE:</p>
                <ul>
                  <li><strong>Чат-приложения:</strong> Для получения новых сообщений от сервера.</li>
                  <li><strong>Обновления данных в реальном времени:</strong> Для отображения новостей, финансовых данных и т.п.</li>
                  <li><strong>Мониторинг систем:</strong> Для получения данных о состоянии серверов и приложений.</li>
                </ul>
              `,
            },
          ],
        },
        {
          title: "PATCH и PUT",
          children: [
            {
              title: "Определение",
              type: "list",
              description: `
                <p>PATCH и PUT — это HTTP-методы, используемые для обновления ресурсов на сервере, но они имеют различные подходы и цели.</p>
              `,
            },
            {
              title: "PUT",
              type: "list",
              description: `
                <p>Характеристики метода PUT:</p>
                <ul>
                  <li><strong>Обновление ресурса:</strong> PUT используется для полного обновления ресурса. Если ресурс не существует, он может быть создан.</li>
                  <li><strong>Идемпотентность:</strong> Повторные запросы PUT с одинаковыми данными не изменяют состояние ресурса после первого запроса.</li>
                  <li><strong>Требование полного представления:</strong> Клиент должен отправить все данные ресурса, даже если изменяется только часть из них.</li>
                  <li><strong>Пример:</strong> Отправка полного объекта пользователя для обновления всех его полей.</li>
                </ul>
              `,
            },
            {
              title: "PATCH",
              type: "list",
              description: `
                <p>Характеристики метода PATCH:</p>
                <ul>
                  <li><strong>Частичное обновление:</strong> PATCH используется для частичного обновления ресурса, позволяя изменять только необходимые поля.</li>
                  <li><strong>Неидемпотентность:</strong> Хотя PATCH может быть идемпотентным, это зависит от реализации. Повторные запросы могут иметь разные результаты.</li>
                  <li><strong>Гибкость:</strong> Клиент отправляет только изменяемые поля, что уменьшает объем передаваемых данных.</li>
                  <li><strong>Пример:</strong> Отправка только обновленного адреса электронной почты пользователя без необходимости отправлять остальные данные.</li>
                </ul>
              `,
            },
            {
              title: "Сравнение PUT и PATCH",
              type: "list",
              description: `
                <p>Сравнение методов PUT и PATCH:</p>
                <ul>
                  <li><strong>Обновление:</strong> PUT требует полного ресурса, тогда как PATCH требует только измененных полей.</li>
                  <li><strong>Идемпотентность:</strong> PUT всегда идемпотентен, PATCH может быть идемпотентным, но не всегда.</li>
                  <li><strong>Применение:</strong> PUT чаще используется для полных обновлений, PATCH — для частичных изменений.</li>
                </ul>
              `,
            },
            {
              title: "Рекомендации по использованию",
              type: "list",
              description: `
                <p>Когда использовать PUT и PATCH:</p>
                <ul>
                  <li><strong>Используйте PUT:</strong> Когда необходимо полностью обновить ресурс или создать его, если он не существует.</li>
                  <li><strong>Используйте PATCH:</strong> Когда нужно внести небольшие изменения в существующий ресурс без необходимости отправлять все его данные.</li>
                </ul>
              `,
            },
          ],
        },
        {
          title: "GET и POST",
          children: [
            {
              title: "Определение",
              type: "list",
              description: `
                <p>GET и POST — это два основных метода HTTP, используемых для взаимодействия с ресурсами на сервере. Они имеют различные цели и особенности.</p>
              `,
            },
            {
              title: "GET",
              type: "list",
              description: `
                <p>Характеристики метода GET:</p>
                <ul>
                  <li><strong>Запрос данных:</strong> GET используется для получения данных с сервера. Запросы обычно не изменяют состояние сервера.</li>
                  <li><strong>Идемпотентность:</strong> Повторные запросы GET с одинаковыми параметрами возвращают один и тот же результат и не изменяют ресурс.</li>
                  <li><strong>Передача данных:</strong> Данные передаются через URL в строке запроса (query string). Ограничение на длину URL может варьироваться в зависимости от браузера.</li>
                  <li><strong>Кэширование:</strong> Ответы на GET-запросы могут быть кэшированы браузерами и прокси-серверами.</li>
                  <li><strong>Пример:</strong> Запрос для получения списка пользователей: <code>GET /users</code>.</li>
                </ul>
              `,
            },
            {
              title: "POST",
              type: "list",
              description: `
                <p>Характеристики метода POST:</p>
                <ul>
                  <li><strong>Отправка данных:</strong> POST используется для отправки данных на сервер, например, для создания нового ресурса или выполнения действия.</li>
                  <li><strong>Неидемпотентность:</strong> Повторные запросы POST могут создавать несколько одинаковых ресурсов или изменять состояние сервера.</li>
                  <li><strong>Передача данных:</strong> Данные отправляются в теле запроса, что позволяет передавать большие объемы информации и сложные структуры (например, JSON).</li>
                  <li><strong>Кэширование:</strong> Ответы на POST-запросы обычно не кэшируются.</li>
                  <li><strong>Пример:</strong> Запрос для создания нового пользователя: <code>POST /users</code> с телом запроса, содержащим данные пользователя.</li>
                </ul>
              `,
            },
            {
              title: "Сравнение GET и POST",
              type: "list",
              description: `
                <p>Сравнение методов GET и POST:</p>
                <ul>
                  <li><strong>Цель:</strong> GET используется для получения данных, POST — для отправки данных на сервер.</li>
                  <li><strong>Идемпотентность:</strong> GET идемпотентен, POST — нет.</li>
                  <li><strong>Объем данных:</strong> GET ограничен длиной URL, POST позволяет отправлять большие объемы данных в теле запроса.</li>
                  <li><strong>Кэширование:</strong> GET-запросы могут кэшироваться, POST-запросы — обычно нет.</li>
                </ul>
              `,
            },
            {
              title: "Рекомендации по использованию",
              type: "list",
              description: `
                <p>Когда использовать GET и POST:</p>
                <ul>
                  <li><strong>Используйте GET:</strong> Когда необходимо получить данные с сервера, и запрос не должен изменять состояние ресурса.</li>
                  <li><strong>Используйте POST:</strong> Когда нужно отправить данные на сервер для создания или изменения ресурса.</li>
                </ul>
              `,
            },
          ],
        },
        {
          title: "OPTIONS",
          children: [
            {
              title: "Определение",
              type: "list",
              description: `
                <p>Метод OPTIONS в HTTP используется для получения информации о том, какие методы и заголовки поддерживаются сервером для определенного ресурса или по определенному URL.</p>
              `,
            },
            {
              title: "Характеристики",
              type: "list",
              description: `
                <p>Характеристики метода OPTIONS:</p>
                <ul>
                  <li><strong>Запрос информации:</strong> OPTIONS позволяет клиенту узнать, какие методы могут быть использованы для взаимодействия с ресурсом.</li>
                  <li><strong>Не изменяет состояние:</strong> Запросы OPTIONS не изменяют состояние ресурса на сервере и являются идемпотентными.</li>
                  <li><strong>Используются в CORS:</strong> Метод OPTIONS часто используется в механизме Cross-Origin Resource Sharing (CORS) для проверки разрешенных методов и заголовков при кросс-доменных запросах.</li>
                  <li><strong>Ответ сервера:</strong> Сервер может вернуть заголовок <code>Allow</code>, указывающий на поддерживаемые методы для данного ресурса.</li>
                </ul>
              `,
            },
            {
              title: "Применение",
              type: "list",
              description: `
                <p>Метод OPTIONS используется в следующих сценариях:</p>
                <ul>
                  <li><strong>Документация API:</strong> Позволяет клиентам узнать, какие методы доступны для работы с API.</li>
                  <li><strong>Кросс-доменные запросы:</strong> В CORS для проверки разрешений на запросы с других доменов.</li>
                  <li><strong>Тестирование и отладка:</strong> Для диагностики и тестирования доступных методов и функциональности сервера.</li>
                </ul>
              `,
            },
            {
              title: "Пример запроса",
              type: "list",
              description: `
                <p>Пример запроса OPTIONS:</p>
                <pre><code>OPTIONS /api/users HTTP/1.1
        Host: example.com
        </code></pre>
                <p>Ответ сервера может выглядеть так:</p>
                <pre><code>HTTP/1.1 200 OK
        Allow: GET, POST, OPTIONS
        </code></pre>
              `,
            },
          ],
        },
        {
          title: "Модель OSI",
          children: [
            {
              title: "Определение",
              type: "list",
              description: `
                <p>Модель OSI (Open Systems Interconnection) — это концептуальная модель, разработанная для стандартизации процессов взаимодействия компьютерных систем в сети. Она делит сетевые функции на семь уровней, каждый из которых выполняет свою уникальную роль.</p>
              `,
            },
            {
              title: "Уровни модели OSI",
              type: "list",
              description: `
                <p>Семь уровней модели OSI:</p>
                <ol>
                  <li><strong>Физический уровень:</strong> Определяет физические средства передачи данных (кабели, разъемы, электрические сигналы).</li>
                  <li><strong>Канальный уровень:</strong> Обеспечивает надежную передачу данных через физический уровень, включая управление доступом к среде и исправление ошибок.</li>
                  <li><strong>Сетевой уровень:</strong> Отвечает за маршрутизацию данных между сетями и определение логических адресов (например, IP-адреса).</li>
                  <li><strong>Транспортный уровень:</strong> Обеспечивает надежную передачу данных между конечными узлами и управляет потоками данных (например, TCP, UDP).</li>
                  <li><strong>Сессионный уровень:</strong> Управляет сеансами связи между приложениями, устанавливая, поддерживая и завершая соединения.</li>
                  <li><strong>Представительский уровень:</strong> Обеспечивает преобразование данных в формат, понятный приложениям, включая шифрование и сжатие.</li>
                  <li><strong>Прикладной уровень:</strong> Обеспечивает интерфейсы для взаимодействия приложений с сетевыми службами (например, HTTP, FTP, SMTP).</li>
                </ol>
              `,
            },
            {
              title: "Применение модели OSI",
              type: "list",
              description: `
                <p>Модель OSI используется в следующих целях:</p>
                <ul>
                  <li><strong>Стандартизация:</strong> Обеспечивает общую основу для разработки сетевых протоколов и технологий.</li>
                  <li><strong>Обучение:</strong> Помогает понять и изучить, как работают сетевые технологии.</li>
                  <li><strong>Устранение неполадок:</strong> Позволяет системным администраторам и инженерам диагностировать и исправлять проблемы в сетях.</li>
                </ul>
              `,
            },
            {
              title: "Сравнение с моделью TCP/IP",
              type: "list",
              description: `
                <p>Сравнение модели OSI и модели TCP/IP:</p>
                <ul>
                  <li><strong>Количество уровней:</strong> OSI имеет 7 уровней, TCP/IP — 4 уровня.</li>
                  <li><strong>Применение:</strong> OSI является теоретической моделью, тогда как TCP/IP более практична и широко используется в интернете.</li>
                  <li><strong>Стандартизация:</strong> OSI разработана как стандартная модель, TCP/IP развивалась через реализацию протоколов.</li>
                </ul>
              `,
            },
          ],
        },
        {
          title: "Метод CONNECT",
          children: [
            {
              title: "Определение",
              type: "list",
              description: `
                <p>Метод CONNECT в HTTP используется для установления туннельного соединения к серверу через прокси-сервер. Этот метод позволяет клиенту устанавливать TCP-соединение с сервером через прокси, что полезно для работы с зашифрованными соединениями, такими как HTTPS.</p>
              `,
            },
            {
              title: "Характеристики",
              type: "list",
              description: `
                <p>Характеристики метода CONNECT:</p>
                <ul>
                  <li><strong>Туннелирование:</strong> Метод CONNECT создает туннель для передачи данных между клиентом и сервером через прокси-сервер.</li>
                  <li><strong>Использование с HTTPS:</strong> Обычно применяется для передачи зашифрованного HTTPS-трафика через прокси.</li>
                  <li><strong>Неизменяемость запросов:</strong> Все данные передаются без изменений, что позволяет поддерживать безопасность соединения.</li>
                  <li><strong>Ответ прокси-сервера:</strong> Прокси-сервер отвечает на запрос CONNECT с кодом 200 (OK), если соединение успешно установлено.</li>
                </ul>
              `,
            },
            {
              title: "Применение",
              type: "list",
              description: `
                <p>Метод CONNECT используется в следующих ситуациях:</p>
                <ul>
                  <li><strong>Доступ к защищенным ресурсам:</strong> Позволяет клиентам подключаться к защищенным ресурсам через прокси-серверы.</li>
                  <li><strong>Обход ограничений:</strong> Используется для обхода сетевых фильтров и блокировок, позволяя осуществлять безопасное соединение.</li>
                  <li><strong>Шифрование данных:</strong> Обеспечивает шифрование трафика между клиентом и сервером в случаях, когда это необходимо.</li>
                </ul>
              `,
            },
            {
              title: "Пример запроса",
              type: "list",
              description: `
                <p>Пример запроса CONNECT:</p>
                <pre><code>CONNECT www.example.com:443 HTTP/1.1
        Host: www.example.com:443
        </code></pre>
                <p>Ответ прокси-сервера может выглядеть так:</p>
                <pre><code>HTTP/1.1 200 Connection Established
        </code></pre>
              `,
            },
          ],
        },
        {
          title: "Request/Response",
          children: [
            {
              title: "Определение",
              type: "list",
              description: `
                <p>Модель Request/Response (Запрос/Ответ) — это основополагающая модель взаимодействия в сетевых протоколах, особенно в HTTP. Она описывает процесс, при котором клиент отправляет запрос на сервер, а сервер отвечает на этот запрос.</p>
              `,
            },
            {
              title: "Структура запроса",
              type: "list",
              description: `
                <p>Структура HTTP-запроса включает следующие компоненты:</p>
                <ul>
                  <li><strong>Метод:</strong> Тип запроса (например, GET, POST, PUT, DELETE).</li>
                  <li><strong>URL:</strong> Адрес ресурса, к которому осуществляется запрос.</li>
                  <li><strong>Версия протокола:</strong> Версия HTTP (например, HTTP/1.1).</li>
                  <li><strong>Заголовки:</strong> Дополнительные данные о запросе (например, Content-Type, User-Agent).</li>
                  <li><strong>Тело запроса:</strong> (опционально) Данные, отправляемые с запросом (например, данные формы).</li>
                </ul>
              `,
            },
            {
              title: "Структура ответа",
              type: "list",
              description: `
                <p>Структура HTTP-ответа включает следующие компоненты:</p>
                <ul>
                  <li><strong>Версия протокола:</strong> Версия HTTP (например, HTTP/1.1).</li>
                  <li><strong>Код состояния:</strong> Код, указывающий на результат обработки запроса (например, 200 OK, 404 Not Found).</li>
                  <li><strong>Фраза состояния:</strong> Описание кода состояния (например, "OK", "Not Found").</li>
                  <li><strong>Заголовки:</strong> Дополнительные данные об ответе (например, Content-Type, Content-Length).</li>
                  <li><strong>Тело ответа:</strong> (опционально) Данные, возвращаемые в ответе (например, HTML-код, JSON-данные).</li>
                </ul>
              `,
            },
            {
              title: "Процесс взаимодействия",
              type: "list",
              description: `
                <p>Процесс взаимодействия между клиентом и сервером:</p>
                <ol>
                  <li>Клиент формирует запрос, используя нужный метод и адрес ресурса.</li>
                  <li>Запрос отправляется на сервер через сеть.</li>
                  <li>Сервер обрабатывает запрос и формирует ответ.</li>
                  <li>Ответ отправляется обратно клиенту.</li>
                  <li>Клиент обрабатывает ответ и выполняет необходимые действия (например, отображает данные пользователю).</li>
                </ol>
              `,
            },
            {
              title: "Применение",
              type: "list",
              description: `
                <p>Модель Request/Response используется в различных приложениях и протоколах:</p>
                <ul>
                  <li><strong>Веб-приложения:</strong> Основной механизм взаимодействия между клиентами (браузерами) и серверами.</li>
                  <li><strong>API:</strong> RESTful и другие API используют модель Request/Response для обмена данными.</li>
                  <li><strong>Службы обмена сообщениями:</strong> Многие протоколы обмена сообщениями основаны на модели запросов и ответов.</li>
                </ul>
              `,
            },
          ],
        },
        {
          title: "CORS",
          children: [
            {
              title: "Определение",
              type: "list",
              description: `
                <p>CORS (Cross-Origin Resource Sharing) — это механизм, который позволяет ограничивать или разрешать доступ к ресурсам на веб-сервере из других источников (доменных имен). Он используется для обеспечения безопасности при выполнении запросов между разными доменами.</p>
              `,
            },
            {
              title: "Проблема кросс-доменных запросов",
              type: "list",
              description: `
                <p>Современные браузеры применяют политику одного источника (Same-Origin Policy), которая ограничивает выполнение запросов с одного домена к ресурсам другого домена. CORS позволяет обойти это ограничение при помощи специальных HTTP-заголовков.</p>
              `,
            },
            {
              title: "Как работает CORS",
              type: "list",
              description: `
                <p>Процесс работы CORS включает следующие шаги:</p>
                <ol>
                  <li>Клиент (например, браузер) отправляет запрос к ресурсу на другом домене.</li>
                  <li>Сервер проверяет, разрешен ли доступ с указанного источника.</li>
                  <li>Если доступ разрешен, сервер добавляет необходимые CORS-заголовки в ответ.</li>
                  <li>Браузер обрабатывает ответ и, в зависимости от заголовков, позволяет или блокирует доступ к данным.</li>
                </ol>
              `,
            },
            {
              title: "Основные CORS-заголовки",
              type: "list",
              description: `
                <p>Некоторые ключевые заголовки, связанные с CORS:</p>
                <ul>
                  <li><strong>Access-Control-Allow-Origin:</strong> Указывает, какие источники могут получать доступ к ресурсу (например, <code>*</code> для всех).</li>
                  <li><strong>Access-Control-Allow-Methods:</strong> Указывает, какие HTTP-методы разрешены для кросс-доменных запросов (например, GET, POST).</li>
                  <li><strong>Access-Control-Allow-Headers:</strong> Указывает, какие заголовки могут быть использованы в запросе.</li>
                  <li><strong>Access-Control-Allow-Credentials:</strong> Указывает, разрешено ли использование учетных данных (например, куки) в кросс-доменных запросах.</li>
                </ul>
              `,
            },
            {
              title: "Предварительные запросы",
              type: "list",
              description: `
                <p>В некоторых случаях браузеры отправляют предварительный запрос (preflight request) с методом OPTIONS, чтобы проверить, разрешены ли кросс-доменные запросы с указанным методом и заголовками.</p>
              `,
            },
            {
              title: "Применение",
              type: "list",
              description: `
                <p>CORS широко используется в веб-разработке для:</p>
                <ul>
                  <li><strong>API:</strong> Обеспечения безопасного доступа к ресурсам API с разных доменов.</li>
                  <li><strong>Веб-приложения:</strong> Разрешения взаимодействия между различными веб-приложениями и сервисами.</li>
                  <li><strong>Мобильные приложения:</strong> Обеспечения доступа к веб-ресурсам из мобильных приложений.</li>
                </ul>
              `,
            },
          ],
        },
        {
          title: "CRP",
          children: [
            {
              title: "1. Что такое CRP?",
              type: "text",
              description: `
                <p>CRP (Cross-Origin Resource Policy) - это механизм безопасности, который позволяет управлять доступом к ресурсам на основе их источника.</p>
                <p>Он используется для определения, какие ресурсы могут быть использованы в контексте других источников.</p>
              `,
            },
            {
              title: "2. Зачем нужен CRP?",
              type: "text",
              description: `
                <p>CRP помогает предотвратить атаки, такие как:</p>
                <ul>
                  <li>Cross-Site Scripting (XSS)</li>
                  <li>Cross-Origin Resource Sharing (CORS)</li>
                </ul>
                <p>Это позволяет разработчикам контролировать, какие внешние ресурсы могут взаимодействовать с их приложениями.</p>
              `,
            },
            {
              title: "3. Как работает CRP?",
              type: "text",
              description: `
                <p>CRP работает путем добавления заголовков HTTP к ресурсам, которые определяют правила доступа.</p>
                <p>Примеры заголовков:</p>
                <ul>
                  <li><code>Cross-Origin-Resource-Policy: same-origin</code> - Разрешает доступ только с того же источника.</li>
                  <li><code>Cross-Origin-Resource-Policy: cross-origin</code> - Разрешает доступ с любых источников.</li>
                </ul>
              `,
            },
            {
              title: "4. Пример использования CRP",
              type: "code",
              description: `
                <p>Пример настройки заголовка CRP в серверном приложении:</p>
              `,
              code: `
        response.setHeader('Cross-Origin-Resource-Policy', 'same-origin');
              `
            },
            {
              title: "5. Когда использовать CRP?",
              type: "text",
              description: `
                <p>CRP следует использовать, когда:</p>
                <ul>
                  <li>Необходимо защитить ресурсы от несанкционированного доступа.</li>
                  <li>Приложение взаимодействует с ресурсами из разных источников.</li>
                  <li>Хотите контролировать доступ к вашим ресурсам на уровне безопасности.</li>
                </ul>
              `,
            },
          ],
        },
        {
          title: "REST",
          children: [
            {
              title: "Определение",
              type: "list",
              description: `
                <p>REST (Representational State Transfer) — это архитектурный стиль, используемый для разработки веб-сервисов. Он основывается на принципах работы HTTP и предназначен для упрощения взаимодействия между клиентом и сервером.</p>
              `,
            },
            {
              title: "Принципы REST",
              type: "list",
              description: `
                <p>Основные принципы REST:</p>
                <ul>
                  <li><strong>Клиент-сервер:</strong> Четкое разделение между клиентом и сервером, что позволяет развивать их независимо.</li>
                  <li><strong>Статусность:</strong> Каждый запрос от клиента к серверу должен содержать всю необходимую информацию для его обработки.</li>
                  <li><strong>Кэширование:</strong> Ответы могут быть кэшированы для повышения производительности и уменьшения нагрузки на сервер.</li>
                  <li><strong>Единый интерфейс:</strong> Упрощает архитектуру, делая взаимодействие предсказуемым и стандартизированным.</li>
                  <li><strong>Слои:</strong> Архитектура может состоять из нескольких слоев, что позволяет улучшать масштабируемость и безопасность.</li>
                </ul>
              `,
            },
            {
              title: "HTTP-методы в REST",
              type: "list",
              description: `
                <p>REST использует стандартные HTTP-методы для выполнения операций над ресурсами:</p>
                <ul>
                  <li><strong>GET:</strong> Получение информации о ресурсе.</li>
                  <li><strong>POST:</strong> Создание нового ресурса.</li>
                  <li><strong>PUT:</strong> Обновление существующего ресурса.</li>
                  <li><strong>DELETE:</strong> Удаление ресурса.</li>
                </ul>
              `,
            },
            {
              title: "Ресурсы и URI",
              type: "list",
              description: `
                <p>В REST ресурсы идентифицируются с помощью URI (Uniform Resource Identifier). Каждому ресурсу соответствует уникальный URI, по которому можно получить доступ к этому ресурсу.</p>
              `,
            },
            {
              title: "Форматы данных",
              type: "list",
              description: `
                <p>RESTful API может использовать различные форматы данных для обмена информацией, включая:</p>
                <ul>
                  <li><strong>JSON:</strong> Наиболее распространенный формат для передачи данных.</li>
                  <li><strong>XML:</strong> Используется реже, но все еще поддерживается.</li>
                  <li><strong>HTML:</strong> Может использоваться для возвращения веб-страниц.</li>
                </ul>
              `,
            },
            {
              title: "Применение",
              type: "list",
              description: `
                <p>REST широко используется в разработке веб-приложений и API:</p>
                <ul>
                  <li><strong>Веб-сервисы:</strong> Основной подход для создания API, который взаимодействует с клиентами.</li>
                  <li><strong>Мобильные приложения:</strong> Используются RESTful API для обмена данными с сервером.</li>
                  <li><strong>Интеграция систем:</strong> REST позволяет интегрировать различные системы и сервисы.</li>
                </ul>
              `,
            },
          ],
        },
        {
          title: "Web-угрозы",
          children: [
            {
              title: "Определение",
              type: "list",
              description: `
                <p>Web-угрозы — это потенциальные опасности, связанные с использованием веб-технологий и интернет-ресурсов, которые могут привести к компрометации данных, нарушению конфиденциальности или повреждению систем.</p>
              `,
            },
            {
              title: "Типы Web-угроз",
              type: "list",
              description: `
                <p>Основные типы Web-угроз:</p>
                <ul>
                  <li><strong>Вредоносное ПО:</strong> Программы, такие как вирусы, черви и трояны, которые могут заражать устройства и вызывать ущерб.</li>
                  <li><strong>Фишинг:</strong> Мошеннические попытки получить конфиденциальную информацию, выдавая себя за надежные источники.</li>
                  <li><strong>SQL-инъекции:</strong> Атаки, нацеленные на базы данных через уязвимости в веб-приложениях, позволяющие злоумышленникам выполнять произвольные SQL-запросы.</li>
                  <li><strong>Кросс-сайтовый скриптинг (XSS):</strong> Уязвимость, позволяющая злоумышленникам внедрять скрипты на страницы, которые просматривают другие пользователи.</li>
                  <li><strong>Отказ в обслуживании (DoS/DDoS):</strong> Атаки, направленные на перегрузку сайта или сервиса, что делает его недоступным для пользователей.</li>
                  <li><strong>Сниффинг:</strong> Перехват сетевого трафика с целью получения конфиденциальной информации.</li>
                </ul>
              `,
            },
            {
              title: "Причины Web-угроз",
              type: "list",
              description: `
                <p>Причины возникновения Web-угроз:</p>
                <ul>
                  <li><strong>Уязвимости программного обеспечения:</strong> Ошибки в коде, которые могут быть использованы злоумышленниками.</li>
                  <li><strong>Неправильная конфигурация:</strong> Ошибки в настройках серверов и приложений, которые могут создать уязвимости.</li>
                  <li><strong>Человеческий фактор:</strong> Невнимательность пользователей, например, кликание на подозрительные ссылки или открытие вложений от незнакомцев.</li>
                </ul>
              `,
            },
            {
              title: "Защита от Web-угроз",
              type: "list",
              description: `
                <p>Методы защиты от Web-угроз:</p>
                <ul>
                  <li><strong>Использование антивирусного ПО:</strong> Для защиты устройств от вредоносных программ.</li>
                  <li><strong>Обновление программного обеспечения:</strong> Регулярное обновление систем и приложений для устранения уязвимостей.</li>
                  <li><strong>Использование брандмауэров:</strong> Для фильтрации трафика и защиты сети.</li>
                  <li><strong>Обучение пользователей:</strong> Повышение осведомленности о потенциальных угрозах и безопасном поведении в интернете.</li>
                  <li><strong>Резервное копирование данных:</strong> Регулярное создание резервных копий для защиты от потери данных.</li>
                </ul>
              `,
            },
            {
              title: "Заключение",
              type: "list",
              description: `
                <p>Web-угрозы представляют собой серьезную проблему для пользователей и организаций. Понимание типов угроз и методов защиты поможет минимизировать риски и обеспечить безопасность в интернете.</p>
              `,
            },
          ],
        },
        {
          title: "Заголовки HTTP",
          children: [
            {
              title: "Определение",
              type: "list",
              description: `
                <p>Заголовки HTTP — это части HTTP-запросов и ответов, которые содержат метаинформацию о сообщении. Они используются для передачи информации между клиентом и сервером, определяя параметры запроса или ответа.</p>
              `,
            },
            {
              title: "Типы заголовков",
              type: "list",
              description: `
                <p>Заголовки HTTP делятся на несколько категорий:</p>
                <ul>
                  <li><strong>Общие заголовки:</strong> Применяются как в запросах, так и в ответах (например, Date, Connection).</li>
                  <li><strong>Заголовки запроса:</strong> Используются только в запросах от клиента к серверу (например, Accept, User-Agent).</li>
                  <li><strong>Заголовки ответа:</strong> Используются только в ответах от сервера к клиенту (например, Server, WWW-Authenticate).</li>
                  <li><strong>Заголовки сущностей:</strong> Применяются для описания тела сообщения, включая тип и длину контента (например, Content-Type, Content-Length).</li>
                </ul>
              `,
            },
            {
              title: "Примеры заголовков",
              type: "list",
              description: `
                <p>Некоторые распространенные заголовки HTTP:</p>
                <ul>
                  <li><strong>Content-Type:</strong> Указывает тип данных, отправляемых в теле сообщения (например, application/json, text/html).</li>
                  <li><strong>Authorization:</strong> Содержит учетные данные для аутентификации пользователя.</li>
                  <li><strong>Accept:</strong> Указывает, какие типы контента клиент готов принимать.</li>
                  <li><strong>User-Agent:</strong> Информация о клиентском приложении, которое делает запрос (например, браузер).</li>
                  <li><strong>Cookie:</strong> Передает данные о сессии пользователя на сервер.</li>
                  <li><strong>Cache-Control:</strong> Указывает, как кэшировать ответ (например, no-cache, max-age).</li>
                </ul>
              `,
            },
            {
              title: "Роль заголовков в HTTP",
              type: "list",
              description: `
                <p>Заголовки HTTP играют важную роль в:</p>
                <ul>
                  <li><strong>Управлении сессиями:</strong> Позволяют передавать информацию о пользователях и их сессиях.</li>
                  <li><strong>Кэшировании:</strong> Помогают управлять кэшированием данных, улучшая производительность и уменьшение нагрузки на сервер.</li>
                  <li><strong>Безопасности:</strong> Обеспечивают аутентификацию и авторизацию пользователей через заголовки.</li>
                </ul>
              `,
            },
            {
              title: "Заключение",
              type: "list",
              description: `
                <p>Заголовки HTTP являются важной частью протокола и обеспечивают гибкость и функциональность в обмене данными между клиентами и серверами. Понимание их структуры и назначения помогает эффективно разрабатывать и использовать веб-приложения.</p>
              `,
            },
          ],
        },
        {
          title: "Response Codes",
          children: [
            {
              title: "Определение",
              type: "list",
              description: `
                <p>Коды ответа (Response Codes) — это числовые коды, которые сервер возвращает в ответ на HTTP-запросы. Они указывают на статус обработки запроса и помогают клиенту понять, что произошло с запросом.</p>
              `,
            },
            {
              title: "Структура кодов ответа",
              type: "list",
              description: `
                <p>Коды ответа HTTP состоят из трех цифр и делятся на пять основных классов:</p>
                <ul>
                  <li><strong>1xx (Информационные):</strong> Указывают, что запрос получен и продолжается обработка (например, 100 Continue).</li>
                  <li><strong>2xx (Успех):</strong> Указывают, что запрос был успешно обработан (например, 200 OK, 201 Created).</li>
                  <li><strong>3xx (Перенаправление):</strong> Указывают, что для завершения запроса необходимо выполнить дополнительные действия (например, 301 Moved Permanently, 302 Found).</li>
                  <li><strong>4xx (Ошибка клиента):</strong> Указывают на проблемы с запросом, отправленным клиентом (например, 400 Bad Request, 404 Not Found).</li>
                  <li><strong>5xx (Ошибка сервера):</strong> Указывают на ошибки, возникшие на стороне сервера при обработке запроса (например, 500 Internal Server Error, 503 Service Unavailable).</li>
                </ul>
              `,
            },
            {
              title: "Примеры кодов ответа",
              type: "list",
              description: `
                <p>Некоторые распространенные коды ответа:</p>
                <ul>
                  <li><strong>200 OK:</strong> Запрос успешно обработан, и сервер возвращает запрашиваемые данные.</li>
                  <li><strong>201 Created:</strong> Запрос успешно обработан, и создан новый ресурс.</li>
                  <li><strong>204 No Content:</strong> Запрос успешно обработан, но нет данных для возврата.</li>
                  <li><strong>400 Bad Request:</strong> Запрос содержит неверный синтаксис или не может быть выполнен.</li>
                  <li><strong>401 Unauthorized:</strong> Для доступа к ресурсу требуется аутентификация.</li>
                  <li><strong>403 Forbidden:</strong> Сервер отказывается выполнять запрос, несмотря на наличие аутентификации.</li>
                  <li><strong>404 Not Found:</strong> Запрашиваемый ресурс не найден на сервере.</li>
                  <li><strong>500 Internal Server Error:</strong> Произошла ошибка на сервере, и запрос не может быть выполнен.</li>
                  <li><strong>503 Service Unavailable:</strong> Сервер временно недоступен, возможно, из-за перегрузки или обслуживания.</li>
                </ul>
              `,
            },
            {
              title: "Роль кодов ответа",
              type: "list",
              description: `
                <p>Коды ответа играют важную роль в веб-разработке:</p>
                <ul>
                  <li><strong>Управление потоком данных:</strong> Позволяют клиенту понимать статус выполнения запросов и реагировать соответствующим образом.</li>
                  <li><strong>Отладка:</strong> Помогают разработчикам находить и исправлять ошибки в приложениях.</li>
                  <li><strong>Улучшение пользовательского опыта:</strong> Предоставляют пользователям информацию о состоянии их запросов и возможных ошибках.</li>
                </ul>
              `,
            },
            {
              title: "Заключение",
              type: "list",
              description: `
                <p>Коды ответа являются важной частью протокола HTTP и необходимы для эффективного взаимодействия между клиентами и серверами. Понимание их значений и использования помогает в разработке и отладке веб-приложений.</p>
              `,
            },
          ],
        },
      ]
    },
    {
      title: "HTML/CSS",
      children: [
        {
          title: "Style",
          children: [
            {
              title: "CSS",
              children: [
                {
                  title: "Способы подключения стилей в HTML",
                  children: [
                    {
                      title: "1. Внешний стиль (External CSS)",
                      type: "list",
                      description: `
                        <p>Подключение стилей через отдельный файл:</p>
                        <ul>
                          <li><strong>Используемый тег</strong>: <code>&lt;link&gt;</code>.</li>
                          <li><strong>Пример</strong>: 
                            <code>&lt;link rel="stylesheet" href="styles.css"&gt;</code>.
                          </li>
                          <li><strong>Преимущества</strong>: Упрощает управление стилями и позволяет повторно использовать их на нескольких страницах.</li>
                        </ul>
                      `,
                    },
                    {
                      title: "2. Встроенный стиль (Internal CSS)",
                      type: "list",
                      description: `
                        <p>Подключение стилей в <code>&lt;head&gt;</code> документа:</p>
                        <ul>
                          <li><strong>Используемый тег</strong>: <code>&lt;style&gt;</code>.</li>
                          <li><strong>Пример</strong>: 
                            <code>&lt;style&gt; body { background-color: lightblue; } &lt;/style&gt;</code>.
                          </li>
                          <li><strong>Преимущества</strong>: Удобно для небольших проектов или когда стили специфичны для одной страницы.</li>
                        </ul>
                      `,
                    },
                    {
                      title: "3. Инлайновый стиль (Inline CSS)",
                      type: "list",
                      description: `
                        <p>Применение стилей непосредственно к элементам:</p>
                        <ul>
                          <li><strong>Используемый атрибут</strong>: <code>style</code>.</li>
                          <li><strong>Пример</strong>: 
                            <code>&lt;h1 style="color: red;"&gt;Заголовок&lt;/h1&gt;</code>.
                          </li>
                          <li><strong>Преимущества</strong>: Быстрое применение стилей к отдельным элементам, но может привести к дублированию кода.</li>
                        </ul>
                      `,
                    },
                  ],
                },
                {
                  title: "Вес селектора или что такое специфичность в CSS",
                  children: [
                    {
                      title:
                        "Специфичность в CSS определяет, какой стиль применяется к элементу при наличии множества правил. Она рассчитывается на основе различных типов селекторов:",
                      type: "code",
                      description: `
                        <ul>
                          <li><strong>глобальный селектор *</strong>: не имеет веса</li>
                          <li><strong>Инлайновые стили</strong>: 1000</li>
                          <li><strong>ID-селекторы</strong>: 100</li>
                          <li><strong>Классы, атрибуты и псевдоклассы</strong>: 10</li>
                          <li><strong>Теги и псевдоэлементы</strong>: 1</li>
                        </ul>
                        <p>Пример:</p>
                      `,
                      code: `
// Специфичность: 0 (глобальный селектор)
* {
  color: black;
}                    

/* Специфичность: 1 (тег) */
p {
  color: blue;
}

/* Специфичность: 10 (класс) */
.myClass {
  color: red;
}

/* Специфичность: 100 (ID) */
#myId {
  color: green;
}

/* Специфичность: 1000 (инлайн стиль) */
&lt;p style="color: yellow;"&gt;Hello&lt;/p&gt;
                      `,
                    },
                  ],
                },
                {
                  title: "Псевдоклассы и псевдоэлементы",
                  children: [
                    {
                      title:
                        "Псевдоклассы и псевдоэлементы позволяют стилизовать элементы на основе их состояния или позиции:",
                      type: "code",
                      description: `
                        <ul>
                          <li><strong>Псевдоклассы</strong>: <code>:hover</code>, <code>:focus</code>, <code>:nth-child()</code></li>
                          <li><strong>Псевдоэлементы</strong>: <code>::before</code>, <code>::after</code>, <code>::first-line</code></li>
                        </ul>
                        <p>Пример:</p>
                      `,
                      code: `
/* Псевдокласс */
a:hover {
color: blue;
}

/* Псевдоэлемент */
p::first-line {
font-weight: bold;
}
                      `,
                    },
                  ],
                },
                {
                  title: "Коробчатая модель (box-sizing)",
                  children: [
                    {
                      title: "Коробчатая модель описывает пространство, занимаемое элементом",
                      type: "code",
                      description: `
                        <p>Она включает в себя следующие свойства:</p>
                        <ul>
                          <li><strong>Content</strong>: Содержимое элемента.</li>
                          <li><strong>Padding</strong>: Поля вокруг содержимого.</li>
                          <li><strong>Border</strong>: Граница вокруг элемента.</li>
                          <li><strong>Margin</strong>: Отступы между элементами.</li>
                        </ul>
                        <p>Пример:</p>
                      `,
                      code: `
                div {
                  margin: 10px;
                  border: 1px solid black;
                  padding: 5px;
                  width: 100px;
                }
                      `,
                    },
                    {
                      title: "Зачем нужен box-sizing?",
                      type: "text",
                      description: `
                        <p>Свойство <code>box-sizing</code> определяет, как рассчитывается ширина и высота элемента. Оно позволяет избежать путаницы с размерами элементов, особенно когда используются отступы и границы. Без <code>box-sizing: border-box</code>, добавление <strong>padding</strong> и <strong>border</strong> увеличивает фактические размеры элемента, что может привести к нежелательным эффектам, особенно в макетах на основе сеток.</p>
                        <p>С помощью <code>box-sizing: border-box</code> вы можете установить ширину и высоту элемента так, чтобы они включали в себя <strong>padding</strong> и <strong>border</strong>, что делает управление размерами более предсказуемым.</p>
                      `,
                    },
                    {
                      title: "Пример использования box-sizing",
                      type: "code",
                      description: `
                        <p>Пример применения свойства <code>box-sizing</code>:</p>
                      `,
                      code: `
                * {
                  box-sizing: border-box;
                }
                
                div {
                  margin: 10px;
                  border: 1px solid black;
                  padding: 5px;
                  width: 100px; // Включает в себя padding и border
                }
                      `,
                    },
                  ],
                },
                {
                  title: "em против rem, относительные и абсолютные значения",
                  children: [
                    {
                      title:
                        "<code>em</code> и <code>rem</code> - это относительные единицы измерения, используемые в CSS:",
                      type: "code",
                      description: `
                        <ul>
                          <li><strong>em</strong>: Относится к текущему элементу. Если размер шрифта родительского элемента равен 16px, то 1em = 16px.</li>
                          <li><strong>rem</strong>: Относится к корневому элементу (обычно <code>html</code>). Если размер шрифта корневого элемента равен 16px, то 1rem = 16px.</li>
                        </ul>
                        <p>Пример:</p>
                      `,
                      code: `
h1 {
font-size: 2em; /* 32px, если родительский элемент имеет размер 16px */
}

p {
font-size: 1.5rem; /* 24px */
}
                      `,
                    },
                  ],
                },
                {
                  title: "Позиционирование: поток документов, overflow, z-index",
                  children: [
                    {
                      title:
                        "Позиционирование в CSS управляет размещением элементов на странице:",
                      type: "code",
                      description: `
                        <ul>
                          <li><strong>position: static</strong>: Обычное потоковое позиционирование.</li>
                          <li><strong>position: relative</strong>: Относительное позиционирование, элемент сдвигается относительно своего обычного положения.</li>
                          <li><strong>position: absolute</strong>: Абсолютное позиционирование относительно ближайшего родительского элемента.</li>
                          <li><strong>position: fixed</strong>: Фиксированное позиционирование относительно окна браузера.</li>
                          <li><strong>position: sticky</strong>: Элемент ведет себя как <code>relative</code> до определенной точки, после чего становится <code>fixed</code>.</li>
                        </ul>
                        <p>Пример:</p>
                      `,
                      code: `
.relative {
position: relative;
top: 10px;
}

.absolute {
position: absolute;
top: 20px;
}

.fixed {
position: fixed;
top: 0;
}
                      `,
                    },
                    {
                      title: "Переполнение (Overflow)",
                      type: "list",
                      description: `
                        <p>Свойство <code>overflow</code> в CSS управляет тем, как обрабатывается содержимое, выходящее за пределы блока. Оно может принимать следующие значения:</p>
                        <ul>
                          <li><strong>visible</strong>: Содержимое не обрезается; его можно видеть за пределами элемента (значение по умолчанию).</li>
                          <li><strong>hidden</strong>: Содержимое, выходящее за пределы элемента, скрыто.</li>
                          <li><strong>scroll</strong>: Содержимое скрыто, но добавляются полосы прокрутки для доступа к нему.</li>
                          <li><strong>auto</strong>: Полосы прокрутки добавляются только при необходимости.</li>
                        </ul>
                      `,
                    },
                    {
                      title: "Пример использования overflow",
                      type: "code",
                      description: `
                        <p>Пример CSS с использованием свойства <code>overflow</code>:</p>
                      `,
                      code: `
.container {
  width: 200px;
  height: 100px;
  overflow: scroll; /* Добавляет полосы прокрутки */
}
                      `,
                    },
                    {
                      title: "z-индекс (z-index)",
                      type: "list",
                      description: `
                        <p>Свойство <code>z-index</code> управляет порядком наложения элементов на странице. Оно определяет, какой элемент будет отображаться сверху, когда элементы перекрываются. Некоторые важные моменты:</p>
                        <ul>
                          <li><strong>Числовые значения</strong>: Элементы с большим значением <code>z-index</code> отображаются выше элементов с меньшим значением.</li>
                          <li><strong>Контекст наложения</strong>: <code>z-index</code> работает только для элементов, у которых задано свойство <code>position</code> (relative, absolute, fixed или sticky).</li>
                          <li><strong>Значение по умолчанию</strong>: Элементы без заданного <code>z-index</code> имеют значение по умолчанию 0.</li>
                        </ul>
                      `,
                    },
                    {
                      title: "Пример использования z-index",
                      type: "code",
                      description: `
                        <p>Пример CSS с использованием свойства <code>z-index</code>:</p>
                      `,
                      code: `
.box1 {
  position: absolute;
  z-index: 1; /* Находится ниже */
}

.box2 {
  position: absolute;
  z-index: 2; /* Находится выше */
}
                      `,
                    },
                  ],
                },

                {
                  title: "Флексбокс",
                  children: [
                    {
                      title:
                        "Флексбокс - это метод расположения элементов в одной строке или колонке с возможностью изменения их размеров:",
                      type: "code",
                      description: `
                        <ul>
                          <li><strong>display: flex</strong>: Включает флексбокс на родительском элементе.</li>
                          <li><strong>flex-direction</strong>: Определяет направление основного оси (row, column).</li>
                          <li><strong>justify-content</strong>: Управляет расположением элементов вдоль главной оси.</li>
                          <li><strong>align-items</strong>: Управляет расположением элементов вдоль поперечной оси.</li>
                        </ul>
                        <p>Пример:</p>
                        `,
                      code: `               
.container {
  display: flex;
  flex-direction: row;
  justify-content: space-between;
  align-items: center;
}
                      `,
                    },
                  ],
                },
                {
                  title: "Сетка",
                  children: [
                    {
                      title: "CSS Grid",
                      type: "code",
                      description: `
                      <p>CSS Grid - это мощный инструмент для создания гибких и сложных макетов. Основные моменты:</p>
                      <ul>
                        <li>Создает двумерные сетки</li>
                        <li>Контролирует размещение элементов по строкам и колонкам</li>
                        <li>Задает размер и расстояние между элементами</li>
                      </ul>
                      <p>Пример:</p>
                      `,
                      code: `
.grid-container {
display: grid;
grid-template-columns: repeat(3, 1fr); /* 3 колонки */
gap: 10px; /* расстояние между элементами */
}
                      `,
                    },
                  ],
                },
                {
                  title: "CSS Grid Layout",
                  children: [
                    {
                      title: "CSS Grid Layout",
                      type: "image",
                      url: "https://i.pinimg.com/enabled_hi/564x/54/e9/87/54e98761c2348545244bf25487c5be23.jpg",
                    },
                    {
                      title: `⚡️ Мультиколонки:
        Основная идея мультиколонок заключается в том, что вы можете взять фрагмент содержимого и поместить его в несколько колонок, как в газете
                      `,
                      type: "code",
                      code: `
.article-content {
  columns: auto 10rem;
}

.article {
    // Шорткат columns даёт возможность указать значения для 
    // свойств column-count и column-width одновременно, задав 
    // количество и ширину колонок
    columns: 2 200px;
    column-gap: 25px;
  }
  .title{
    // Свойство column-span позволяет элементу растянуться 
    // на несколько колонок
    column-span: all;
  }
}`,
                    },
                  ]
                },
                {
                  title: "Разница между блочными и строчными элементами",
                  children: [
                    {
                      title: "Блочные элементы",
                      type: "list",
                      description: `
                        <p>Характеристики блочных элементов:</p>
                        <ul>
                          <li><strong>Занимают всю ширину</strong>: Блочные элементы по умолчанию занимают всю доступную ширину контейнера.</li>
                          <li><strong>Начинают новую строку</strong>: Каждый блочный элемент начинается с новой строки, что создает визуальное разделение между элементами.</li>
                          <li><strong>Примеры</strong>: <code>&lt;div&gt;</code>, <code>&lt;p&gt;</code>, <code>&lt;h1&gt;</code>, <code>&lt;ul&gt;</code>, <code>&lt;section&gt;</code>.</li>
                        </ul>
                      `,
                    },
                    {
                      title: "Строчные элементы",
                      type: "list",
                      description: `
                        <p>Характеристики строчных элементов:</p>
                        <ul>
                          <li><strong>Занимают только необходимую ширину</strong>: Строчные элементы занимают только ту ширину, которая необходима для их содержания.</li>
                          <li><strong>Не начинают новую строку</strong>: Строчные элементы располагаются в одной строке с другими элементами, не создавая разрывов.</li>
                          <li><strong>Примеры</strong>: <code>&lt;span&gt;</code>, <code>&lt;a&gt;</code>, <code>&lt;strong&gt;</code>, <code>&lt;em&gt;</code>, <code>&lt;img&gt;</code>.</li>
                        </ul>
                      `,
                    },
                    {
                      title: "Сводная таблица различий",
                      type: "list",
                      description: `
                        <p>Краткое сравнение:</p>
                        <ul>
                          <li><strong>Ширина</strong>: Блочные элементы — 100% ширины; строчные элементы — по содержимому.</li>
                          <li><strong>Перенос</strong>: Блочные элементы переносят последующий контент на новую строку; строчные элементы — нет.</li>
                          <li><strong>Использование</strong>: Блочные элементы для структуры; строчные элементы для форматирования текста.</li>
                        </ul>
                      `,
                    },
                  ],
                },
                {
                  title: "HTML and CSS Slider",
                  children: [
                    {
                      title: "",
                      type: "video",
                      url: "https://www.youtube.com/embed/gVxyTOPPEPc",
                    },
                  ]
                },
                {
                  title: "Принципы семантической верстки",
                  children: [
                    {
                      title: "Принципы семантической верстки включают:",
                      type: "code",
                      description: `
                      <ul>
                        <li>Использование HTML-тегов по назначению (например, &lt;header&gt;, &lt;article&gt;, &lt;footer&gt;).</li>
                        <li>Обеспечение доступности для технологий помощников (скринридеров).</li>
                        <li>Улучшение SEO (поисковой оптимизации).</li>
                      </ul>
                      <p>Пример:</p>
                      `,
                      code: `
<article>
<header>
<h1>Заголовок статьи</h1>
</header>
<p>Содержимое статьи...</p>
<footer>Автор: Иван Иванов</footer>
</article>
                      `,
                    },
                  ],
                },
                {
                  title: "Что такое #shadow-root в инспекторе HTML-страницы",
                  children: [
                    {
                      title:
                        "Shadow DOM позволяет создавать отдельные области DOM, чтобы избежать конфликтов стилей",
                      type: "list",
                      description: `
                              <ul>
                                  <li>Поддержка инкапсуляции: Стили внутри Shadow DOM не влияют на родительский DOM.</li>
                                  <li>Упрощение разработки компонентов: Позволяет создавать защищенные компоненты.</li>
                              </ul>
                      `,
                    },
                  ],
                },
                {
                  title: "Названия популярных CSS-методологий и их отличия",
                  children: [
                    {
                      title: "Существует несколько популярных CSS-методологий:",
                      type: "list",
                      description: `
                              <ul>
                                  <li><strong>BEM</strong> (Block, Element, Modifier) - способствует созданию доступных и модульных стилей.</li>
                                  <li><strong>SMACSS</strong> (Scalable and Modular Architecture for CSS) - структурирует стили по категориям.</li>
                                  <li><strong>OOCSS</strong> (Object-Oriented CSS) - акцентирует внимание на создании повторно используемых объектов.</li>
                              </ul>
                      `,
                    },
                  ],
                },
                {
                  title: "Как изменить цвет в svg файле",
                  children: [
                    {
                      title: "Изменение цвета",
                      type: "code",
                      description: `
                              <p>Существует несколько способов изменить цвет в SVG:</p>
                              <ul>
                                  <li>Изменение атрибутов <code>fill</code> и <code>stroke</code> в самом SVG файле.</li>
                                  <li>Использование CSS для стилизации SVG элементов.</li>
                                  <li>Динамическое изменение с помощью JavaScript.</li>
                              </ul>
                      `,
                      code: `
// изменение атрибутов
<svg width="100" height="100">
<circle cx="50" cy="50" r="40" fill="red" stroke="black" 
    stroke-width="2" />
</svg>


// использование CSS 
<svg width="100" height="100">
<style>
.myCircle {
fill: blue;
stroke: green;
stroke-width: 3;
}
</style>
<circle class="myCircle" cx="50" cy="50" r="40" />
</svg>


// динамическое изменение
<svg id="mySvg" width="100" height="100">
<circle id="myCircle" cx="50" cy="50" r="40" fill="orange" 
    stroke="black" stroke-width="2" />
</svg>

<button onclick="changeColor()">Изменить цвет</button>

<script>
function changeColor() {
var circle = document.getElementById("myCircle");
circle.setAttribute("fill", "purple");  // Изменяем цвет заливки
circle.setAttribute("stroke", "yellow"); // Изменяем цвет обводки
}
</script>
                      `,
                    },
                  ],
                },
              ],
            },
            {
              title: "SASS",
              children: [
                {
                  title: "SASS cheat sheet",
                  type: "image",
                  url: "https://d1le3ohiuslpz1.cloudfront.net/skillcrush/wp-content/uploads/2023/07/how-sass-works-1024x506.png",
                },
              ],
            },
            {
              title: "SCSS",
              children: [
                {
                  title: "SCSS cheat sheet",
                  type: "image",
                  url: "https://i0.wp.com/techprimelab.com/wp-content/uploads/2020/06/SCSS-or-CSS.jpg",
                },
              ],
            },
            {
              title: "styled-components",
              children: [
                {
                  title: "styled-components cheat sheet",
                  type: "image",
                  url: "https://raw.githubusercontent.com/styled-components/brand/master/styled-components.png",
                },
              ],
            },
          ],
        },
        {
          title: "Создание макета в HTML и CSS",
          children: [
            {
              title: "HTML атрибуты для создания макета:",
              type: "code",
              description: `
                <ul>
                  <li><strong>Атрибуты <code>div</code>:</strong>
                    <ul>
                      <li><code>id</code>: Уникальный идентификатор элемента.</li>
                      <li><code>class</code>: Классы для стилизации с помощью CSS.</li>
                    </ul>
                  </li>
                  <li><strong>Семантические элементы:</strong>
                    <ul>
                      <li><code>&lt;section&gt;</code>, <code>&lt;article&gt;</code>, <code>&lt;nav&gt;</code>, <code>&lt;header&gt;</code>, <code>&lt;footer&gt;</code>: Используются для структурирования страницы.</li>
                    </ul>
                  </li>
                  <li><strong>Встраиваемый стиль:</strong>
                    <ul>
                      <li>Пример использования <code>style</code>:</li>
                    </ul>
                  </li>
                </ul>
              `,
              code: `
<div style="width: 50%; float: left;">Контент</div>
              `,
            },
            {
              title: "CSS свойства для создания макета:",
              type: "code",
              description: `
                <ul>
                  <li><strong>Свойство <code>display</code>:</strong>
                    <ul>
                      <li><code>block</code>, <code>inline</code>, <code>inline-block</code>, <code>flex</code>, <code>grid</code></li>
                    </ul>
                  </li>
                  <li><strong>Свойство <code>position</code>:</strong>
                    <ul>
                      <li><code>static</code>, <code>relative</code>, <code>absolute</code>, <code>fixed</code>, <code>sticky</code></li>
                    </ul>
                  </li>
                  <li><strong>Свойства <code>margin</code> и <code>padding</code>:</strong> Используются для управления пространством между элементами и внутри элемента.</li>
                  <li><strong>Свойства <code>width</code> и <code>height</code>:</strong> Задают размеры элемента.</li>
                </ul>
              `,
              code: `
.container {
  display: flex;
  justify-content: center; /* Выравнивание по горизонтали */
  align-items: center; /* Выравнивание по вертикали */
}
              `,
            },
            {
              title: "HTML5 семантические элементы:",
              type: "list",
              description: `
                <ul>
                  <li><strong>&lt;header&gt;</strong>, <strong>&lt;nav&gt;</strong>, <strong>&lt;main&gt;</strong>, <strong>&lt;section&gt;</strong>, <strong>&lt;article&gt;</strong>, <strong>&lt;aside&gt;</strong>, <strong>&lt;footer&gt;</strong>: Эти элементы помогают улучшить SEO и доступность.</li>
                </ul>
              `,
            },
            {
              title: "Flexbox и Grid для создания макетов:",
              type: "code",
              description: `
                <ul>
                  <li><strong>Flexbox:</strong> Упрощает выравнивание элементов вдоль одной оси.</li>
                  <li><strong>Grid:</strong> Позволяет создавать сеточные макеты, определяя колонки и строки.</li>
                </ul>
              `,
              code: `
/* Flexbox */
.container {
  display: flex;
  justify-content: center; /* Выравнивание по горизонтали */
  align-items: center; /* Выравнивание по вертикали */
}

/* Grid */
.grid-container {
  display: grid;
  grid-template-columns: repeat(3, 1fr); /* Три равные колонки */
}
              `,
            },
          ],
        },
        {
          title: "Структура HTML документа",
          children: [
            {
              title: "<!DOCTYPE html>",
              type: "list",
              description: `
                <p>Объявляет тип документа и версию HTML:</p>
                <ul>
                  <li><strong>Версия</strong>: Обычно используется HTML5.</li>
                </ul>
              `,
            },
            {
              title: "<html>",
              type: "list",
              description: `
                <p>Корневой элемент HTML-документа:</p>
                <ul>
                  <li><strong>Атрибуты</strong>: Может содержать атрибут <code>lang</code> для указания языка.</li>
                </ul>
              `,
            },
            {
              title: "<head>",
              type: "list",
              description: `
                <p>Содержит метаданные о документе:</p>
                <ul>
                  <li><strong><meta charset="UTF-8"></strong>: Устанавливает кодировку документа.</li>
                  <li><strong><meta name="viewport"></strong>: Настройки для адаптивного дизайна и отображения на мобильных устройствах.</li>
                  <li><strong><title></strong>: Заголовок, отображаемый на вкладке браузера.</li>
                  <li><strong><link></strong>: Подключение внешних CSS-файлов.</li>
                  <li><strong><script></strong>: Подключение внешних JavaScript-файлов (если необходимо).</li>
                </ul>
              `,
            },
            {
              title: "<body>",
              type: "list",
              description: `
                <p>Основное содержимое страницы:</p>
                <ul>
                  <li><strong><header></strong>: Заголовок или навигация сайта.</li>
                  <li><strong><main></strong>: Основной контент страницы.</li>
                  <li><strong><footer></strong>: Нижний колонтитул с информацией о правами и ссылками.</li>
                </ul>
              `,
            },
          ],
        },




        {
          title: "На что нужно обратить внимание при разработке мультиязычных сайтов",
          children: [
            {
              title:
                "При разработке мультиязычных сайтов стоит учитывать:",
              type: "code",
              description: `
              <ul>
                <li>Хранение текста: использовать JSON или базы данных для хранения переведенных текстов.</li>
                <li>Изменение языка: обеспечить пользовательский интерфейс для смены языка.</li>
                <li>SEO: использовать атрибут &lt;html lang="en"&gt; для указания языка страницы.</li>
              </ul>
              <p>Пример:</p>
              `,
              code: `
<html lang="ru">
  <head>
    <meta charset="UTF-8">
  </head>
</html>
              `,
            },
          ],
        },
        {
          title: "Что такое прогрессивная развертка",
          children: [
            {
              title:
                "Прогрессивная развертка - это подход к разработке страниц, при котором отображение контента происходит по мере его загрузки",
              type: "code",
              description: `
              <ul>
                <li>Сначала загружается основной контент</li>
                <li>Второстепенный контент загружается позже</li>
              </ul>
              <p>Пример:</p>
              `,
              code: `
// Пример с использованием JavaScript для прогрессивной загрузки
fetch('/api/content')
  .then(response => response.json())
  .then(data => {
document.getElementById('content').innerHTML = data.content;
});
              `,
            },
          ],
        },
        {
          title: "Разница между script, script async и script defer",
          children: [
            {
              title: "Загрузки скриптов",
              type: "code",
              description: `
              <p>Существует три способа подключения скриптов в HTML:</p>
              <ul>
                <li>&lt;script&gt;: Загружает и выполняет скрипт синхронно.</li>
                <li>&lt;script async&gt;: Загружает скрипт асинхронно, не блокируя загрузку страницы.</li>
                <li>&lt;script defer&gt;: Также загружает скрипт асинхронно, но гарантирует, что он будет выполнен после полной загрузки HTML.</li>
              </ul>
              <p>Пример:</p>
              `,
              code: `
<script src="script.js"></script>
<script async src="script-async.js"></script>
<script defer src="script-defer.js"></script>
              `,
            },
          ],
        },
        {
          title: "Подключение JavaScript-скриптов в HTML",
          children: [
            {
              title: "1. Внешний скрипт (External Script)",
              type: "list",
              description: `
                <p>Подключение скрипта через отдельный файл:</p>
                <ul>
                  <li><strong>Используемый тег</strong>: <code>&lt;script&gt;</code>.</li>
                  <li><strong>Пример</strong>: 
                    <code>&lt;script src="script.js"&gt;&lt;/script&gt;</code>.
                  </li>
                  <li><strong>Преимущества</strong>: Упрощает организацию кода и позволяет повторно использовать скрипты на нескольких страницах.</li>
                </ul>
              `,
            },
            {
              title: "2. Встроенный скрипт (Internal Script)",
              type: "list",
              description: `
                <p>Подключение скрипта непосредственно в документе:</p>
                <ul>
                  <li><strong>Используемый тег</strong>: <code>&lt;script&gt;</code>.</li>
                  <li><strong>Пример</strong>: 
                    <code>&lt;script&gt; console.log('Hello, world!'); &lt;/script&gt;</code>.
                  </li>
                  <li><strong>Преимущества</strong>: Удобно для небольших скриптов, специфичных для одной страницы.</li>
                </ul>
              `,
            },
            {
              title: "Атрибуты тега <script>",
              type: "list",
              description: `
                <p>Основные атрибуты:</p>
                <ul>
                  <li><strong>src</strong>: Указывает путь к внешнему JavaScript-файлу.</li>
                  <li><strong>defer</strong>: Загружает скрипт после завершения парсинга HTML-документа. Работает только с внешними скриптами.</li>
                  <li><strong>async</strong>: Загружает скрипт асинхронно, не блокируя парсинг HTML. Работает только с внешними скриптами.</li>
                  <li><strong>type</strong>: Указывает тип скрипта (по умолчанию <code>text/javascript</code>). Например, для модулей можно использовать <code>type="module"</code>.</li>
                  <li><strong>integrity</strong>: Используется для проверки целостности загружаемого файла с использованием Subresource Integrity (SRI).</li>
                  <li><strong>crossorigin</strong>: Определяет, как браузер должен обрабатывать кросс-доменные запросы для загружаемого скрипта.</li>
                </ul>
              `,
            },
          ],
        },
        {
          title: "Атрибут For",
          children: [
            {
              title: ``,
              type: "code",
              description: `
              Он связывает элемент <label> с соответствующим полем < input >, позволяя пользователям 
              кликать по тексту метки для выбора или фокуса на связанном элементе управления.
              p.s. Значение атрибута for должно совпадать с id связанного элемента, что 
              улучшает доступность и удобство взаимодействия с формами.
              `,
              code: `
<label for="Number">Ваше любимое число:</label>
<input id="number">`,
            },
          ]
        }
      ],
    },
    {
      title: "JavaScript",
      children: [
        {
          title: "addEventListener() method arguments",
          children: [
            {
              title: "1. event",
              type: "text",
              description: `
                <p>Название события, которое вы хотите отслеживать (например, <code>'click'</code>, <code>'keyup'</code>, <code>'load'</code>).</p>
              `,
            },
            {
              title: "2. handler",
              type: "text",
              description: `
                <p>Функция, которая будет вызвана при возникновении события. Она принимает объект события в качестве первого аргумента.</p>
              `,
            },
            {
              title: "3. options",
              type: "text",
              description: `
                <p>Опциональный аргумент, который может быть:</p>
                <ul>
                  <li><strong>boolean:</strong> Если <code>true</code>, обработчик будет вызван на фазе захвата.</li>
                  <li><strong>object:</strong> Объект с параметрами:</li>
                  <ul>
                    <li><code>capture</code>: Если <code>true</code>, обработчик срабатывает на фазе захвата.</li>
                    <li><code>once</code>: Если <code>true</code>, обработчик вызовется только один раз.</li>
                    <li><code>passive</code>: Если <code>true</code>, обработчик не вызовет <code>preventDefault()</code>.</li>
                  </ul>
                </ul>
              `,
            },
            {
              title: "Пример использования",
              type: "code",
              description: `
                <p>Пример добавления обработчика события клика:</p>
              `,
              code: `
const button = document.getElementById('myButton');

button.addEventListener('click', function(event) {
  console.log('Кнопка нажата!');
}, {
  capture: false,
  once: true
});
              `
            },
          ],
        },
        {
          title: "Asynchronous Programming",
          children: [
            {
              title: "Basics of async programming",
              type: "list",
              description: `
                <p><strong>Асинхронное программирование</strong> — это парадигма, позволяющая выполнять операции, не блокируя основной поток выполнения. Это особенно полезно для задач, которые могут занять продолжительное время, таких как сетевые запросы или операции с файлами.</p>
              `,
            },
            {
              title: "Key Concepts",
              type: "list",
              description: `
                <p>Основные концепции асинхронного программирования:</p>
                <ul>
                  <li><strong>Callbacks</strong>: Функции обратного вызова, которые передаются в другие функции и вызываются после завершения асинхронной операции.</li>
                  <li><strong>Promises</strong>: Объекты, представляющие результат асинхронной операции, которые могут быть в состоянии ожидания (pending), выполнены (fulfilled) или отклонены (rejected).</li>
                  <li><strong>Async/Await</strong>: Синтаксический сахар над промисами, позволяющий писать асинхронный код, который выглядит как синхронный.</li>
                </ul>
              `,
            },
            {
              title: "Callbacks",
              type: "code",
              description: `
                <p>Пример использования колбеков:</p>
              `,
              code: `
function fetchData(callback) {
  setTimeout(() => {
    callback('Data received');
  }, 1000);
}

fetchData((data) => {
  console.log(data); // 'Data received'
});
              `,
            },
            {
              title: "Promises",
              type: "code",
              description: `
                <p>Пример использования промисов:</p>
              `,
              code: `
function fetchData() {
  return new Promise((resolve, reject) => {
    setTimeout(() => {
      resolve('Data received');
    }, 1000);
  });
}

fetchData().then(data => {
  console.log(data); // 'Data received'
});
              `,
            },
            {
              title: "Async/Await",
              type: "code",
              description: `
                <p>Пример использования async/await:</p>
              `,
              code: `
  async function fetchData() {
    return new Promise((resolve) => {
      setTimeout(() => {
        resolve('Data received');
      }, 1000);
    });
  }

  async function getData() {
    const data = await fetchData();
    console.log(data); // 'Data received'
  }

  getData();
              `,
            },
            {
              title: "Benefits of Asynchronous Programming",
              type: "list",
              description: `
                <p>Преимущества асинхронного программирования:</p>
                <ul>
                  <li><strong>Улучшенная производительность</strong>: Не блокирует основной поток выполнения, что позволяет выполнять другие задачи.</li>
                  <li><strong>Лучшая отзывчивость приложения</strong>: Пользовательский интерфейс остается активным во время выполнения длительных операций.</li>
                  <li><strong>Упрощение кода</strong>: Использование async/await делает код более читаемым и понятным.</li>
                </ul>
              `,
            },
          ],
        },
        {
          title: "Context this",
          children: [
            {
              title: "Описание",
              type: "list",
              description:
                "this – это специальное ключевое слово в JavaScript, которое ссылается на объект, который в данный момент выполняет код. Значение `this` определяется не тем, как функция была объявлена, а тем, как она была вызвана.",
            },
            {
              title: "Контекст вызова",
              type: "code",
              description: `Значение "this" зависит от контекста вызова функции. Вот основные правила:`,
              code: `
// В глобальном контексте (вне функций) 'this' ссылается на глобальный объект (window в браузере).
console.log(this); // window

// В методе объекта 'this' ссылается на объект, в контексте которого был вызван метод:
const obj = {
  name: 'Obj',
  method: function() {
  console.log(this.name);
  }
};
obj.method(); // 'Obj'
              `,
            },
            {
              title: "Значение this в функциях",
              type: "code",
              description:
                "В обычной функции `this` ссылается на глобальный объект (или undefined в строгом режиме).",
              code: `
function showThis() {
  console.log(this);
}

showThis(); // window (или undefined в строгом режиме)
              `,
            },
            {
              title: "Классы и this",
              type: "code",
              description:
                "В классах `this` ссылается на экземпляр класса, который был создан с помощью ключевого слова new.",
              code: `
class MyClass {
  constructor(value) {
    this.value = value;
  }
  showValue() {
    console.log(this.value);
  }
}

const instance = new MyClass(10);
instance.showValue(); // 10
              `,
            },
            {
              title: "Стрелочные функции и this",
              type: "code",
              description:
                "Стрелочные функции не имеют собственного `this` и наследуют его из родительского контекста, в котором они были созданы.",
              code: `
const obj = {
  value: 20,
  method: function() {
    const arrowFunction = () => {
      console.log(this.value);
    };
    arrowFunction();
  }
}

obj.method(); // 20
              `,
            },
            {
              title: "Способы контроля this",
              type: "code",
              description:
                "Можно контролировать значение `this` в функции с помощью методов `.call()`, `.apply()` и `.bind()`.",
              code: `
function show() {  
  console.log(this.name);
  const obj = { name: 'Test' };
  show.call(obj);    // 'Test'
  show.apply(obj);   // 'Test'
  const boundShow = show.bind(obj);
  boundShow();       // 'Test'
}
              `,
            },
            {
              title: "Вывод",
              type: "list",
              description:
                "Контекст `this` в JavaScript может быть сложным для понимания. Важно понимать, как он работает в разных контекстах для избежания ошибок.",
            },
          ],
        },
        {
          title: "Cancel ascent and dive / Отмена всплытия и погружения",
          children: [
            {
              title: "1. Всплытие событий",
              type: "text",
              description: `
                <p>Всплытие - это процесс, при котором событие движется от целевого элемента к корню документа.</p>
                <p>По умолчанию события всплывают, позволяя родительским элементам обрабатывать их.</p>
              `,
            },
            {
              title: "2. Погружение событий",
              type: "text",
              description: `
                <p>Погружение (или захват) - это процесс, при котором событие движется от корня документа к целевому элементу.</p>
                <p>Этот процесс выполняется только при установке соответствующего параметра в <code>addEventListener</code>.</p>
              `,
            },
            {
              title: "3. Отмена всплытия",
              type: "text",
              description: `
                <p>Чтобы отменить всплытие события, используйте метод <code>event.stopPropagation()</code>.</p>
                <p>Этот метод предотвращает дальнейшее распространение события по дереву DOM.</p>
              `,
            },
            {
              title: "4. Отмена погружения",
              type: "text",
              description: `
                <p>Чтобы отменить погружение события, используйте метод <code>event.stopImmediatePropagation()</code>.</p>
                <p>Этот метод не только предотвращает дальнейшее распространение, но и останавливает выполнение других обработчиков события на текущем элементе.</p>
              `,
            },
            {
              title: "Пример отмены всплытия",
              type: "code",
              description: `
                <p>Пример отмены всплытия события:</p>
              `,
              code: `
        button.addEventListener('click', function(event) {
          event.stopPropagation(); // Отменяет всплытие события
          console.log('Кнопка нажата, всплытие отменено!');
        });
              `
            },
          ],
        },
        {
          title: "Closure / Замыкание",
          children: [
            {
              title: "1. Определение замыкания",
              type: "text",
              description: `
                <p>Замыкание - это функция, которая имеет доступ к своей внешней области видимости даже после завершения выполнения внешней функции.</p>
              `,
            },
            {
              title: "2. Как работает замыкание?",
              type: "text",
              description: `
                <p>Когда функция создаётся в JavaScript, она "захватывает" переменные из своей внешней области видимости. Даже если внешняя функция завершила выполнение, замыкание сохраняет ссылку на эти переменные.</p>
              `,
            },
            {
              title: "3. Пример замыкания",
              type: "code",
              description: `
                <p>Пример замыкания:</p>
              `,
              code: `
function outerFunction() {
  let outerVar = 'I am outside!';
  
  function innerFunction() {
    console.log(outerVar); // Доступ к outerVar
  }
  
  return innerFunction;
}

const myInnerFunction = outerFunction();
myInnerFunction(); // Вывод: "I am outside!"
              `
            },
            {
              title: "4. Применение замыканий",
              type: "text",
              description: `
                <p>Замыкания часто используются для:</p>
                <ul>
                  <li>Создания приватных переменных.</li>
                  <li>Фабричных функций для создания функций с предустановленными значениями.</li>
                  <li>Обработчиков событий, где необходимо сохранить состояние.</li>
                </ul>
              `,
            },
            {
              title: "5. Пример использования замыкания для приватных переменных",
              type: "code",
              description: `
                <p>Пример создания приватной переменной:</p>
              `,
              code: `
function createCounter() {
  let count = 0; // Приватная переменная
  
  return {
    increment: function() {
      count++;
      return count;
    },
    decrement: function() {
      count--;
      return count;
    },
    getCount: function() {
      return count;
    }
  };
}

const counter = createCounter();
console.log(counter.increment()); // 1
console.log(counter.increment()); // 2
console.log(counter.getCount()); // 2
console.log(counter.decrement()); // 1
              `
            },
            {
              title: "6. Замыкания и производительность",
              type: "text",
              description: `
                <p>Хотя замыкания мощный инструмент, они могут повлиять на производительность, если используются неправильно. Избыточное использование замыканий может привести к утечкам памяти, если ссылки на замыкания не освобождаются.</p>
              `,
            },
          ],
        },
        {
          title: "Data types / Типы данных",
          children: [
            {
              title: "1. Числа (Number)",
              type: "list",
              description: `
                <p>Характеристики чисел:</p>
                <ul>
                  <li><strong>Тип данных</strong>: Представляют как целые, так и дробные числа.</li>
                  <li><strong>Примеры</strong>: <code>42</code>, <code>3.14</code>.</li>
                  <li><strong>Особенности</strong>: Поддерживают специальные значения, такие как <code>Infinity</code>, <code>-Infinity</code>, и <code>NaN</code> (не число).</li>
                </ul>
              `,
            },
            {
              title: "2. Строки (String)",
              type: "list",
              description: `
                <p>Характеристики строк:</p>
                <ul>
                  <li><strong>Тип данных</strong>: Последовательность символов, используемая для представления текста.</li>
                  <li><strong>Примеры</strong>: <code>"Hello, world!"</code>, <code>'JavaScript'</code>.</li>
                  <li><strong>Методы</strong>: Строки имеют множество методов, таких как <code>length</code>, <code>substring()</code>, <code>toUpperCase()</code>.</li>
                </ul>
              `,
            },
            {
              title: "3. Логические значения (Boolean)",
              type: "list",
              description: `
                <p>Характеристики логических значений:</p>
                <ul>
                  <li><strong>Тип данных</strong>: Представляют истинное (<code>true</code>) или ложное (<code>false</code>) значение.</li>
                  <li><strong>Примеры</strong>: <code>true</code>, <code>false</code>.</li>
                  <li><strong>Использование</strong>: Часто используются в условиях и циклах.</li>
                </ul>
              `,
            },
            {
              title: "4. Объекты (Object)",
              type: "list",
              description: `
                <p>Характеристики объектов:</p>
                <ul>
                  <li><strong>Тип данных</strong>: Сложные структуры, которые могут содержать множество значений и методов.</li>
                  <li><strong>Примеры</strong>: <code>{ name: "Alice", age: 25 }</code>, <code>new Date()</code>.</li>
                  <li><strong>Типы объектов</strong>: Могут быть встроенными (Array, Date и т.д.) или пользовательскими.</li>
                </ul>
              `,
            },
            {
              title: "5. Массивы (Array)",
              type: "list",
              description: `
                <p>Характеристики массивов:</p>
                <ul>
                  <li><strong>Тип данных</strong>: Специальный тип объекта, который хранит упорядоченные коллекции значений.</li>
                  <li><strong>Примеры</strong>: <code>[1, 2, 3]</code>, <code>["apple", "banana"]</code>.</li>
                  <li><strong>Методы</strong>: Массивы имеют множество методов, таких как <code>push()</code>, <code>pop()</code>, <code>map()</code>.</li>
                </ul>
              `,
            },
            {
              title: "6. Специальные значения",
              type: "list",
              description: `
                <p>Некоторые специальные значения:</p>
                <ul>
                  <li><strong>undefined</strong>: Переменная, которая была объявлена, но не инициализирована.</li>
                  <li><strong>null</strong>: Явное указание на отсутствие значения или объект.</li>
                  <li><strong>Symbol</strong>: Уникальные и неизменяемые идентификаторы (доступны с ES6).</li>
                  <li><strong>BigInt</strong>: Тип данных для работы с целыми числами произвольной длины (доступен с ES11).</li>
                </ul>
              `,
            },
          ],
        },
        {
          title: "Descriptors, Getters, and Setters",
          children: [
            {
              title: "Определение дескрипторов",
              type: "text",
              description: `
                <p>Дескрипторы свойств — это объекты, которые содержат информацию о свойствах объектов в JavaScript, такие как возможность записи, перечисляемость и доступность.</p>
                <p><strong>Дескрипторы объекта</strong> — это объекты, которые описывают свойства объекта, их поведение и характеристики. Они позволяют управлять тем, как свойства могут быть использованы и изменены.</p>
              `,
            },
            {
              title: "Типы дескрипторов",
              type: "list",
              description: `
                <p>Существует два типа дескрипторов:</p>
                <ul>
                  <li><strong>Данные дескриптора</strong>: хранят значение и могут быть настроены для записи.</li>
                  <li><strong>Accessor дескрипторы</strong>: используют геттеры и сеттеры для управления доступом к значениям.</li>
                </ul>
              `,
            },
            {
              title: "Геттеры",
              type: "text",
              description: `
                <p>Геттеры — это специальные методы, которые позволяют получать значения свойств объекта. Они определяются с помощью ключевого слова <code>get</code>.</p>
              `,
            },
            {
              title: "Пример геттера",
              type: "code",
              description: `
                <p>Пример использования геттера в объекте:</p>
              `,
              code: `
const person = {
  firstName: 'John',
  lastName: 'Doe',
  get fullName() {
    return \`\${this.firstName} \${this.lastName}\`;
  }
};

console.log(person.fullName); // John Doe
              `,
            },
            {
              title: "Сеттеры",
              type: "text",
              description: `
                <p>Сеттеры — это специальные методы, которые позволяют задавать значения свойств объекта. Они определяются с помощью ключевого слова <code>set</code>.</p>
              `,
            },
            {
              title: "Пример сеттера",
              type: "code",
              description: `
                <p>Пример использования сеттера в объекте:</p>
              `,
              code: `
const person = {
  firstName: 'John',
  lastName: 'Doe',
  set fullName(name) {
    [this.firstName, this.lastName] = name.split(' ');
  }
};

person.fullName = 'Jane Smith';
console.log(person.firstName); // Jane
console.log(person.lastName); // Smith
              `,
            },
            {
              title: "Заключение",
              type: "text",
              description: `
                <p>Дескрипторы, геттеры и сеттеры позволяют управлять доступом к свойствам объектов, обеспечивая более гибкий и контролируемый способ работы с данными в JavaScript.</p>
              `,
            },
            {
              title: "Подробнее на learn.javascript.ru",
              type: "link",
              url: "https://learn.javascript.ru/descriptors-getters-setters",
            }
          ],
        },
        {
          title: "Destructuring objects in JS",
          children: [
            {
              title: "",
              description:
                "Деструктуризация объектов позволяет извлекать значения из объекта и присваивать их переменным в краткой форме",
              type: "code",
              code: `
const person = { name: 'Alice', age: 25 };
const { name, age } = person;
console.log(name, age);`,
            },
          ],
        },
        {
          title: "Difference between null and undefined / Разница между null и undefined",
          children: [
            {
              title: "Описание null и undefined",
              type: "code",
              description: `
                <p><strong>null</strong>: Это специальное значение, указывающее на отсутствие какого-либо объектного значения. Оно явно назначается переменной, чтобы показать, что эта переменная не содержит ничего.</p>
                <p><strong>undefined</strong>: Это значение автоматически назначается переменной, которая была объявлена, но не инициализирована. Также это происходит, если функция не возвращает значения.</p>
                <ul>
                  <li>Оба значения представляют отсутствие значения, но в разных контекстах.</li>
                </ul>
              `,
              code: `
// Примеры null и undefined
let a = null;      // Явно задано значение null
let b;             // Не инициализирована, значение undefined

console.log(a);   // null
console.log(b);   // undefined

// Проверка типов
console.log(typeof a); // "object"
console.log(typeof b); // "undefined"
              `,
            },
            {
              title: "Сравнение null и undefined",
              type: "code",
              description: `
                <p>Важно понимать, что при нестрогом сравнении они равны друг другу:</p>
              `,
              code: `
console.log(null == undefined); // true (нестрогое сравнение)
console.log(null === undefined); // false (строгое сравнение)
              `,
            },
          ],
        },
        {
          title: "Drag and Drop / Перетаскивание",
          children: [
            {
              title: "Mouse Drag and Drop",
              type: "link",
              url: "https://learn.javascript.ru/mouse-drag-and-drop",
            },
            {
              title: "Основы Drag and Drop",
              type: "text",
              description: `
                <p>Drag and Drop — это способ улучшить интерфейс, позволяя пользователю перемещать элементы с помощью мыши. Это может быть полезно для копирования и перемещения документов, а также для других действий, таких как добавление элементов в корзину.</p>
              `,
            },
            {
              title: "Алгоритм Drag and Drop",
              type: "list",
              description: `
                <p>Базовый алгоритм Drag and Drop включает следующие шаги:</p>
                <ul>
                  <li><strong>mousedown</strong>: Подготовка элемента к перемещению.</li>
                  <li><strong>mousemove</strong>: Перемещение элемента на новые координаты.</li>
                  <li><strong>mouseup</strong>: Завершение перемещения элемента.</li>
                </ul>
              `,
            },
            {
              title: "Правильное позиционирование",
              type: "text",
              description: `
                <p>Чтобы избежать «прыжков» элемента при начале Drag and Drop, запоминаем расстояние от курсора до элемента и используем его при перемещении.</p>
              `,
            },
            {
              title: "Цели переноса (Droppable)",
              type: "list",
              description: `
                <p>Для реализации переноса элемента в другую цель, используйте метод <code>document.elementFromPoint</code> для определения, над каким элементом находится указатель.</p>
                <ul>
                  <li>Подсвечивайте элементы, когда мышь находится над ними.</li>
                  <li>Обрабатывайте окончание переноса, чтобы выполнить действия с элементами.</li>
                </ul>
              `,
            },
            {
              title: "Пример кода",
              type: "code",
              description: `
                <p>Пример реализации Drag and Drop:</p>
              `,
              code: `
ball.onmousedown = function(event) {
  // код для начала переноса
};

function onMouseMove(event) {
  // код для перемещения элемента
}
              `,
            },
          ],
        },
        {
          title: "ES6",
          children: [
            {
              title: "Destructuring assignment",
              type: "title",
            },
            {
              title: "Arrow functions () => {} ",
              type: "title",
            },
            {
              title: "Template strings `${}`",
              type: "title",
            },
            {
              title: "variable declaration with let and const",
              type: "title",
            },
            {
              title: "Classes",
              type: "title",
            },
            {
              title: "IIFE (immediately invoked function expression)",
              type: "title",
            },
            {
              title: "Multi-line strings",
              type: "title",
            },
            {
              title: "Promises",
              type: "title",
            },
            {
              title: "forEach and for...of",
              type: "title",
            },
            {
              title: "Default parameters",
              type: "title",
            },
            {
              title: "Rest-параметры и Spread-оператор ...",
              type: "title",
            },
          ],
        },
        {
          title: "Event Loop / Цикл событий",
          children: [
            {
              title:
                "Цикл событий (event loop) — это механизм, который позволяет JavaScript выполнять асинхронные операции, не блокируя основной поток выполнения. Он обеспечивает обработку событий и выполнение колбеков (callback functions) в ответ на события, такие как клики мыши, нажатия клавиш и завершение асинхронных операций.",
              type: "list",
              description: `
              <p>Вот как работает цикл событий:</p>
                <li>Обработка асинхронного кода: Если в обработчике события есть асинхронный код, такой как таймеры или сетевые запросы, он не блокирует выполнение других событий. Вместо этого асинхронный код помещается в очередь задач (task queue) для выполнения в будущем.</li>
                <li>Очередь сообщений (Message Queue): Когда асинхронная операция (например, запрос к серверу) завершается, соответствующий колбек помещается в очередь сообщений.</li>
                <li>Цикл событий: Цикл событий постоянно проверяет стек вызовов и очередь сообщений. Если стек пуст, он берет первое сообщение из очереди и помещает его в стек вызовов для выполнения.</li>
                <p>Таким образом, цикл событий позволяет JavaScript обрабатывать асинхронные операции, не блокируя выполнение других кода, что делает его эффективным для работы с пользовательскими интерфейсами и сетевыми запросами.</p>
              `,
            },
          ],
        },
        {
          title: "Function Levenshtein / Функция Левенштейна",
          children: [
            {
              title: "Function Levenshtein or Levenshtein Distance",
              type: "code",
              description: `
                <p>Функция Левенштейна, или расстояние Левенштейна, измеряет различие между двумя строками, 
                определяя минимальное количество операций, необходимых для преобразования одной строки в другую.
                </p>
                <ul>Операциями могут быть:
                  <li>Замена: Заменить один символ на другой;</li>
                  <li>Удаление: Удалить символ из строки;</li>
                  <li>Вставка: Вставить символ в строку;</li>
                </ul>
                <p>Суть и применение</p>
                <ul>
                  <li>Сравнение строк: Функция используется для нахождения «похожести» строк. Чем меньше расстояние Левенштейна, тем более похожи строки.</li>
                  <li>Поиск и исправление ошибок: Часто применяется в системах проверки правописания, для поиска похожих слов и исправления ошибок.</li>
                  <li>Обработка естественного языка: Используется в алгоритмах для сравнения слов и предложений, что может быть полезно в чат-ботах, поисковых системах и других NLP приложениях.</li>
                </ul>
                            `,
              code: `
function levenshtein(a, b) {
  if (a.length === 0) return b.length;
  if (b.length === 0) return a.length;
  const matrix = [];
  for (let i = 0; i <= b.length; matrix[i] = [i]) i++;
  for (let j = 0; j <= a.length; matrix[0][j] = j++) j++;
  for (let i = 1; i <= b.length; i++) {
    for (let j = 1; j <= a.length; j++) {
      matrix[i][j] = b[i - 1] === a[j - 1]
        ? matrix[i - 1][j - 1]
        : Math.min(
          matrix[i - 1][j - 1] + 1,
          Math.min(matrix[i][j - 1] + 1, matrix[i - 1][j] + 1)
        );
    }
  }
  return matrix[b.length][a.length];
}
`
            },
          ],
        },
        {
          title: "function declaration and expression, arrow function",
          children: [
            {
              title: "Описание объявлений и выражений функций",
              type: "code",
              description: `
                <p><strong>Объявление функции</strong>: Это способ определения функции с использованием ключевого слова <code>function</code>. Функция может быть вызвана до ее определения (подъем).</p>
                <p><strong>Выражение функции</strong>: Это определение функции, которое присваивается переменной. Функция не может быть вызвана до ее объявления.</p>
              `,
              code: `
// Объявление функции
function sayHello() {
  console.log("Hello!");
}
sayHello(); // "Hello!"

// Выражение функции
const greet = function() {
  console.log("Hi!");
};
greet(); // "Hi!"
              `,
            },
            {
              title: "Стрелочные функции",
              type: "code",
              description: `
                <p><strong>Стрелочные функции</strong>: Это упрощенный синтаксис для объявления функций, введенный в ES6. Они не имеют собственного значения <code>this</code> и не могут быть использованы 
                в качестве конструктора.</p>
              `,
              code: `
const multiply = (x, y) => x * y;
console.log(multiply(2, 3)); // 6

const add = (a, b) => {
  return a + b;
};
console.log(add(2, 3)); // 5
              `,
            },
            {
              title: "Сравнение синтаксиса",
              type: "code",
              description: `
                <p>Различия в синтаксисе между обычными и стрелочными функциями:</p>
              `,
              code: `
// Обычная функция
function square(x) {
  return x * x;
}

// Стрелочная функция
const squareArrow = (x) => x * x;

console.log(square(4)); // 16
console.log(squareArrow(4)); // 16
              `,
            },
            {
              title: "Преимущества",
              type: "code",
              description: `
                <p>Стрелочные функции обеспечивают более лаконичный синтаксис и удобнее работают с <code>this</code> в контексте методов, так как они наследуют <code>this</code> 
                от родительской области видимости.</p>
              `,
              code: `
const obj = {
  value: 100,
  regularFunction: function() {
    console.log(this.value);
  },
  arrowFunction: () => {
    console.log(this.value);
  },
};

obj.regularFunction(); // 100
obj.arrowFunction();   // undefined (т.к. 'this' не ссылается на obj)
              `,
            },
          ],
        },
        {
          title: "Features of arrow functions / Особенности стрелочных функций",
          children: [
            {
              title: "1. Синтаксис",
              type: "code",
              description: `
                <p>Стрелочные функции имеют более компактный синтаксис по сравнению с обычными функциями:</p>
              `,
              code: `
const add = (a, b) => a + b;
console.log(add(2, 3)); // 5
              `,
            },
            {
              title: "2. Лексическое значение this",
              type: "code",
              description: `
                <p>Стрелочные функции не имеют своего собственного <code>this</code>; вместо этого они используют <code>this</code> из окружающего контекста:</p>
              `,
              code: `
function Person() {
  this.age = 0;

  setInterval(() => {
  this.age++; // 'this' ссылается на объект Person
    console.log(this.age);
  }, 1000);
}

  const p = new Person(); // будет выводить возраст каждую секунду
              `,
            },
            {
              title: "3. Отсутствие объекта arguments",
              type: "code",
              description: `
                <p>Стрелочные функции не имеют собственного объекта <code>arguments</code>. Для доступа к аргументам можно использовать оператор <code>rest</code>:</p>
              `,
              code: `
const sum = (...args) => args.reduce((a, b) => a + b, 0);
console.log(sum(1, 2, 3, 4)); // 10
              `,
            },
            {
              title: "4. Не могут быть использованы как конструкторы",
              type: "code",
              description: `
                <p>Стрелочные функции не могут быть использованы с оператором <code>new</code>:</p>
              `,
              code: `
const Person = () => {};
// const p = new Person(); // ошибка: Person is not a constructor
              `,
            },
            {
              title: "5. Не имеют свойства prototype",
              type: "code",
              description: `
                <p>Стрелочные функции не имеют свойства <code>prototype</code>, что делает их непригодными для создания методов объектов:</p>
              `,
              code: `
const arrowFunc = () => {};
console.log(arrowFunc.prototype); // undefined
              `,
            },
            {
              title: "6. Возврат значений",
              type: "code",
              description: `
                <p>Если стрелочная функция состоит из одного выражения, то фигурные скобки и ключевое слово <code>return</code> можно опустить:</p>
              `,
              code: `
const square = x => x * x;
console.log(square(4)); // 16
              `,
            },
          ],
        },
        {
          title: "Global window object / Глобальный объект window",
          children: [
            {
              title: "1. Что такое объект window?",
              type: "text",
              description: `
                <p>Объект <code>window</code> представляет собой глобальный объект в браузере, который является корнем для всех объектов и функций в JavaScript.</p>
                <p>Он предоставляет доступ к свойствам и методам, связанным с окном браузера.</p>
              `,
            },
            {
              title: "2. Свойства объекта window",
              type: "text",
              description: `
                <p>Некоторые ключевые свойства объекта <code>window</code>:</p>
                <ul>
                  <li><code>window.document</code> - доступ к DOM-документу.</li>
                  <li><code>window.location</code> - информация о текущем URL.</li>
                  <li><code>window.history</code> - управление историей браузера.</li>
                  <li><code>window.navigator</code> - информация о браузере и его версиях.</li>
                </ul>
              `,
            },
            {
              title: "3. Методы объекта window",
              type: "text",
              description: `
                <p>Некоторые полезные методы объекта <code>window</code>:</p>
                <ul>
                  <li><code>window.alert()</code> - отображает простое окно с сообщением.</li>
                  <li><code>window.confirm()</code> - показывает диалоговое окно с вопросом и кнопками "OK" и "Cancel".</li>
                  <li><code>window.open()</code> - открывает новое окно или вкладку.</li>
                  <li><code>window.setTimeout()</code> - выполняет функцию через заданный интервал времени.</li>
                </ul>
              `,
            },
            {
              title: "4. Пример использования объекта window",
              type: "code",
              description: `
                <p>Пример использования объекта <code>window</code> для отображения сообщения:</p>
              `,
              code: `
window.alert('Привет, мир!');
              `
            },
            {
              title: "5. Особенности объекта window",
              type: "text",
              description: `
                <p>Объект <code>window</code> является единственным экземпляром глобального объекта в браузере, что означает, что:</p>
                <ul>
                  <li>Все глобальные переменные и функции доступны как свойства объекта <code>window</code>.</li>
                  <li>Вы можете обращаться к методам и свойствам через <code>this</code> в глобальном контексте.</li>
                </ul>
              `,
            },
          ],
        },
        {
          title: "How objects become primitives / Как объекты превращаются в примитивы",
          children: [
            {
              title: "Преобразование объектов в примитивы",
              type: "code",
              description: `
                <p>В JavaScript объекты могут быть автоматически преобразованы в примитивные значения в контекстах, таких как сравнение, арифметические операции или приведение типов. Процесс преобразования включает:</p>
                <ul>
                  <li>Попытка вызова метода <strong>valueOf()</strong></li>
                  <li>Попытка вызова метода <strong>toString()</strong></li>
                </ul>
              `,
              code: `
const obj = {
  valueOf: function() {
    return 42;
  }
};

console.log(obj + 10); // 52 (вызывается obj.valueOf())
              `,
            },
            {
              title: "Этапы преобразования",
              type: "code",
              description: `
                <p>Когда JavaScript пытается преобразовать объект в примитив, он выполняет следующие шаги:</p>
                <ol>
                  <li>Вызывать метод <strong>valueOf()</strong>. Если он возвращает примитив, то это значение используется.</li>
                  <li>Если <strong>valueOf()</strong> возвращает объект, то JavaScript попытется вызвать <strong>toString()</strong>. Если <strong>toString()</strong> возвращает примитив, то это значение используется.</li>
                </ol>
              `,
              code: `
const obj2 = {
  toString: function() {
    return 'Hello';
  }
};

console.log(obj2 + ' World'); // "Hello World" (вызывается obj2.toString())
              `,
            },
            {
              title: "Примеры преобразования",
              type: "code",
              description: `
                <p>Пример объекта с реализацией обоих методов:</p>
              `,
              code: `
const obj3 = {
  valueOf: function() {
    return 10;
  },
  toString: function() {
    return 'I am an object';
  }
};

console.log(obj3 + 5); // 15 (вызывается valueOf)
console.log(String(obj3)); // "I am an object" (вызывается toString)
              `,
            },
            {
              title: "Использование операторов",
              type: "code",
              description: `
                <p>Объекты могут быть преобразованы в примитивы при использовании операторов:</p>
                <ul>
                  <li>Сравнение: ==, ===</li>
                  <li>Арифметические операции: +, -, *, /</li>
                  <li>Приведение типов: String(), Number(), Boolean()</li>
                </ul>
              `,
              code: `
console.log([] + '1'); // "1" (вызывается toString)
console.log([1] == 1); // true (нестрогое сравнение, вызывается valueOf)
              `,
            },
            {
              title: "Вывод",
              type: "code",
              description: `
                <p>Объекты в JavaScript автоматически преобразуются в примитивные значения с использованием методов valueOf() и toString(). Контекст и ситуация определяют, какой метод будет вызван.</p>
              `,
              code: `
const obj4 = {
  valueOf: function() {
    return '5';
  },
  toString: function() {
    return 'I am an object';
  }
};

console.log(obj4 + 1); // "51" (вызывается valueOf)
console.log(obj4 == '5'); // true (нестрогое сравнение, вызывается valueOf)
              `,
            },
          ],
        },
        {
          title: "Hoisting / поднятие",
          children: [
            {
              title: "1. Определение Hoisting",
              type: "text",
              description: `
                <p>Hoisting (поднятие) в JavaScript - это механизм, при котором объявления переменных и функций поднимаются в верхнюю часть своей области видимости во время выполнения кода.</p>
              `,
            },
            {
              title: "2. Как работает Hoisting?",
              type: "text",
              description: `
                <p>При выполнении кода JavaScript сначала обрабатывает все объявления переменных и функций, а затем выполняет код. Это означает, что вы можете использовать функции и переменные до их фактического объявления в коде.</p>
              `,
            },
            {
              title: "3. Пример Hoisting с функциями",
              type: "code",
              description: `
                <p>Пример поднятия функций:</p>
              `,
              code: `
sayHello(); // Работает, выводит "Hello!"

function sayHello() {
  console.log("Hello!");
}
              `
            },
            {
              title: "4. Пример Hoisting с переменными",
              type: "code",
              description: `
                <p>Пример поднятия переменных:</p>
              `,
              code: `
console.log(myVar); // undefined

var myVar = 5;
console.log(myVar); // 5
              `
            },
            {
              title: "5. Что происходит на самом деле?",
              type: "text",
              description: `
                <p>Когда код выполняется, JavaScript фактически обрабатывает его следующим образом:</p>
                <pre>
        var myVar; // Объявление переменной поднимается
        console.log(myVar); // undefined
        myVar = 5; // Инициализация переменной
                </pre>
              `,
            },
            {
              title: "6. Hoisting с let и const",
              type: "text",
              description: `
                <p>Переменные, объявленные с помощью <code>let</code> и <code>const</code>, также поднимаются, но они находятся в Temporal Dead Zone (TDZ) до их инициализации:</p>
              `,
            },
            {
              title: "7. Пример Hoisting с let и const",
              type: "code",
              description: `
                <p>Пример с <code>let</code> и <code>const</code>:</p>
              `,
              code: `
console.log(a); // ReferenceError: Cannot access 'a' before initialization
let a = 10;

console.log(b); // ReferenceError: Cannot access 'b' before initialization
const b = 20;
              `
            },
            {
              title: "8. Важность понимания Hoisting",
              type: "text",
              description: `
                <p>Понимание Hoisting помогает избежать неожиданных ошибок и улучшает качество кода. Важно помнить, что хотя функции могут быть вызваны до их объявления, поведение переменных может привести к неожиданным результатам.</p>
              `,
            },
          ],
        },
        {
          title: "Inheritance / наследование",
          children: [
            {
              title: "Прототипное наследование",
              type: "code",
              description: `
                <p><strong>Прототипное наследование</strong>: В JavaScript объекты могут наследовать свойства и методы от других объектов через механизм прототипов. Каждый объект имеет внутреннюю ссылку на свой прототип, который может содержать свойства и методы, доступные наследуемым объектам.</p>
                <p>Это характерно для JavaScript и позволяет разработчикам расширять возможности объектов без необходимости использовать классы.</p>
              `,
              code: `
// Создаем объект родитель
const parent = {
  greet: function() {
    console.log("Hello from parent!");
  }
};

// Создаем объект child с наследованием от parent
const child = Object.create(parent);
child.greet(); // "Hello from parent!"
              `,
            },
            {
              title: "Классы ES6",
              type: "code",
              description: `
                <p><strong>Классы ES6</strong>: С появлением ES6 в JavaScript появилась возможность использования классов. Классы предоставляют более удобный и понятный синтаксис для реализации наследования. Классы также используют механизм прототипов под капотом.</p>
              `,
              code: `
class Parent {
  greet() {
    console.log("Hello from parent class!");
  }
}

class Child extends Parent {
  greet() {
    console.log("Hello from child class!");
  }
}

const childInstance = new Child();
childInstance.greet(); // "Hello from child class!"
const parentInstance = new Parent();
parentInstance.greet(); // "Hello from parent class!"
              `,
            },
            {
              title:
                "Наследование с использованием Object.setPrototypeOf",
              type: "code",
              description: `
                <p><strong>Object.setPrototypeOf</strong>: Этот метод можно использовать для изменения прототипа существующего объекта. Это также позволяет реализовать наследование, но рекомендуется использовать в основном в особых случаях, т.к. может привести к ухудшению производительности.</p>
              `,
              code: `
const parent = {
  greet: function() {
    console.log("Hello from parent!");
  }
};

const child = {};
Object.setPrototypeOf(child, parent);
child.greet(); // "Hello from parent!"
              `,
            },
            {
              title: "Сравнение различных способов наследования",
              type: "code",
              description: `
                <p>Различные способы реализации наследования в JavaScript имеют свои преимущества и недостатки:</p>
                <ul>
                  <li><strong>Прототипное наследование:</strong> Гибкость, но может быть сложнее для понимания начинающим.</li>
                  <li><strong>Классы ES6:</strong> Более читаемый и привычный синтаксис, похожий на другие языки программирования.</li>
                  <li><strong>Object.setPrototypeOf:</strong> Не рекомендуется для частого использования, так как имеет низкую производительность.</li>
                </ul>
              `,
              code: `
// Обзор методов
console.log(Object.getPrototypeOf(child) === parent); // true
console.log(child instanceof Child); // true
console.log(child instanceof Parent); // true
              `,
            },
          ],
        },
        {
          title: "IIFE (Immediately Invoked Function Expression) / (Немедленно вызванное функциональное выражение)",
          children: [
            {
              title: "Описание IIFE",
              type: "code",
              description: `
                <p>
                  <strong>IIFE</strong>: Это функциональное выражение, которое выполняется сразу после его определения. Это позволяет создать локальную область видимости и изолировать переменные от глобальной области видимости.
                </p>
                <p>
                  IIFE часто используется для организации кода и предотвращения загрязнения глобального пространства имен.
                </p>
              `,
              code: `
(function() {
  var localVariable = 'I am local';
  console.log(localVariable); // 'I am local'
})();

// console.log(localVariable); // Uncaught ReferenceError: localVariable is not defined
              `,
            },
            {
              title: "Синтаксис IIFE",
              type: "code",
              description: `
                <p>Стандартный синтаксис включает в себя определение функции, заключенное в круглые скобки, и сразу же вызываемое с использованием дополнительных круглых скобок.</p>
              `,
              code: `
(function() {
  // Код здесь
})();

// Или с использованием стрелочной функции
(() => {
  // Код здесь
})();
              `,
            },
            {
              title: "Преимущества использования IIFE",
              type: "code",
              description: `
                <p>
                  <strong>Преимущества:</strong>
                  <ul>
                    <li>Изолированная область видимости для переменных.</li>
                    <li>Предотвращение конфликтов переменных с глобальной областью видимости.</li>
                    <li>Помогает безопасно избегать переменных, которые могут повлиять на другие скрипты.</li>
                  </ul>
                </p>
              `,
              code: `
(function() {
  var count = 0; // Локальная переменная, недоступная вне IIFE
  console.log(count); // 0
})();

// console.log(count); // Uncaught ReferenceError: count is not defined
              `,
            },
          ],
        },
        {
          title: "Lexical Environment / Лексическое окружение",
          children: [
            {
              title: "1. Определение лексического окружения",
              type: "text",
              description: `
                <p>Лексическое окружение в JavaScript - это структура, которая хранит все переменные и функции, доступные в определённой области видимости. Оно создаётся во время исполнения кода и используется для определения, где и как переменные могут быть использованы.</p>
              `,
            },
            {
              title: "2. Составляющие лексического окружения",
              type: "text",
              description: `
                <p>Лексическое окружение состоит из двух основных частей:</p>
                <ul>
                  <li><strong>Объект окружения:</strong> Содержит все переменные и функции, доступные в данной области видимости.</li>
                  <li><strong>Ссылка на внешнее окружение:</strong> Указывает на лексическое окружение, в котором была создана текущая функция. Это позволяет функции доступ к переменным из внешней области видимости.</li>
                </ul>
              `,
            },
            {
              title: "3. Пример лексического окружения",
              type: "code",
              description: `
                <p>Пример, иллюстрирующий лексическое окружение:</p>
              `,
              code: `
function outerFunction() {
  let outerVar = 'I am outside!';

  function innerFunction() {
    console.log(outerVar); // Доступ к переменной outerVar из внешнего окружения
  }

  return innerFunction;
}

const myInnerFunction = outerFunction();
myInnerFunction(); // Вывод: "I am outside!"
              `
            },
            {
              title: "4. Как лексическое окружение связано с замыканиями?",
              type: "text",
              description: `
                <p>Когда функция создаётся, она захватывает свое лексическое окружение. Это означает, что даже после завершения внешней функции, внутренние функции могут продолжать получать доступ к переменным, объявленным в этом окружении. Это и есть замыкание.</p>
              `,
            },
            {
              title: "5. Значение лексического окружения для производительности",
              type: "text",
              description: `
                <p>Лексическое окружение помогает JavaScript управлять памятью и областью видимости. Понимание этой концепции помогает разработчикам писать более эффективный и управляемый код.</p>
              `,
            },
          ],
        },
        {
          title: "Living and nonliving collections / Живые и неживые коллекции",
          children: [
            {
              title: "1. Что такое коллекции в JavaScript?",
              type: "text",
              description: `
                <p>Коллекции в JavaScript - это объекты, которые хранят группы элементов. Они могут быть живыми или неживыми в зависимости от их поведения при изменении DOM.</p>
              `,
            },
            {
              title: "2. Живые коллекции",
              type: "text",
              description: `
                <p>Живые коллекции автоматически обновляются при изменении DOM. Примеры:</p>
                <ul>
                  <li><code>document.getElementsByTagName()</code></li>
                  <li><code>document.getElementsByClassName()</code></li>
                  <li><code>document.childNodes</code></li>
                </ul>
                <p>При добавлении или удалении элементов, живые коллекции будут отражать эти изменения.</p>
              `,
            },
            {
              title: "3. Неживые коллекции",
              type: "text",
              description: `
                <p>Неживые коллекции не обновляются при изменении DOM. Примеры:</p>
                <ul>
                  <li><code>document.querySelectorAll()</code></li>
                  <li><code>Array.from()</code> (при преобразовании живых коллекций)</li>
                </ul>
                <p>Эти коллекции сохраняют состояние на момент их создания и не реагируют на изменения в DOM.</p>
              `,
            },
            {
              title: "4. Пример работы с живыми коллекциями",
              type: "code",
              description: `
                <p>Пример использования живой коллекции:</p>
              `,
              code: `
        const elements = document.getElementsByClassName('example');
        console.log(elements.length); // Выводит количество элементов с классом 'example'
        
        // Добавим новый элемент с классом 'example'
        const newElement = document.createElement('div');
        newElement.className = 'example';
        document.body.appendChild(newElement);
        
        console.log(elements.length); // Теперь длина коллекции увеличилась
              `
            },
            {
              title: "5. Пример работы с неживыми коллекциями",
              type: "code",
              description: `
                <p>Пример использования неживой коллекции:</p>
              `,
              code: `
        const staticElements = document.querySelectorAll('.example');
        console.log(staticElements.length); // Выводит количество элементов с классом 'example'
        
        // Добавим новый элемент с классом 'example'
        const newStaticElement = document.createElement('div');
        newStaticElement.className = 'example';
        document.body.appendChild(newStaticElement);
        
        console.log(staticElements.length); // Длина коллекции не изменилась
              `
            },
          ],
        },
        {
          title: "Linear equation / Линейное уравнение",
          children: [
            {
              title: "1. Определение линейного уравнения",
              type: "text",
              description: `
                <p>Линейное уравнение - это алгебраическое уравнение, в котором каждая переменная имеет степень 1. Общее уравнение с двумя переменными (x и y) имеет вид:</p>
                <p><code>ax + by = c</code>,</p>
                <p>где <code>a</code> и <code>b</code> - коэффициенты, <code>x</code> и <code>y</code> - переменные, <code>c</code> - константа.</p>
              `,
            },
            {
              title: "2. Графическое представление",
              type: "text",
              description: `
                <p>График линейного уравнения представляет собой прямую линию в координатной плоскости. Угловой коэффициент определяет наклон этой линии, а y-перехват указывает, где линия пересекает ось y.</p>
              `,
            },
            {
              title: "3. Пример линейного уравнения",
              type: "code",
              description: `
                <p>Пример линейного уравнения в стандартной форме:</p>
              `,
              code: `
2x + 3y = 6
              `
            },
            {
              title: "4. Преобразование в форму с угловым коэффициентом",
              type: "code",
              description: `
                <p>Преобразование стандартного уравнения в форму с угловым коэффициентом:</p>
              `,
              code: `
y = -\\frac{2}{3}x + 2
              `
            },
            {
              title: "5. Пример кода для решения линейного уравнения",
              type: "code",
              description: `
                <p>Пример кода на JavaScript, который решает линейное уравнение:</p>
              `,
              code: `
function solveLinearEquation(a, b, c) {
  // Решение уравнения ax + by = c для y
  let y = (c - a) / b;
  return y;
}

let a = 2;
let b = 3;
let c = 6;

console.log(solveLinearEquation(a, b, c)); // Вывод: 0
              `
            },
            {
              title: "6. Применение линейных уравнений",
              type: "text",
              description: `
                <p>Линейные уравнения используются в различных областях, таких как экономика, физика и инженерное дело. Они помогают моделировать отношения между переменными и находить решения для различных задач.</p>
              `,
            },
          ],
        },
        {
          title: "Methods",
          children: [
            {
              title: "Array Methods",
              children: [
                {
                  title: "1. pop() => removes the last element from an array.",
                  type: "title",
                },
                {
                  title: "2.shift() => удаляет элемент в начале массива",
                  type: "title",
                },
                {
                  title:
                    "3.push() => добавляется несколько элементов в конец массива",
                  type: "title",
                },
                {
                  title:
                    "4.unshift() => добавляет несколько элементов в начало массива",
                  type: "title",
                },
                {
                  title: "5.length => получаем число элементов массива",
                  type: "title",
                },
                {
                  title: `6.splice() => добавление нескольких элементов в массив; 
                            первый аргумент указывает где начать вставку элементов по индексу; 
                            второй аргумент указывает сколько элементов нужно удалить, если аргумент не указать, то удаления не будет, просто добавится новый элемент в массиве; самые новые элементы указываются в скобках данного метода в кавычках,`,
                  type: "title",
                },
                {
                  title: `7.slice() => вырезает один или несколько элементов массива
                            через указатель аргумента начала вырезания и второй аргумент где закончить срез;
                            принимает отрицательные значения.`,
                  type: "title",
                },
                {
                  title: "8.concat() => конкатенация двух массивов",
                  type: "title",
                },
                {
                  title: `9.map() => принимает массив и применяет указанную функцию для
                            всех элементов массива; возвращает новый массив.`,
                  type: "title",
                },
                {
                  title: `10.every() => проверяет, соответствуют ли все элементы указанному
                            массиву определённому условию; если все элементы соответствуют условию, то возвращает
                            метод true, в противном случае вернёт false.`,
                  type: "title",
                },
                {
                  title: `11.includes() => проверяет на наличие в массиве элемента; если
                            элемент найден, то возвращает true.`,
                  type: "title",
                },
                {
                  title: `12.spread() => превращает массив в строки с помощью специальных
                            разделителей … сохраняет между ними границу или по умолчанию между строками образуются
                            пробелы.`,
                  type: "title",
                },
                {
                  title: `13.filter() => возвращает новый массив из всех элементов соответствующих
                            заданному условию.`,
                  type: "title",
                },
                {
                  title:
                    "14.reduce(function (previousValue, item, index, array) { … }, [initial]); => сводит массив к одному значению.",
                  type: "title",
                },
                {
                  title:
                    "15.reduceRight() => сводит массив к одному значение с права на лево.",
                  type: "title",
                },
                {
                  title: `16.indexOf() => возвращает первый индекс по которому может быть найден
                            элемент в массиве и -1 если такого элемента нет; это не тоже самое что и Boolean values,
                            мы можем получать 2 и более индекса совпадений по массиву.`,
                  type: "title",
                },
                {
                  title: `17.sort() => возвращает отсортированный массив; если compareFunction
                            предоставлена, то массив сортируется в соответствиями с этими условиями.`,
                  type: "title",
                },
                {
                  title: `18.find() => возвращает значение первого найденного в массиве элемента,
                            который удовлетворяет условию указанных в функции, в противном случае возвращает undefined.`,
                  type: "title",
                },
                {
                  title: `19.findIndex() => возвращает индекс в массиве, если элемент удовлетворяет
                            условиям проверяющей функции, в противном случае вернёт -1.`,
                  type: "title",
                },
                {
                  title: `20.forEach(function (item, index, array) { … } => выполняет указанную
                            функцию один раз для каждого элемента в массиве.`,
                  type: "title",
                },
                {
                  title:
                    "21.join(‘, ’) => преобразовывает массив в строку с заданным разделителем.",
                  type: "title",
                },
                {
                  title:
                    "22.isArray() => проверяем массив ли этот объект или нет.",
                  type: "title",
                },
                {
                  title: "Learn more about array methods.",
                  type: "link",
                  url: "https://learn.javascript.ru/array-methods",
                },
                {
                  title: "Visual representation of array methods.",
                  type: "link",
                  url: "https://medium.com/@sewolpe/visualizing-javascript-array-methods-7babf560f7be",
                },
              ],
            },
            {
              title: "Strings Methods",
              children: [
                {
                  title: "1.toUpperCase() => перевод строки в верхний регистр",
                  type: "title",
                },
                {
                  title: "2.toLowerCase() => перевод строки в нижний регистр",
                  type: "title",
                },
                {
                  title: "3.trim() => удаляет пробелы в начале и конце строки",
                  type: "title",
                },
                {
                  title: "4.length => получаем длину строки",
                  type: "title",
                },
                {
                  title: `5.includes() => проверяет на наличие в строке элемента; если элемент найден, то возвращает true.`,
                  type: "title",
                },
                {
                  title: `6.spread() => превращает массив в строки с помощью специальных разделителей ... сохраняет между ними границу или по умолчанию между строками образуются пробелы.`,
                  type: "title",
                },
                {
                  title: `7.repeat() => повторяет строку указанное количество раз.`,
                  type: "title",
                },
                {
                  title: `8.split() => разбивает строку на массив подстроки по указанному разделителю. Возвращает новый массив, который содержит подстроки полученные в ходе разбиения.`,
                  type: "title",
                },
                {
                  title: `9.startsWith() => проверяет на наличие в начале строки указанного элемента. Возвращает true или false`,
                  type: "title",
                },
                {
                  title: `10.endsWith() => проверяет на наличие в конце строки указанного элемента. Возвращает true или false`,
                  type: "title",
                },
                {
                  title: `11.slice() => вырезает один или несколько элементов внутри строки через указатель аргумента начала вырезания и второй аргумент где закончить срез; принимает отрицательные значения.`,
                  type: "title",
                },
                {
                  title: `12.substring() => возвращает вырезанную часть строки, но не принимает отрицательные числа в качестве аргументов.`,
                  type: "title",
                },
                {
                  title: `13.concat() => конкатенация между собой строк в одну строку`,
                  type: "title",
                },
                {
                  title: `14.charCodeAt() => возвращает значение символа по Юникод.`,
                  type: "title",
                },
                {
                  title: `15.charAt() => возвращает символ по Юникод.`,
                  type: "title",
                },
                {
                  title: `16.trimStart() => удаляет пробелы в начале строки.`,
                  type: "title",
                },
                {
                  title: `17.trimEnd() => удаляет пробелы в конце строки.`,
                  type: "title",
                },
                {
                  title: `18.padStart() => добавляет символы в начале строки, чтобы результирующая строка получила указанную длину; по умолчанию метод возвращает пустую строку до указанной длины, но может принимать и другие символы указанные во втором аргументе.`,
                  type: "title",
                },
                {
                  title: `19.padEnd() => добавляет символы в конце строки, чтобы результирующая строка получила указанную длину.`,
                  type: "title",
                },
                {
                  title: `20.indexOf() => возвращает индекс первого вхождения указанного элемента в строку. Если элемент не найден, возвращает -1.`,
                  type: "title",
                },
                {
                  title: `21.at(-1) или at() => получает последний символ строки или символ согласно индексу слева на право, так же как при отрицательном значении принимает символ с право на лево.`,
                  type: "title",
                },
                {
                  title: `22.search()`,
                  type: "code",
                  description: `search() => возвращает индекс первого вхождения подстроки в строке.`,
                  code: `console.log(str.search('World')); // 9`
                }
              ],
            },
            {
              title: "Numbers Methods",
              children: [
                {
                  title:
                    "1.toFixed(number) => форматирует число с использованием записи с фиксированной запятой. Аргументам принимает количество знаков после запяты.",
                  type: "title",
                },
                {
                  title:
                    "2.parseFloat(string) => принимает строку в качестве аргумента и возвращает число с плавающей точной.",
                  type: "title",
                },
                {
                  title:
                    "3.parseInt(string, radix) => принимает строку в качестве аргумента и возвращает целое число в соответствии с указанной системой счисления.",
                  type: "title",
                },
                {
                  title:
                    "4.Number() => преобразовывает строку в числовой тип данных.",
                  type: "title",
                },
                {
                  title: "toExponential()",
                  type: "code",
                  description:
                    "<p>Преобразует число в экспоненциальное представление.</p>",
                  code: "var x = 9.656; console.log(x.toExponential(2)); // '9.66e+0'",
                },
                {
                  title: "toPrecision()",
                  type: "code",
                  description:
                    "<p>Возвращает строку с числом, записанным с указанной длиной.</p>",
                  code: "var x = 9.656; console.log(x.toPrecision(4)); // '9.656'",
                },
                {
                  title: "Методы Math",
                  children: [
                    {
                      title: "Math.max()",
                      type: "code",
                      description: "<p>Возвращает наибольшее значение.</p>",
                      code: "console.log(Math.max(1, 2, 3)); // 3",
                    },
                    {
                      title: "Math.min()",
                      type: "code",
                      description: "<p>Возвращает наименьшее значение.</p>",
                      code: "console.log(Math.min(1, 2, 3)); // 1",
                    },
                    {
                      title: "Math.random()",
                      type: "code",
                      description:
                        "<p>Генерирует случайное число от 0 до 1.</p>",
                      code: `
function getRandomInt(min, max) {
  // генерация случайного целого числа
  return Math.floor(Math.random() * (max - min + 1)) + min;
}
console.log(getRandomInt(1, 10)); // случайное число от 1 до 10
                      `,
                    },
                    {
                      title: "Math.round()",
                      type: "code",
                      description:
                        "<p>Округляет число до ближайшего целого.</p>",
                      code: "console.log(Math.round(4.6)); // 5",
                    },
                    {
                      title: "5.Math.sqrt() => возвращает квадратный корень числа.",
                      type: "title",
                    },
                    {
                      title: "6.Math.cbrt() => возвращает кубический корень числа.",
                      type: "title",
                    },
                    {
                      title:
                        "7.Math.abs() => возвращает абсолютное значение числа.",
                      type: "title",
                    },
                    {
                      title:
                        "8.Math.pow() => возвращает число, возведённое в степень.",
                      type: "title",
                    },
                  ],
                },
              ],
            },
            {
              title: "Object Methods",
              children: [
                {
                  title: "1.Object.keys(obj): Возвращает массив строк, содержащий имена собственных перечисляемых свойств объекта.",
                  type: "code",
                  description: `<p>Примеры использования <code>Object.keys()</code>:</p>`,
                  code: `
const person = { name: 'Alice', age: 25 };
console.log(Object.keys(person)); // ['name', 'age']
                                      `,
                },
                {
                  title: "2.Object.values(obj): Возвращает массив значений собственных перечисляемых свойств объекта.",
                  type: "code",
                  description: `<p>Примеры использования <code>Object.values()</code>:</p>`,
                  code: `
const person = { name: 'Alice', age: 25 };
console.log(Object.values(person)); // ['Alice', 25]
                                      `,
                },
                {
                  title: "3.Object.create(proto, propertiesObject): Создает новый объект с указанным прототипом и свойствами.",
                  type: "code",
                  description: `<p>Примеры использования <code>Object.create()</code>:</p>`,
                  code: `
const proto = { greet() { console.log('Hello!'); } };
const obj = Object.create(proto);
obj.greet(); // 'Hello!'
                  `,
                },
                {
                  title: "4.Object.freeze(obj): Замораживает объект, предотвращая добавление, удаление или изменение его свойств.",
                  type: "code",
                  description: `<p>Примеры использования <code>Object.freeze()</code>:</p>`,
                  code: `
const obj = { name: 'Alice' };
Object.freeze(obj);
obj.name = 'Bob'; // не сработает
console.log(obj.name); // 'Alice'
                  `,
                },
                {
                  title: "5.Object.assign(target, ...sources): Копирует значения всех собственных перечисляемых свойств из одного или более источников в целевой объект и возвращает его.",
                  type: "code",
                  description: `<p>Примеры использования <code>Object.assign()</code>:</p>`,
                  code: `
const target = { a: 1 };
const source = { b: 2, c: 3 };
const returnedTarget = Object.assign(target, source);
console.log(returnedTarget); // { a: 1, b: 2, c: 3 }
                  `,
                },
                {
                  title: "6.Object.entries(obj): Возвращает массив пар [ключ, значение] для собственных перечисляемых свойств объекта.",
                  type: "code",
                  description: `<p>Примеры использования <code>Object.entries()</code>:</p>`,
                  code: `
const person = { name: 'Alice', age: 25 };
console.log(Object.entries(person)); // [['name', 'Alice'], ['age', 25]]
                  `,
                },
                {
                  title:
                    "7.Object.seal(obj): Замораживает объект, предотвращая добавление, удаление или изменение его свойств.",
                  type: "code",
                  description: `<p>Примеры использования <code>Object.seal()</code>:</p>`,
                  code: `
const obj = { name: 'Alice' };
Object.seal(obj);
obj.age = 25; // не сработает
obj.name = 'Bob'; // сработает
console.log(obj); // { name: 'Bob' }
                  `,
                },
                {
                  title:
                    "8.Object.is(value1, value2): Определяет, являются ли два значения одним и тем же значением.",
                  type: "code",
                  description: `<p>Примеры использования <code>Object.is()</code>:</p>`,
                  code: `
console.log(Object.is('abc', 'abc')); // true
console.log(Object.is(0, -0)); // false
console.log(Object.is(NaN, NaN)); // true
console.log(Object.is(null, undefined)); // false
                  `,
                },
                {
                  title: "9. Object.prototype.hasOwnProperty(): Возвращает булево значение, указывающее, является ли указанное свойство собственным свойством объекта.",
                  type: "code",
                  description: `<p>Примеры использования <code>Object.prototype.hasOwnProperty()</code>:</p>`,
                  code: `
const obj = { name: 'Alice' };
console.log(obj.hasOwnProperty('name')); // true
console.log(obj.hasOwnProperty('age')); // false
                  `,
                },
              ],
            },
            {
              title: "Cycle",
              children: [
                {
                  title: "for, while, do while",
                  children: [
                    {
                      title: "Использование циклов for, while, do while",
                      type: "code",
                      description: `
                      <p>В JavaScript существуют различные виды циклов, которые позволяют повторять выполнение блока кода определенное количество раз или до тех пор, пока выполняется заданное условие.</p>
                      <ul>
                        <li><strong>Цикл for</strong>: Используется, когда известно количество итераций.</li>
                        <li><strong>Цикл while</strong>: Используется, когда количество итераций неизвестно, и необходимо повторять выполнение до тех пор, пока условие истинно.</li>
                        <li><strong>Цикл do while</strong>: Похож на цикл while, но гарантирует хотя бы одну итерацию.</li>
                      </ul>
                      `,
                      code: `
// Пример цикла for
for (let i = 0; i < 5; i++) {
  console.log("Итерация: " + i); // Выводит 0, 1, 2, 3, 4
}

// Пример цикла while
let j = 0; 
while (j < 5) {
  console.log("Итерация: " + j); // Выводит 0, 1, 2, 3, 4
  j++;
}

// Пример цикла do while
let k = 0;
do {
  console.log("Итерация: " + k); // Выводит 0, 1, 2, 3, 4
  k++;
} while (k < 5);
                      `,
                    },
                  ],
                },
                {
                  title:"1.for => повторяет блок кода определённое количество раз.",
                  type: "title",
                },
                {
                  title:"2.while => повторяет блок кода до тех пор, пока не выполнится условие.",
                  type: "title",
                },
                {
                  title:"3.do while => повторяет блок кода до тех пор, пока не выполнится условие. После чего выполняется блок кода.",
                  type: "title",
                },
                {
                  title:"4.for...of => повторяет блок кода для каждого элемента в массиве.",
                  type: "title",
                },
                {
                  title:"5.forEach() => повторяет блок кода для каждого элемента в массиве.",
                  type: "title",
                },
                {
                  title:"6.for in => повторяет блок кода для каждого свойства в объекте.",
                  type: "title",
                },
                {
                  title: "7.break => прерывает выполнение цикла.",
                  type: "title",
                },
                {
                  title:"8.continue => прерывает текущую итерацию цикла и переходит к следующей.",
                  type: "title",
                },
              ],
            },
            {
              title: "work with JSON",
              children: [
                {
                  title: `JSON.stringify(value, replacer, space): Преобразует значение в строку JSON.`,
                  type: "title",
                },
                {
                  title: `JSON.parse(text, reviver): Преобразует строку JSON в значение.`,
                  type: "title",
                },
              ],
            },
          ],
        },
        {
          title: "NaN (Not-a-Number)",
          children: [
            {
              title: "Использование NaN в JavaScript",
              type: "code",
              description: `
                <p>NaN (Not-a-Number) — специальное значение в JavaScript, которое представляет собой результат вычисления, не являющегося числом.</p>
                <ul>
                  <li>NaN является единственным значением, которое не равно ни одному числу, включая само себя.</li>
                  <li>Для проверки на NaN в JavaScript следует использовать функцию <code>isNaN()</code> или <code>Number.isNaN()</code>.</li>
                </ul>
                <p>Вот примеры работы с NaN:</p>
              `,
              code: `
// Примеры, когда результатом является NaN
console.log(0 / 0); // NaN
console.log(Math.sqrt(-1)); // NaN
console.log(parseInt('abc')); // NaN

// Проверка на NaN
console.log(isNaN(NaN)); // true
console.log(isNaN('abc')); // true
console.log(isNaN(123)); // false

// Использование Number.isNaN
console.log(Number.isNaN(NaN)); // true
console.log(Number.isNaN('abc')); // false
console.log(Number.isNaN(undefined)); // false
              `,
            },
          ],
        },
        {
          title: "Override browser defaults / Отмена действий браузера по умолчанию",
          children: [
            {
              title: "1. Что такое действия по умолчанию?",
              type: "text",
              description: `
                <p>Действия по умолчанию - это стандартные действия браузера на определенные события, например:</p>
                <ul>
                  <li>Переход по ссылке при клике на элемент <code>&lt;a&gt;</code>.</li>
                  <li>Отправка формы при нажатии кнопки <code>&lt;button&gt;</code>.</li>
                  <li>Прокрутка страницы при нажатии клавиш со стрелками.</li>
                </ul>
              `,
            },
            {
              title: "2. Как отменить действия по умолчанию?",
              type: "text",
              description: `
                <p>Для отмены действий по умолчанию используйте метод <code>event.preventDefault()</code>.</p>
                <p>Этот метод предотвращает выполнение стандартной реакции браузера на событие.</p>
              `,
            },
            {
              title: "3. Пример отмены действий по умолчанию",
              type: "code",
              description: `
                <p>Пример отмены перехода по ссылке:</p>
              `,
              code: `
const link = document.getElementById('myLink');

link.addEventListener('click', function(event) {
  event.preventDefault(); // Отменяет переход по ссылке
  console.log('Переход отменен!');
});
              `
            },
            {
              title: "4. Когда использовать отмену действий по умолчанию?",
              type: "text",
              description: `
                <p>Отмена действий по умолчанию полезна, когда вы хотите:</p>
                <ul>
                  <li>Изменить стандартное поведение элемента.</li>
                  <li>Добавить свою логику обработки события.</li>
                  <li>Создать пользовательский интерфейс с уникальным поведением.</li>
                </ul>
              `,
            },
          ],
        },
        {
          title: "Promise",
          children: [
            {
              title: "Определение",
              type: "list",
              description: `
                <p>Promise — это объект, представляющий конечный результат асинхронной операции. Он может находиться в одном из трех состояний:</p>
                <ul>
                  <li><strong>Ожидание (pending)</strong>: начальное состояние, ни выполнено, ни отклонено.</li>
                  <li><strong>Выполнено (fulfilled)</strong>: операция завершена успешно.</li>
                  <li><strong>Отклонено (rejected)</strong>: операция завершена с ошибкой.</li>
                </ul>
              `,
            },
            {
              title: "Создание Promise",
              type: "code",
              description: `
                <p>Promise создается с помощью конструктора <code>Promise</code>, который принимает функцию с двумя аргументами: <code>resolve</code> и <code>reject</code>.</p>
              `,
              code: `
const myPromise = new Promise((resolve, reject) => {
  // Асинхронная операция
  const success = true; // поменяйте на false для теста отклонения

  if (success) {
    resolve('Operation was successful!');
  } else {
    reject('Operation failed.');
    }
});
              `,
            },
            {
              title: "Основные статические методы Promise",
              type: "list",
              description: `
                <p>Promise предоставляет несколько статических методов:</p>
                <ul>
                  <li><strong>Promise.all(iterable)</strong>: Ожидает выполнения всех переданных промисов и возвращает массив результатов. Если любой из промисов будет отклонен, возвращается ошибка.</li>
                  <li><strong>Promise.allSettled(iterable)</strong>: Ожидает выполнения всех переданных промисов и возвращает массив объектов с результатами (выполнено или отклонено) для каждого промиса.</li>
                  <li><strong>Promise.any(iterable)</strong>: Ожидает выполнения первого успешного промиса. Если все промисы будут отклонены, возвращается ошибка.</li>
                  <li><strong>Promise.race(iterable)</strong>: Ожидает выполнения первого завершенного промиса (выполнено или отклонено).</li>
                  <li><strong>Promise.resolve(value)</strong>: Возвращает промис, который выполнен с заданным значением.</li>
                  <li><strong>Promise.reject(reason)</strong>: Возвращает промис, который отклонен с заданной причиной.</li>
                </ul>
              `,
            },
          ],
        },
        {
          title: "Page Visibility API",
          children: [
            {
              title:
                "Реализация паузы/старта видео в зависимости от состояния видимости страницы",
              description: `Page Visibility API — это API браузера, который проверяет видимость страницы. Он помогает определять, скрыта или свернута текущая страница, и тем самым позволяет контролировать ее поведение и использование ресурсов`,
              type: "code",
              code: `
const video = document.querySelector('video');
document.addEventListener('visibilitychange', () => {
  if (document.hidden) {
    video.pause();
  } else {
    video.play();
  }
});
`,
              link: "Подробнее — MDN",
              url: "https://medium.com/nuances-of-programming/%D0%B2%D0%B2%D0%B5%D0%B4%D0%B5%D0%BD%D0%B8%D0%B5-%D0%B2-page-visibility-api-fca074a5b113",
            },
          ],
        },
        {
          title: "Recursion",
          children: [
            {
              title: "Определение",
              type: "list",
              description: `
                <p><strong>Рекурсия</strong> — это функция вызывающая саму себя для решения подзадач. Рекурсивные функции обычно разбивают задачу на меньшие подзадачи, которые решаются аналогичным образом.</p>
              `,
            },
            {
              title: "Структура рекурсивной функции",
              type: "code",
              description: `
                <p>Рекурсивная функция должна иметь:</p>
                <ul>
                  <li><strong>Базовый случай</strong>: Условие, при котором функция прекращает вызывать саму себя, чтобы избежать бесконечной рекурсии.</li>
                  <li><strong>Рекурсивный случай</strong>: Вызов самой функции с меньшей или более простой версией задачи.</li>
                </ul>
              `,
              code: `
function factorial(n) {
  if (n === 0) { // базовый случай
    return 1;
  }
  return n * factorial(n - 1); // рекурсивный случай
}
console.log(factorial(5)); // 120
              `,
            },
            {
              title: "Примеры использования",
              type: "list",
              description: `
                <p>Рекурсия может быть использована в следующих ситуациях:</p>
                <ul>
                  <li>Вычисление факториала.</li>
                  <li>Обход деревьев и графов.</li>
                  <li>Решение задач, таких как сортировка (например, быстрая сортировка, сортировка слиянием).</li>
                  <li>Решение задач, связанных с последовательностями (например, числа Фибоначчи).</li>
                </ul>
              `,
            },
            {
              title: "Преимущества и недостатки",
              type: "list",
              description: `
                <p>Преимущества и недостатки рекурсии:</p>
                <ul>
                  <li><strong>Преимущества:</strong> Код более лаконичен и понятен, особенно при работе со сложными структурами данных.</li>
                  <li><strong>Недостатки:</strong> Рекурсия может приводить к большому потреблению памяти из-за хранения состояния вызовов стека и может быть менее эффективной по сравнению с итеративными подходами.</li>
                </ul>
              `,
            },
          ],
        },
        {
          title: "Reducers",
          children: [
            {
              title: "Определение редьюсера",
              type: "text",
              description: `
                <p>Редьюсер — это чистая функция, которая принимает текущее состояние и действие, и возвращает новое состояние.</p>
              `,
            },
            {
              title: "Аргументы редьюсера",
              type: "list",
              description: `
                <p>Редьюсер принимает два аргумента:</p>
                <ul>
                  <li><strong>state</strong>: текущее состояние.</li>
                  <li><strong>action</strong>: объект, описывающий действие.</li>
                </ul>
              `,
            },
            {
              title: "Пример редьюсера",
              type: "code",
              description: `
                <p>Пример простого редьюсера для управления задачами:</p>
              `,
              code: `
const initialState = { todos: [] };

function todoReducer(state = initialState, action) {
  switch (action.type) {
    case 'ADD_TODO':
      return { ...state, todos: [...state.todos, action.payload] };
    case 'REMOVE_TODO':
      return {
        ...state,
        todos: state.todos.filter((_, index) => index !== action.payload),
      };
    default:
      return state;
  }
}
              `,
            },
            {
              title: "Использование редьюсера",
              type: "text",
              description: `
                <p>Редьюсеры комбинируются с помощью функции <code>combineReducers</code> для создания общего состояния в Redux.</p>
              `,
            },
            {
              title: "Пример с использованием useReducer",
              type: "code",
              description: `
                <p>Пример использования <code>useReducer</code> в React:</p>
              `,
              code: `
import React, { useReducer } from 'react';

const initialState = { count: 0 };

function reducer(state, action) {
  switch (action.type) {
    case 'increment':
      return { count: state.count + 1 };
    case 'decrement':
      return { count: state.count - 1 };
    default:
      throw new Error();
  }
}

function Counter() {
  const [state, dispatch] = useReducer(reducer, initialState);

  return (
    <>
      Count: {state.count}
      <button onClick={() => dispatch({ type: 'increment' })}>+</button>
      <button onClick={() => dispatch({ type: 'decrement' })}>-</button>
    </>
  );
}
              `,
            },
            {
              title: "Заключение",
              type: "text",
              description: `
                <p>Редьюсеры обеспечивают предсказуемое и централизованное управление состоянием в приложениях.</p>
              `,
            },
          ],
        },
        {
          title: "Switch",
          children: [
            {
              title: "Использование конструкции switch и где это нужно",
              type: "code",
              description: `
              <p>Конструкция switch позволяет выполнять различные действия на основе значения выражения.</p>
              <ul>
                <li>Мы можем использовать switch вместо многочисленных if-else, когда нужно проверить одно значение на несколько возможных вариантов.</li>
                <li>Это делает код более читаемым и поддерживаемым.</li>
              </ul>
              <p>Вот несколько примеров использования switch:</p>
              `,
              code: `
// Пример 1: Определение дня недели
const day = 3;
let dayName;

switch (day) {
  case 1:
  dayName = 'Понедельник';
  break;
  case 2:
  dayName = 'Вторник';
  break;
  case 3:
  dayName = 'Среда';
  break;
  case 4:
  dayName = 'Четверг';
  break;
  case 5:
  dayName = 'Пятница';
  break;
  case 6:
  dayName = 'Суббота';
  break;
  case 7:
  dayName = 'Воскресенье';
  break;
  default:
  dayName = 'Некорректный день';
}

console.log(dayName); // "Среда"


// Пример 2: Использование switch с выражением
const fruit = 'яблоко';
let color;

switch (fruit) {
  case 'банан':
  color = 'желтый';
  break;
  case 'яблоко':
  color = 'красный';
  break;
  case 'виноград':
  color = 'зеленый';
  break;
  default:
  color = 'неизвестный цвет';
}

console.log(color); // "красный"


// Пример 3: Объединение случаев
const grade = 'B';
let message;

switch (grade) {
  case 'A':
  case 'B':
  message = 'Отлично!';
  break;
  case 'C':
  message = 'Хорошо!';
  break;
  case 'D':
  message = 'Удовлетворительно!';
  break;
  case 'F':
  message = 'Неп satisfactoriously!';
  break;
  default:
  message = 'Некорректная оценка';
}

console.log(message); // "Отлично!"
              `,
            },
          ],
        },
        {
          title: "Sort functions",
          children: [
            {
              title: "Сортировка пузырьком",
              type: "code",
              description: `
                <p>Алгоритм сортировки пузырьком сравнивает пары соседних элементов и меняет их местами, если порядок неправильный.</p>
                <p>Задача: Реализовать сортировку массива с использованием алгоритма пузырька.</p>
              `,
              code: `
function bubbleSort(arr) {
  const n = arr.length;
  let swapped;
  do {
    swapped = false;
    for (let i = 0; i < n - 1; i++) {
    if (arr[i] > arr[i + 1]) {
      [arr[i], arr[i + 1]] = [arr[i + 1], arr[i]]; // обмен элементов
      swapped = true;
      }
    }
  } while (swapped);
    return arr;
}
              `,
            },
          ]
        },
        {
          title: "Search function",
          children: [

          ]
        },
        {
          title: "Strict comparison",
          children: [
            {
              title: "Использование строгого сравнения в JavaScript",
              type: "code",
              description: `
                <p>В JavaScript есть два типа сравнения: нестрогое (==) и строгое (===).</p>
                <ul>
                  <li><strong>Нестрогое сравнение (==)</strong>: Приводит операнды к одному типу перед сравнением.</li>
                  <li><strong>Строгое сравнение (===)</strong>: Сравнивает как значение, так и тип данных.</li>
                </ul>
                <p>Вот примеры использования строгого сравнения:</p>
              `,
              code: `
// Пример нестрогого сравнения
console.log(5 == '5'); // true
console.log(null == undefined); // true

// Пример строгого сравнения
console.log(5 === '5'); // false
console.log(null === undefined); // false

// Строгое сравнение с разными типами
console.log(1 === 1); // true
console.log(true === 1); // false
              `,
            },
          ],
        },
        {
          title: "Scope",
          children: [
            {
              title: "1. Определение Scope",
              type: "text",
              description: `
                <p>Scope (область видимости) в JavaScript определяет, где переменные, функции и объекты доступны для использования в коде.</p>
              `,
            },
            {
              title: "2. Типы области видимости",
              type: "text",
              description: `
                <p>В JavaScript существуют два основных типа области видимости:</p>
                <ul>
                  <li><strong>Глобальная область видимости:</strong> Переменные, объявленные вне любой функции, доступны везде в коде.</li>
                  <li><strong>Локальная область видимости:</strong> Переменные, объявленные внутри функции, доступны только внутри этой функции.</li>
                </ul>
              `,
            },
            {
              title: "3. Области видимости с использованием let и const",
              type: "text",
              description: `
                <p>Переменные, объявленные с помощью <code>let</code> и <code>const</code>, имеют блочную область видимости, что означает, что они доступны только внутри блока кода (например, внутри фигурных скобок).</p>
              `,
            },
            {
              title: "4. Пример глобальной области видимости",
              type: "code",
              description: `
                <p>Пример глобальной области видимости:</p>
              `,
              code: `
var globalVar = "I'm global!";

function testGlobal() {
  console.log(globalVar); // Доступно
}
testGlobal();
              `
            },
            {
              title: "5. Пример локальной области видимости",
              type: "code",
              description: `
                <p>Пример локальной области видимости:</p>
              `,
              code: `
function testLocal() {
  var localVar = "I'm local!";
  console.log(localVar); // Доступно
}
testLocal();
console.log(localVar); // ReferenceError: localVar is not defined
              `
            },
            {
              title: "6. Блочная область видимости",
              type: "code",
              description: `
                <p>Пример блочной области видимости с let:</p>
              `,
              code: `
{
  let blockVar = "I'm in a block!";
  console.log(blockVar); // Доступно
}
console.log(blockVar); // ReferenceError: blockVar is not defined
              `
            },
            {
              title: "7. Иерархия области видимости",
              type: "text",
              description: `
                <p>JavaScript использует иерархию области видимости, что означает, что внутренняя функция имеет доступ к переменным своей внешней функции.</p>
              `,
            },
            {
              title: "8. Пример иерархии области видимости",
              type: "code",
              description: `
                <p>Пример иерархии области видимости:</p>
              `,
              code: `
function outerFunction() {
  var outerVar = "I'm outside!";
  
  function innerFunction() {
    console.log(outerVar); // Доступно
  }
  innerFunction();
}
outerFunction();
              `
            },
          ],
        },
        {
          title: "Temporal Dead Zone / Временная мертвая зона",
          children: [
            {
              title: "1. Определение Temporal Dead Zone",
              type: "text",
              description: `
                <p>Temporal Dead Zone (TDZ) - это область кода в JavaScript, где переменная не может быть доступна, даже если она была объявлена. Это происходит до момента, когда она инициализирована.</p>
                <p>TDZ применяется к переменным, объявленным с помощью <code>let</code> и <code>const</code>.</p>
              `,
            },
            {
              title: "2. Как работает Temporal Dead Zone?",
              type: "text",
              description: `
                <p>Когда вы пытаетесь получить доступ к переменной, объявленной с помощью <code>let</code> или <code>const</code>, до её инициализации, JavaScript выбросит ошибку ReferenceError.</p>
              `,
            },
            {
              title: "3. Пример Temporal Dead Zone",
              type: "code",
              description: `
                <p>Пример, демонстрирующий TDZ:</p>
              `,
              code: `
console.log(a); // ReferenceError: Cannot access 'a' before initialization
let a = 5;
              `
            },
            {
              title: "4. Важность понимания TDZ",
              type: "text",
              description: `
                <p>Понимание TDZ важно для предотвращения ошибок в коде:</p>
                <ul>
                  <li>Помогает избежать неожиданных ошибок при доступе к переменным.</li>
                  <li>Способствует лучшему пониманию области видимости и инициализации переменных.</li>
                </ul>
              `,
            },
            {
              title: "5. Сравнение с var",
              type: "text",
              description: `
                <p>В отличие от <code>let</code> и <code>const</code>, переменные, объявленные с помощью <code>var</code>, имеют всплытие (hoisting) и могут быть доступны до их объявления, хотя инициализированы они будут только в момент выполнения кода:</p>
              `,
            },
            {
              title: "6. Пример с var",
              type: "code",
              description: `
                <p>Пример, показывающий поведение <code>var</code>:</p>
              `,
              code: `
console.log(b); // undefined
var b = 10;
              `
            },
          ],
        },
        {
          title: "Ternary operator and logical operators",
          children: [
            {
              title:
                "Использование тернарного оператора и логических операторов",
              type: "code",
              description: `
                <p>В JavaScript есть несколько удобных операторов, которые помогают упростить код и избавиться от лишних проверок.</p>
                <ul>
                  <li><strong>Тернарный оператор</strong>: Сокращенная форма if-else, позволяет записать условную логику в одной строке.</li>
                  <li><strong>Оператор нулевого объединения (??)</strong>: Позволяет вернуть правое значение, если левое значение равно null или undefined.</li>
                  <li><strong>Необязательное связывание (?.)</strong>: Позволяет безопасно получать доступ к вложенным свойствам объектов без необходимости проверки каждой промежуточной ссылки.</li>
                </ul>
              `,
              code: `
// Пример тернарного оператора
const age = 18;
const canVote = (age >= 18) ? "Да" : "Нет";
console.log(canVote); // "Да"

// Пример оператора нулевого объединения
const userInput = null;
const defaultValue = userInput ?? "Значение по умолчанию";
console.log(defaultValue); // "Значение по умолчанию"

// Пример необязательного связывания
const user = {
  profile: {
    name: "Alice",
    age: 30,
  },
};
const userCity = user.profile?.city ?? "Город не указан";
console.log(userCity); // "Город не указан" (поскольку city не существует)

// Пример логического И (&&) и ИЛИ (||)
const isAuthenticated = true;
const userRole = isAuthenticated && "admin";
// вернёт "admin", если isAuthenticated true
const fallback = userRole || "guest"; // вернёт "guest", если userRole falsy
              `,
            },
          ],
        },
        {
          title: "typeof operator ",
          children: [
            {
              title: "Описание оператора typeof",
              type: "code",
              description: `
                <p><strong>typeof</strong>: Это оператор в JavaScript, который используется для определения типа переменной или выражения. Он возвращает строку, описывающую тип аргумента.</p>
                <ul>
                  <li>Примеры типов: "undefined", "boolean", "number", "string", "object", "function", "symbol".</li>
                </ul>
              `,
              code: `
// Примеры использования оператора typeof
console.log(typeof undefined); // "undefined"
console.log(typeof null);      // "object" (это известная ошибка в JavaScript)
console.log(typeof 42);        // "number"
console.log(typeof 'hello');   // "string"
console.log(typeof {});         // "object"
console.log(typeof [];          // "object"
console.log(typeof function(){}); // "function"
              `,
            },
            {
              title: "Практическое применение",
              type: "code",
              description: `
                <p>Оператор typeof часто используется для проверки типов переменных перед выполнением операций:</p>
              `,
              code: `
let value;

if (typeof value === 'undefined') {
  console.log('Переменная value не инициализирована.');
}

value = 10;

if (typeof value === 'number') {
  console.log('value является числом.');
}
              `,
            },
            {
              title: "Ограничения оператора typeof",
              type: "code",
              description: `
                <p>Некоторые особенности и ограничения:</p>
                <ul>
                  <li>Для объектов и массивов оператор возвращает "object".</li>
                  <li>Для null он также возвращает "object", что является известной особенностью JavaScript.</li>
                  <li>Для функций возвращает "function", но это подтип объекта.</li>
                </ul>
              `,
              code: `
console.log(typeof null);       // "object"
console.log(typeof [1, 2, 3]);  // "object"
console.log(typeof {};           // "object"
console.log(typeof (() => {})); // "function"
              `,
            },
            {
              title: "Вывод",
              type: "code",
              description: `
                <p>Оператор typeof является полезным инструментом в JavaScript для проверки типов данных и может помочь избежать ошибок при работе с переменными.</p>
              `,
              code: `
let value = 'test';
console.log(typeof value); // "string"
              `,
            },
          ],
        },
        {
          title: "Variables: let, const, var and hoisting / Переменные: let, const, var и хоистинг",
          children: [
            {
              title: "Область видимости переменных",
              type: "code",
              description: `
                <p>В JavaScript есть три типа областей видимости: глобальная, функция и блок.</p>
                <ul>
                  <li><strong>Глобальная</strong>: Переменные, доступные во всем скрипте.</li>
                  <li><strong>Функция</strong>: Переменные, доступные только внутри функции.</li>
                  <li><strong>Блок</strong>: Переменные, объявленные внутри блока (например, внутри 'if', 'for', и т. д.).</li>
                </ul>
              `,
              code: `
let globalVar = 'I'm global';

function testScope() {
  let functionVar = 'I'm local to function';
  if (true) {
    let blockVar = 'I exist only in this block';
    console.log(blockVar); // доступен здесь
  }
  console.log(functionVar); // доступен здесь
  // console.log(blockVar); // ошибка: blockVar не доступен здесь
}
console.log(globalVar); // доступен здесь
              `,
            },
            {
              title: "Описание переменных",
              type: "code",
              description: `
                <p><strong>var</strong>: Используется для объявления переменных. Переменные, объявленные с помощью var, имеют функциональную или глобальную область видимости и могут быть переопределены. Они также подвержены механизму поднятия (hoisting).</p>
                <p><strong>let</strong>: Вводится в ES6 (ECMAScript 2015). Используется для объявления переменных с блочной областью видимости. Переменные, объявленные с помощью let, не могут быть переопределены в пределах одной и той же области видимости. Также подвержены подъеманию, но не инициализируются до фактической строки кода.</p>
                <p><strong>const</strong>: Также введена в ES6. Используется для объявления констант, значение которых не может быть переопределено. Как и let, имеет блочную область видимости.</p>
              `,
              code: `
var a = 'Hello';
console.log(a); // 'Hello'

let b = 'World';
console.log(b); // 'World'

const c = '!';
console.log(c); // '!'
              `,
            },
            {
              title: "Сравнение области видимости",
              type: "code",
              description: `
                <p>Область видимости переменных var, let и const:</p>
                <ul>
                  <li><strong>var</strong>: Функциональная или глобальная область видимости.</li>
                  <li><strong>let</strong> и <strong>const</strong>: Блочная область видимости.</li>
                </ul>
              `,
              code: `
if (true) {
  var x = 10;
  let y = 20;
  const z = 30;
}

console.log(x); // 10
console.log(y); // ReferenceError: y is not defined
console.log(z); // ReferenceError: z is not defined
              `,
            },
            {
              title: "Hoisting / Подъем переменных",
              type: "code",
              description: `
                <p>Все три типа переменных поднимаются, но их инициализация происходит на разных стадиях:</p>
              `,
              code: `
console.log(aVar); // undefined (подъем, но не инициализация)
var aVar = 'test';

// console.log(aLet); // ReferenceError: Cannot access 'aLet' before initialization
let aLet = 'test';

// console.log(aConst); // ReferenceError: Cannot access 'aConst' before initialization
const aConst = 'test';
              `,
            },
            {
              title: "Использование",
              type: "code",
              description: `
                <p>Рекомендуется использовать let и const вместо var, чтобы избежать неожиданных ошибок и путаницы:</p>
              `,
              code: `
let name = 'John';
const age = 30;

name = 'Doe'; // корректно, значение переменной может меняться
// age = 31; // TypeError: Assignment to constant variable. (ошибка)
              `,
            },
            {
              title: "Вывод",
              type: "code",
              description: `
                <p>Необходимо использовать let и const в современных приложениях, чтобы избежать проблем с областью видимости, поднятием и переопределением переменных.</p>
              `,
              code: `
if (true) {
  let message = "Hello, block!";
  console.log(message); // "Hello, block!"
}
// console.log(message); // ReferenceError: message is not defined
              `,
            },
          ],
        },
        {
          title: "Variable declarations / Объявления переменных",
          children: [
            {
              title: "1. Использование var",
              type: "code",
              description: `
                <p><strong>var</strong>: Объявляет переменную с функциональной или глобальной областью видимости.</p>
                <ul>
                  <li>Переменные, объявленные с помощью <code>var</code>, могут быть переопределены.</li>
                  <li>Подвержены механизму поднятия (hoisting).</li>
                </ul>
              `,
              code: `
var name = 'Alice';
console.log(name); // 'Alice'
var name = 'Bob'; // переопределение
console.log(name); // 'Bob'
              `,
            },
            {
              title: "2. Использование let",
              type: "code",
              description: `
                <p><strong>let</strong>: Объявляет переменную с блочной областью видимости.</p>
                <ul>
                  <li>Переменные, объявленные с помощью <code>let</code>, не могут быть переопределены в пределах одной области видимости.</li>
                  <li>Также подвержены поднятию, но не инициализируются до фактической строки кода.</li>
                </ul>
              `,
              code: `
let age = 25;
console.log(age); // 25
// let age = 30; // ошибка: Identifier 'age' has already been declared
              `,
            },
            {
              title: "3. Использование const",
              type: "code",
              description: `
                <p><strong>const</strong>: Объявляет константу, значение которой не может быть переопределено.</p>
                <ul>
                  <li>Имеет блочную область видимости.</li>
                  <li>Объявленные с помощью <code>const</code> переменные должны быть инициализированы при объявлении.</li>
                </ul>
              `,
              code: `
const pi = 3.14;
console.log(pi); // 3.14
// pi = 3.14159; // ошибка: Assignment to constant variable.
              `,
            },
            {
              title: "4. Групповое объявление",
              type: "code",
              description: `
                <p>Можно объявить несколько переменных в одной строке:</p>
              `,
              code: `
let x = 10, y = 20, z = 30;
console.log(x, y, z); // 10 20 30
              `,
            },
          ],
        },
        {
          title: "Tasks",
          children: [
            {
              title: "Task 1",
              children: [
                {
                  title: "Count Odd Numbers below n",
                  type: 'code',
                  description: `
                    Given a number n, return the number of positive odd numbers below n, EASY!
    
                    Examples (Input -> Output)
                    7  -> 3 (because odd numbers below 7 are [1, 3, 5])
                    15 -> 7 (because odd numbers below 15 are [1, 3, 5, 7, 9, 11, 13])
                    Expect large Inputs!
                  `,
                  code: `
function oddCount(n){
  if (n <= 0){
    return 0
  }
  if (n % 2 === 0){
    return n / 2
  } else {
    return (n - 1) / 2
  }
}

// or

function oddCount(n){
  return n % 2 === 0 ? n / 2 : (n - 1) / 2 
}

// or 

const oddCount = n => n % 2 === 0 ? n / 2 : (n - 1) / 2
                  `,
                }
              ]
            },
            {
              title: "Task 2",
              children: [
                {
                  title: "Pole Vault Starting Marks",
                  type: 'code',
                  description: `
                  For a pole vaulter, it is very important to begin the approach run at the best possible starting mark. This is affected by numerous factors and requires fine-tuning in practice. But there is a guideline that will help a beginning vaulter start at approximately the right location for the so-called "three-step approach," based on the vaulter's body height.
                  This guideline was taught to me in feet and inches, but due to the international nature of Codewars, I am creating this kata to use metric units instead.
                  You are given the following two guidelines to begin with: (1) A vaulter with a height of 1.52 meters should start at 9.45 meters on the runway. (2) A vaulter with a height of 1.83 meters should start at 10.67 meters on the runway.
                  You will receive a vaulter's height in meters (which will always lie in a range between a minimum of 1.22 meters and a maximum of 2.13 meters). Your job is to return the best starting mark in meters, rounded to two decimal places.
                  Hint: Based on the two guidelines given above, you will want to account for the change in starting mark per change in body height. This involves a linear relationship. (If you're not clear on that, search online for "linear equation.") But there is also a constant offset involved. If you can determine the rate of change described above, you should be able to determine that constant offset.
                  `,
                  code: `
// Remember: Body height of 1.52 m --> starting mark: 9.45 m
//           Body height of 1.83 m --> starting mark: 10.67 m
// All other starting marks are based on these guidelines!

function startingMark(bodyHeight){
  const slope = (10.67 - 9.45) / (1.83 - 1.52)
  const freeMember = 9.45 - (slope * 1.52)
  const result = slope * bodyHeight + freeMember
  return parseFloat(result.toFixed(2))
}

// or

const startingMark = bodyHeight => {
  const slope = (10.67 - 9.45)/(1.83 - 1.52);
  const freeMember = 9.45 - (slope * 1.52);
  const x = slope * bodyHeight + freeMember;
  return parseFloat(x.toFixed(2)) 
}

// or 

function startingMark(bodyHeight) {
  let a = {x: 1.52, y: 9.45},
      b = {x: 1.83, y: 10.67},
      slope = (b.y - a.y) / (b.x - a.x);
  return Math.round((slope * bodyHeight + b.y - slope * b.x) * 100) / 100;
}
                  `,
                }
              ]
            },
            {
              title: "Task 3",
              children: [
                {
                  title: "Playing with cubes II",
                  type: 'code',
                  description: `
                  Hey Codewarrior!
                  In the previous kata, you have implemented a Cube class, but now we need your help again! I'm talking about constructors. We don't have one. Let's code one (or more) such that one can instantiate an object via it, handling either no arguments or a single integer. 
                  Also we got a problem with negative values. Correct the code so negative values will be switched to positive ones!    
                  The constructor taking no arguments should assign 0 to Cube's Side property.
                  `,
                  code: `
// This Cube class needs help
// Implement the constructor so that it can take an integer for the side or no args
class Cube {
  constructor(side){
    this.side = (side !== undefined) ? Math.abs(side) : 0
  }
  getSide() {
    return this.side; 
  }
  setSide(n) {
    this.side = Math.abs(n);
  }
}

// or

class Cube {
  constructor(side){
    this.setSide(side)
  }
  getSide() {
    return this.side; 
  }
  setSide(n = 0) {
    this.side = Math.abs(n);
  }
}
                  `,
                }
              ]
            },
            {
              title: "Task 4",
              children: [
                {
                  title: "title",
                  type: 'code',
                  description: `
                    word
                  `,
                  code: `
                  // code 
                  `,
                }
              ]
            },
            {
              title: "Task 5",
              children: [
                {
                  title: "title",
                  type: 'code',
                  description: `
                    word
                  `,
                  code: `
                  // code 
                  `,
                }
              ]
            },
            {
              title: "Task 6",
              children: [
                {
                  title: "title",
                  type: 'code',
                  description: `
                    word
                  `,
                  code: `
                  // code 
                  `,
                }
              ]
            },
            {
              title: "Task 7",
              children: [
                {
                  title: "title",
                  type: 'code',
                  description: `
                    word
                  `,
                  code: `
                  // code 
                  `,
                }
              ]
            },
            {
              title: "Task 8",
              children: [
                {
                  title: "title",
                  type: 'code',
                  description: `
                    word
                  `,
                  code: `
                  // code 
                  `,
                }
              ]
            },
            {
              title: "Task 9",
              children: [
                {
                  title: "title",
                  type: 'code',
                  description: `
                    word
                  `,
                  code: `
                  // code 
                  `,
                }
              ]
            },
            {
              title: "Task 10",
              children: [
                {
                  title: "title",
                  type: 'code',
                  description: `
                    word
                  `,
                  code: `
                  // code 
                  `,
                }
              ]
            },
            {
              title: "Task 11",
              children: [
                {
                  title: "title",
                  type: 'code',
                  description: `
                    word
                  `,
                  code: `
                  // code 
                  `,
                }
              ]
            },
            {
              title: "Task 12",
              children: [
                {
                  title: "title",
                  type: 'code',
                  description: `
                    word
                  `,
                  code: `
                  // code 
                  `,
                }
              ]
            },
            {
              title: "Task 13",
              children: [
                {
                  title: "title",
                  type: 'code',
                  description: `
                    word
                  `,
                  code: `
                  // code 
                  `,
                }
              ]
            },
            {
              title: "Task 14",
              children: [
                {
                  title: "title",
                  type: 'code',
                  description: `
                    word
                  `,
                  code: `
                  // code 
                  `,
                }
              ]
            },
            {
              title: "Task 15",
              children: [
                {
                  title: "title",
                  type: 'code',
                  description: `
                    word
                  `,
                  code: `
                  // code 
                  `,
                }
              ]
            },
            {
              title: "Task 16",
              children: [
                {
                  title: "title",
                  type: 'code',
                  description: `
                    word
                  `,
                  code: `
                  // code 
                  `,
                }
              ]
            }
          ]
        }
      ],
    },
    {
      title: "React",
      children: [
        {
          title: "React JS",
          children: [
            {
              title: "Introduction to React JS",
              type: "link",
              url: "https://it-shpora.pp.ua/category/react/",
            },
            {
              title: "Advanced React JS",
              type: "link",
              url: "https://devdocs.io/react/",
            },
            {
              title: "Storybook",
              type: "link",
              url: "https://storybook.js.org/docs/writing-stories",
            },
            {
              title: "React JS Drag to Select",
              type: "link",
              url: "https://www.joshuawootonn.com/react-drag-to-select",
            },
          ],
        },
        {
          title: "React TS",
          children: [
            {
              title: "Introduction to React TypeScript",
              type: "link",
              url: "https://it-shpora.pp.ua/category/react-typescript/",
            },
            {
              title: "Advanced React Typescript",
              type: "link",
              url: "https://reactjs.org/docs/getting-started",
            },
          ],
        },
        {
          title: "React Native",
          children: [
            {
              title: "Introduction to React Native",
              type: "link",
              url: "https://it-shpora.pp.ua/category/react-native/",
            },
            {
              title: "Advanced React Native",
              type: "link",
              url: "https://reactnative.dev/",
            },
          ],
        },
      ],
    },
    {
      title: "Next.js",
      children: [
        {
          title: "Next.js Crash Course Tutorial",
          children: [
            {
              title: "#1 - Introduction & New Features",
              type: "video",
              url: "https://www.youtube.com/embed?v=TJQbDPGzm0Y&list=PL4cUxeGkcC9jZIVqmy_QhfQdi6mzQvJnT",
            },
            {
              title: "#2 - SSR & Server Components (theory)",
              type: "video",
              url: "https://www.youtube.com/embed?v=YEG2_fSJswc&list=PL4cUxeGkcC9jZIVqmy_QhfQdi6mzQvJnT&index=2",
            },
            {
              title: "#3 - Pages & Routes",
              type: "video",
              url: "https://www.youtube.com/embed?v=vwg4Wrk-kWE&list=PL4cUxeGkcC9jZIVqmy_QhfQdi6mzQvJnT&index=3",
            },
            {
              title: "#4 - Layouts & Links",
              type: "video",
              url: "https://www.youtube.com/embed?v=R7A5vBDfZ18&list=PL4cUxeGkcC9jZIVqmy_QhfQdi6mzQvJnT&index=4",
            },
            {
              title: "#5 - Styles, Fonts & Images",
              type: "video",
              url: "https://www.youtube.com/embed?v=oWUQQD97Rz0&list=PL4cUxeGkcC9jZIVqmy_QhfQdi6mzQvJnT&index=5",
            },
            {
              title: "#6 - Fetching & Revalidating Data",
              type: "video",
              url: "https://www.youtube.com/embed?v=PAXWRgEo7Ns&list=PL4cUxeGkcC9jZIVqmy_QhfQdi6mzQvJnT&index=6",
            },
            {
              title: "#7 - Dynamic Segments (Params)",
              type: "video",
              url: "https://www.youtube.com/embed?v=ZwajQ9ywgIU&list=PL4cUxeGkcC9jZIVqmy_QhfQdi6mzQvJnT&index=7",
            },
            {
              title: "#8 - Static Rendering",
              type: "video",
              url: "https://www.youtube.com/embed?v=ihmyC4Ei2zY&list=PL4cUxeGkcC9jZIVqmy_QhfQdi6mzQvJnT&index=8",
            },
            {
              title: "#9 - Custom 404 Page",
              type: "video",
              url: "https://www.youtube.com/embed?v=PbFH_VE1Iks&list=PL4cUxeGkcC9jZIVqmy_QhfQdi6mzQvJnT&index=9",
            },
            {
              title: "#10 - Loading UI & Suspense",
              type: "video",
              url: "https://www.youtube.com/embed?v=Lzml9L3f4IM&list=PL4cUxeGkcC9jZIVqmy_QhfQdi6mzQvJnT&index=10",
            },
            {
              title: "#11 - Client Form Component",
              type: "video",
              url: "https://www.youtube.com/embed?v=nSfu7sHPE9M&list=PL4cUxeGkcC9jZIVqmy_QhfQdi6mzQvJnT&index=11",
            },
            {
              title: "#12 - Building the App",
              type: "video",
              url: "https://www.youtube.com/embed?v=Yi_zS8jSln8&list=PL4cUxeGkcC9jZIVqmy_QhfQdi6mzQvJnT&index=12",
            },
          ],
        },
        {
          title: "Routing",
          children: [
            {
              title: "Learn more about routing",
              description:
                "The skeleton of every application is routing. This page will introduce you to the fundamental concepts of routing for the web and how to handle routing in Next.js.",
              type: "link",
              url: "https://nextjs.org/docs/app/building-your-application/routing#terminology",
            },
          ],
        },
      ],
    },
    {
      title: "Patterns, principles, methodologies",
      children: [
        {
          title: "Clean code",
          children: [
            {
              title: "Определение",
              type: "list",
              description: `
                <p>Чистый код — это подход к написанию программного обеспечения, который акцентирует внимание на его читаемости, понятности и простоте. Он способствует более легкому пониманию и сопровождению кода.</p>
              `,
            },
            {
              title: "Основные принципы чистого кода",
              type: "list",
              description: `
                <p>Некоторые ключевые принципы чистого кода:</p>
                <ul>
                  <li><strong>Читаемость</strong>: Код должен быть легким для чтения и понимания.</li>
                  <li><strong>Понятность</strong>: Названия переменных, функций и классов должны быть ясными и описательными.</li>
                  <li><strong>Структурированность</strong>: Код должен быть организован логически, с четким разделением на модули и функции.</li>
                  <li><strong>Минимизация дублирования</strong>: Избегайте повторения кода, используя функции и модули.</li>
                  <li><strong>Тестируемость</strong>: Код должен быть легко тестируемым, что облегчает обнаружение ошибок.</li>
                </ul>
              `,
            },
            {
              title: "Примеры хорошего кода",
              type: "code",
              description: `
                <p>Пример хорошего кода с понятными названиями:</p>
              `,
              code: `
function calculateArea(radius) {
  return Math.PI * radius * radius;
}
              `,
            },
            {
              title: "Примеры плохого кода",
              type: "code",
              description: `
                <p>Пример плохого кода с непонятными названиями:</p>
              `,
              code: `
function c(r) {
  return 3.14 * r * r;
}
              `,
            },
            {
              title: "Рекомендации по написанию чистого кода",
              type: "list",
              description: `
                <p>Некоторые рекомендации:</p>
                <ul>
                  <li><strong>Используйте описательные названия</strong>: Названия должны отражать назначение переменной или функции.</li>
                  <li><strong>Разделяйте код на функции</strong>: Каждая функция должна выполнять одну задачу.</li>
                  <li><strong>Пишите комментарии</strong>: Используйте комментарии для объяснения сложных частей кода, но не переусердствуйте.</li>
                  <li><strong>Следуйте стандартам кодирования</strong>: Придерживайтесь общепринятых стилей и стандартов в вашей команде.</li>
                  <li><strong>Регулярно рефакторите код</strong>: Улучшайте и оптимизируйте код по мере его развития.</li>
                </ul>
              `,
            },
            {
              title: "Преимущества чистого кода",
              type: "list",
              description: `
                <p>Преимущества написания чистого кода:</p>
                <ul>
                  <li><strong>Упрощенное сопровождение</strong>: Более легкое понимание и изменение кода.</li>
                  <li><strong>Меньше ошибок</strong>: Чистый код снижает вероятность ошибок и багов.</li>
                  <li><strong>Увеличение производительности команды</strong>: Читаемый код ускоряет процесс разработки и тестирования.</li>
                </ul>
              `,
            },
          ],
        },
        {
          title: "Continuous Integration vs Continuous Deployment vs Delivery Pipeline",
          children: [
            {
              title: "Определение",
              type: "list",
              description: `
                <p>Continuous Integration (CI), Continuous Deployment (CD) и Delivery Pipeline — это практики разработки программного обеспечения, которые помогают обеспечить быструю и надежную поставку кода в рабочую среду.</p>
              `,
            },
            {
              title: "Continuous Integration (CI)",
              type: "list",
              description: `
                <p>CI — это практика, при которой разработчики регулярно интегрируют свои изменения в общий код. Каждый интегрированный код проходит автоматические тесты и сборку, что позволяет обнаруживать ошибки на ранних стадиях.</p>
                <ul>
                  <li><strong>Цели CI:</strong> Устранение проблем, связанных с интеграцией, и обеспечение высокой качества кода.</li>
                  <li><strong>Инструменты:</strong> Jenkins, Travis CI, CircleCI и др.</li>
                </ul>
              `,
            },
            {
              title: "Continuous Deployment (CD)",
              type: "list",
              description: `
                <p>CD — это практика, при которой изменения кода автоматически разворачиваются в рабочую среду после успешного прохождения всех тестов. Это позволяет командам быстрее реагировать на изменения и выпускать новые функции.</p>
                <ul>
                  <li><strong>Цели CD:</strong> Упрощение процесса развертывания и минимизация времени между написанием кода и его доступностью для пользователей.</li>
                  <li><strong>Инструменты:</strong> Docker, Kubernetes, Spinnaker и др.</li>
                </ul>
              `,
            },
            {
              title: "Delivery Pipeline",
              type: "list",
              description: `
                <p>Delivery Pipeline — это автоматизированный процесс, который включает в себя все этапы от написания кода до его развертывания в рабочую среду. Он включает CI и CD и обеспечивает полный контроль над процессом доставки программного обеспечения.</p>
                <ul>
                  <li><strong>Этапы:</strong> Кодирование, тестирование, сборка, развертывание и мониторинг.</li>
                  <li><strong>Преимущества:</strong> Позволяет командам ускорить процесс разработки и повысить качество выпускаемого ПО.</li>
                </ul>
              `,
            },
            {
              title: "Сравнение",
              type: "list",
              description: `
                <p>Сравнение CI, CD и Delivery Pipeline:</p>
                <ul>
                  <li><strong>CI</strong>: Фокус на автоматизации интеграции и тестирования кода.</li>
                  <li><strong>CD</strong>: Фокус на автоматизации развертывания кода в рабочую среду.</li>
                  <li><strong>Delivery Pipeline</strong>: Полный процесс, охватывающий как CI, так и CD, с акцентом на управление всей цепочкой поставки.</li>
                </ul>
              `,
            },
          ],
        },
        {
          title: "DRY",
          children: [
            {
              title: "",
              type: "list",
              description:
                "<strong>DRY (Don't Repeat Yourself)</strong> - Принцип, согласно которому информация и логика не должны повторяться в коде, чтобы уменьшить дублирование и облегчить поддержку.",
            },
          ]
        },
        {
          title: "Design patterns / Шаблоны проектирования",
          children: [
            {
              title: "Определение",
              type: "list",
              description: `
                <p>Шаблоны проектирования — это общепринятые решения для часто встречающихся проблем в проектировании программного обеспечения. Они помогают разработчикам создавать более гибкие, поддерживаемые и устойчивые к изменениям системы.</p>
              `,
            },
            {
              title: "Типы шаблонов проектирования",
              type: "list",
              description: `
                <p>Существует три основных типа шаблонов проектирования:</p>
                <ul>
                  <li><strong>Шаблоны создания (Creational Patterns)</strong>: Определяют способ создания объектов, обеспечивая гибкость и контроль.</li>
                  <li><strong>Шаблоны структурирования (Structural Patterns)</strong>: Определяют, как объекты и классы могут комбинироваться для формирования более крупных структур.</li>
                  <li><strong>Шаблоны поведения (Behavioral Patterns)</strong>: Определяют взаимодействие между объектами и упрощают управление их поведением.</li>
                </ul>
              `,
            },
            {
              title: "Примеры шаблонов",
              type: "list",
              description: `
                <p>Некоторые популярные шаблоны проектирования:</p>
                <ul>
                  <li><strong>Singleton</strong>: Гарантирует, что класс имеет только один экземпляр и предоставляет глобальную точку доступа к нему.</li>
                  <li><strong>Factory Method</strong>: Определяет интерфейс для создания объектов, но позволяет подклассам изменять тип создаваемого объекта.</li>
                  <li><strong>Observer</strong>: Определяет зависимость "один-ко-многим" между объектами, так что при изменении состояния одного объекта все зависимые обновляются автоматически.</li>
                  <li><strong>Decorator</strong>: Позволяет динамически добавлять новое поведение или функциональность к объектам, оборачивая их в другие объекты.</li>
                </ul>
              `,
            },
            {
              title: "Преимущества использования шаблонов проектирования",
              type: "list",
              description: `
                <p>Преимущества использования шаблонов проектирования:</p>
                <ul>
                  <li><strong>Переиспользование кода</strong>: Шаблоны помогают избежать дублирования кода.</li>
                  <li><strong>Улучшение читаемости</strong>: Код становится более понятным для других разработчиков.</li>
                  <li><strong>Упрощение изменений</strong>: Шаблоны делают систему более гибкой и устойчивой к изменениям.</li>
                </ul>
              `,
            },
            {
              title: "Рекомендации по применению",
              type: "list",
              description: `
                <p>Некоторые рекомендации по применению шаблонов проектирования:</p>
                <ul>
                  <li><strong>Не применяйте шаблоны без необходимости</strong>: Используйте их только тогда, когда это действительно оправдано.</li>
                  <li><strong>Изучайте шаблоны</strong>: Понимание шаблонов поможет вам лучше применять их на практике.</li>
                  <li><strong>Комбинируйте шаблоны</strong>: Иногда полезно комбинировать несколько шаблонов для достижения лучших результатов.</li>
                </ul>
              `,
            },
          ],
        },
        {
          title: "Делегирование событий",
          children: [
            {
              title: "1. Что такое делегирование событий?",
              type: "text",
              description: `
                <p>Делегирование событий - это паттерн, при котором обработчик события добавляется к родительскому элементу вместо каждого дочернего элемента.</p>
                <p>Это позволяет обрабатывать события, возникающие на дочерних элементах, более эффективно.</p>
              `,
            },
            {
              title: "2. Преимущества делегирования событий",
              type: "text",
              description: `
                <ul>
                  <li><strong>Упрощение кода:</strong> Меньше обработчиков для управления.</li>
                  <li><strong>Повышение производительности:</strong> Уменьшение количества обработчиков, особенно при динамическом добавлении элементов.</li>
                  <li><strong>Легкость в управлении:</strong> Изменение структуры DOM не требует изменения обработчиков.</li>
                </ul>
              `,
            },
            {
              title: "3. Пример делегирования событий",
              type: "code",
              description: `
                <p>Пример делегирования событий на списке элементов:</p>
              `,
              code: `
        const list = document.getElementById('myList');
        
        list.addEventListener('click', function(event) {
          if (event.target.tagName === 'LI') {
            console.log('Элемент списка нажат:', event.target.textContent);
          }
        });
              `
            },
            {
              title: "4. Когда использовать делегирование событий?",
              type: "text",
              description: `
                <p>Делегирование событий полезно, когда:</p>
                <ul>
                  <li>Необходимо обрабатывать события на множестве дочерних элементов.</li>
                  <li>Элементы могут динамически добавляться или удаляться из DOM.</li>
                  <li>Хотите уменьшить количество обработчиков событий для повышения производительности.</li>
                </ul>
              `,
            },
          ],
        },
        {
          title: "Functional programming",
          children: [
            {
              title: "Определение",
              type: "text",
              description: `
                <p>Функциональное программирование — это парадигма программирования, в которой основное внимание уделяется использованию функций и избеганию изменения состояния и данных.</p>
              `,
            },
            {
              title: "Основные концепции",
              type: "list",
              description: `
                <p>Ключевые концепции функционального программирования:</p>
                <ul>
                  <li><strong>Чистые функции</strong>: функции, которые всегда возвращают один и тот же результат для одинаковых входных данных и не имеют побочных эффектов.</li>
                  <li><strong>Иммутабельность</strong>: состояние не изменяется, вместо этого создаются новые значения.</li>
                  <li><strong>Функции высшего порядка</strong>: функции, которые принимают другие функции в качестве аргументов или возвращают функции.</li>
                  <li><strong>Лямбда-функции</strong>: анонимные функции, которые могут быть определены и использованы непосредственно в коде.</li>
                </ul>
              `,
            },
            {
              title: "Преимущества",
              type: "text",
              description: `
                <p>Функциональное программирование предлагает множество преимуществ, включая:</p>
                <ul>
                  <li>Упрощение отладки и тестирования.</li>
                  <li>Лучшее управление состоянием.</li>
                  <li>Улучшение читаемости и поддержки кода.</li>
                </ul>
              `,
            },
            {
              title: "Пример чистой функции",
              type: "code",
              description: `
                <p>Пример чистой функции, которая вычисляет сумму двух чисел:</p>
              `,
              code: `
function add(a, b) {
  return a + b;
}
              `,
            },
            {
              title: "Функции высшего порядка",
              type: "code",
              description: `
                <p>Пример функции высшего порядка, которая принимает другую функцию в качестве аргумента:</p>
              `,
              code: `
function applyFunction(fn, value) {
  return fn(value);
}

function double(x) {
  return x * 2;
}

const result = applyFunction(double, 5); // 10
              `,
            },
            {
              title: "Заключение",
              type: "text",
              description: `
                <p>Функциональное программирование способствует созданию более предсказуемого и поддерживаемого кода, что делает его популярным выбором для разработки современного программного обеспечения.</p>
              `,
            },
          ],
        },
        {
          title: "Imperative and Declarative Programming",
          children: [
            {
              title: "Определение императивного программирования",
              type: "text",
              description: `
                <p>Императивное программирование — это парадигма, в которой разработчик указывает, как именно должна быть выполнена задача, описывая последовательность шагов, необходимых для достижения результата.</p>
              `,
            },
            {
              title: "Примеры императивного программирования",
              type: "code",
              description: `
                <p>Пример императивного подхода на JavaScript:</p>
              `,
              code: `
let sum = 0;
for (let i = 1; i <= 5; i++) {
  sum += i;
}
console.log(sum); // 15
              `,
            },
            {
              title: "Определение декларативного программирования",
              type: "text",
              description: `
                <p>Декларативное программирование — это парадигма, в которой разработчик описывает, что нужно сделать, а не как это сделать. Основное внимание уделяется результату, а не этапам выполнения.</p>
              `,
            },
            {
              title: "Примеры декларативного программирования",
              type: "code",
              description: `
                <p>Пример декларативного подхода на JavaScript:</p>
              `,
              code: `
const sum = [1, 2, 3, 4, 5].reduce((acc, curr) => acc + curr, 0);
console.log(sum); // 15
              `,
            },
            {
              title: "Сравнение подходов",
              type: "text",
              description: `
                <p>Императивное программирование требует от разработчика указания каждой детали выполнения, в то время как декларативное программирование позволяет сосредоточиться на конечном результате, что может сделать код более читаемым и поддерживаемым.</p>
              `,
            },
            {
              title: "Заключение",
              type: "text",
              description: `
                <p>Обе парадигмы имеют свои сильные и слабые стороны, и выбор между ними зависит от конкретной задачи и предпочтений разработчика.</p>
              `,
            },
          ],
        },
        {
          title: "KISS",
          children: [
            {
              title: "",
              type: "list",
              description:
                "<strong>KISS (Keep It Simple, Stupid)</strong> - это принцип, который подразумевает, что системы следует проектировать максимально просто; избегать ненужной сложности.",
            },
          ]
        },
        {
          title: "Methodology BEM",
          children: [
            {
              title: "B - Блок (Block)",
              type: "list",
              description: `
                <p>Определение блока:</p>
                <ul>
                  <li><strong>Что это</strong>: Независимый компонент интерфейса, который может быть переиспользован.</li>
                  <li><strong>Примеры</strong>: <code>header</code>, <code>menu</code>, <code>button</code>.</li>
                </ul>
              `,
            },
            {
              title: "E - Элемент (Element)",
              type: "list",
              description: `
                <p>Определение элемента:</p>
                <ul>
                  <li><strong>Что это</strong>: Составная часть блока, которая не имеет смысла вне него.</li>
                  <li><strong>Обозначение</strong>: Элементы обозначаются двойным подчеркиванием, например, <code>menu__item</code>.</li>
                </ul>
              `,
            },
            {
              title: "M - Модификатор (Modifier)",
              type: "list",
              description: `
                <p>Определение модификатора:</p>
                <ul>
                  <li><strong>Что это</strong>: Состояние или версия блока или элемента, изменяющая его внешний вид или поведение.</li>
                  <li><strong>Обозначение</strong>: Модификаторы обозначаются двойным дефиссом, например, <code>button--primary</code>.</li>
                </ul>
              `,
            },
            {
              title: "Преимущества BEM",
              type: "list",
              description: `
                <p>Основные преимущества методологии BEM:</p>
                <ul>
                  <li><strong>Читаемость</strong>: Структура именования делает код более понятным.</li>
                  <li><strong>Масштабируемость</strong>: Легко добавлять новые блоки и элементы без конфликтов.</li>
                  <li><strong>Поддерживаемость</strong>: Изменения в одном блоке не влияют на другие.</li>
                </ul>
              `,
            },
          ],
        },
        {
          title: "Methodology Agile",
          children: [
            {
              title: "Определение",
              type: "list",
              description: `
                <p>Agile — это методология разработки программного обеспечения, основанная на гибком подходе к планированию, тестированию и реализации проектов. Она акцентирует внимание на сотрудничестве, изменениях и быстром реагировании на отзывы клиентов.</p>
              `,
            },
            {
              title: "Основные принципы Agile",
              type: "list",
              description: `
                <p>Agile основывается на следующих принципах:</p>
                <ul>
                  <li><strong>Индивиды и взаимодействие</strong>: Приоритет отдается людям и их взаимодействию над процессами и инструментами.</li>
                  <li><strong>Работающий софт</strong>: Основное внимание уделяется созданию работающего программного обеспечения, а не документации.</li>
                  <li><strong>Сотрудничество с заказчиком</strong>: Заказчики активно участвуют в процессе разработки и дают обратную связь.</li>
                  <li><strong>Готовность к изменениям</strong>: Agile приветствует изменения требований, даже на поздних стадиях разработки.</li>
                </ul>
              `,
            },
            {
              title: "Методы Agile",
              type: "list",
              description: `
                <p>Существует несколько методов Agile, среди которых:</p>
                <ul>
                  <li><strong>Scrum</strong>: Методология, основанная на итеративном подходе и работе в командах, с регулярными встречами и спринтами.</li>
                  <li><strong>Kanban</strong>: Метод, акцентирующий внимание на визуализации работы и управлении потоком задач.</li>
                  <li><strong>Extreme Programming (XP)</strong>: Подход, сосредоточенный на технических практиках и улучшении качества кода.</li>
                </ul>
              `,
            },
            {
              title: "Преимущества Agile",
              type: "list",
              description: `
                <p>Преимущества использования Agile:</p>
                <ul>
                  <li><strong>Гибкость</strong>: Легкость адаптации к изменениям и новым требованиям.</li>
                  <li><strong>Улучшение качества</strong>: Регулярное тестирование и обратная связь помогают повышать качество продукта.</li>
                  <li><strong>Повышение вовлеченности команды</strong>: Активное участие членов команды в процессе разработки.</li>
                  <li><strong>Скорость поставки</strong>: Быстрая доставка функционала и ценности клиенту.</li>
                </ul>
              `,
            },
            {
              title: "Рекомендации по внедрению Agile",
              type: "list",
              description: `
                <p>Некоторые рекомендации по внедрению Agile:</p>
                <ul>
                  <li><strong>Обучение команды</strong>: Обеспечьте обучение методологиям Agile для всех участников проекта.</li>
                  <li><strong>Установите четкие роли</strong>: Определите роли в команде (Product Owner, Scrum Master и др.).</li>
                  <li><strong>Постоянная обратная связь</strong>: Регулярно собирайте отзывы от пользователей и членов команды.</li>
                  <li><strong>Итеративный подход</strong>: Начинайте с небольших итераций и постепенно увеличивайте сложность.</li>
                </ul>
              `,
            },
          ],
        },
        {
          title: "Methodology Scrum",
          children: [
            {
              title: "Определение",
              type: "list",
              description: `
                <p>Scrum — это фреймворк для управления проектами в рамках методологии Agile, который позволяет командам работать над сложными проектами, обеспечивая гибкость, прозрачность и регулярную доставку ценности.</p>
              `,
            },
            {
              title: "Основные роли в Scrum",
              type: "list",
              description: `
                <p>В Scrum выделяют три ключевые роли:</p>
                <ul>
                  <li><strong>Product Owner</strong>: Ответственный за создание и управление бэклогом продукта, определяет приоритеты и принимает решения о функциональности.</li>
                  <li><strong>Scrum Master</strong>: Обеспечивает соблюдение принципов Scrum, помогает команде устранять препятствия и организует процессы.</li>
                  <li><strong>Команда разработки</strong>: Мультидисциплинарная группа, которая непосредственно работает над созданием и доставкой продукта.</li>
                </ul>
              `,
            },
            {
              title: "Основные артефакты Scrum",
              type: "list",
              description: `
                <p>В Scrum используются следующие артефакты:</p>
                <ul>
                  <li><strong>Product Backlog</strong>: Список всех требований и задач, которые необходимо выполнить для продукта, приоритетизированный Product Owner.</li>
                  <li><strong>Sprint Backlog</strong>: Набор задач, выбранных из Product Backlog для выполнения в текущем спринте.</li>
                  <li><strong>Increment</strong>: Рабочая версия продукта, которая включает все завершенные задачи за текущий спринт и предыдущие.</li>
                </ul>
              `,
            },
            {
              title: "Процесс Scrum",
              type: "list",
              description: `
                <p>Процесс Scrum включает в себя следующие этапы:</p>
                <ul>
                  <li><strong>Планирование спринта</strong>: Определение задач, которые команда должна выполнить в течение спринта.</li>
                  <li><strong>Спринт</strong>: Итерация, обычно длится от 1 до 4 недель, в течение которой команда работает над задачами из Sprint Backlog.</li>
                  <li><strong>Ежедневные стендапы</strong>: Краткие встречи команды, на которых обсуждаются прогресс, планы и препятствия.</li>
                  <li><strong>Обзор спринта</strong>: Демонстрация завершенных задач заинтересованным сторонам по окончании спринта.</li>
                  <li><strong>Ретроспектива спринта</strong>: Обсуждение того, что прошло хорошо, что можно улучшить и как повысить эффективность команды в следующем спринте.</li>
                </ul>
              `,
            },
            {
              title: "Преимущества Scrum",
              type: "list",
              description: `
                <p>Преимущества использования Scrum:</p>
                <ul>
                  <li><strong>Гибкость</strong>: Легкость в адаптации к изменениям требований.</li>
                  <li><strong>Регулярная обратная связь</strong>: Частые встречи с заказчиками и заинтересованными сторонами для получения отзывов.</li>
                  <li><strong>Участие команды</strong>: Повышенная вовлеченность и ответственность участников команды.</li>
                  <li><strong>Постоянное улучшение</strong>: Регулярные ретроспективы способствуют повышению эффективности команды.</li>
                </ul>
              `,
            },
            {
              title: "Рекомендации по внедрению Scrum",
              type: "list",
              description: `
                <p>Некоторые рекомендации по внедрению Scrum:</p>
                <ul>
                  <li><strong>Обучение команды</strong>: Обеспечьте обучение принципам и практикам Scrum для всех членов команды.</li>
                  <li><strong>Четкое определение ролей</strong>: Убедитесь, что каждая роль хорошо понимает свои обязанности.</li>
                  <li><strong>Регулярные встречи</strong>: Настройте эффективные и регулярные встречи для обсуждения статуса и планов.</li>
                  <li><strong>Инструменты для управления</strong>: Используйте инструменты для управления проектами, такие как Jira или Trello.</li>
                </ul>
              `,
            },
          ],
        },
        {
          title: "Methodology Kanban",
          children: [
            {
              title: "Определение",
              type: "list",
              description: `
                <p>Kanban — это методология управления проектами, основанная на визуализации рабочего процесса и ограничении количества одновременно выполняемых задач. Она помогает командам улучшать эффективность и гибкость в управлении задачами.</p>
              `,
            },
            {
              title: "Основные принципы Kanban",
              type: "list",
              description: `
                <p>Kanban основывается на следующих ключевых принципах:</p>
                <ul>
                  <li><strong>Визуализация работы</strong>: Использование канбан-досок для отображения текущего состояния задач и рабочего процесса.</li>
                  <li><strong>Ограничение WIP (Work In Progress)</strong>: Установка лимитов на количество задач, которые могут выполняться одновременно, чтобы предотвратить перегрузку команды.</li>
                  <li><strong>Управление потоком</strong>: Анализ и оптимизация потока задач для улучшения их завершения.</li>
                  <li><strong>Постоянное улучшение</strong>: Регулярный анализ процессов и поиск возможностей для повышения эффективности.</li>
                </ul>
              `,
            },
            {
              title: "Канбан-доска",
              type: "list",
              description: `
                <p>Канбан-доска — это визуальный инструмент, который помогает командам отслеживать статус задач на разных этапах их выполнения. Обычно она включает следующие колонки:</p>
                <ul>
                  <li><strong>Запланировано</strong>: Задачи, которые еще не начаты.</li>
                  <li><strong>В процессе</strong>: Задачи, которые выполняются в данный момент.</li>
                  <li><strong>Завершено</strong>: Завершенные задачи, которые прошли все этапы.</li>
                </ul>
              `,
            },
            {
              title: "Преимущества Kanban",
              type: "list",
              description: `
                <p>Преимущества использования Kanban:</p>
                <ul>
                  <li><strong>Гибкость</strong>: Легкость в адаптации к изменениям и новым требованиям.</li>
                  <li><strong>Улучшение видимости</strong>: Визуализация процессов помогает команде лучше понимать текущую загрузку и прогресс.</li>
                  <li><strong>Сокращение времени выполнения</strong>: Оптимизация потока задач позволяет сократить время от начала до завершения работы.</li>
                  <li><strong>Постоянное улучшение</strong>: Фокус на анализе и оптимизации процессов способствует повышению качества работы.</li>
                </ul>
              `,
            },
            {
              title: "Рекомендации по внедрению Kanban",
              type: "list",
              description: `
                <p>Некоторые рекомендации по внедрению Kanban:</p>
                <ul>
                  <li><strong>Начните с текущего процесса</strong>: Не пытайтесь изменить все сразу; начните с визуализации текущих задач.</li>
                  <li><strong>Определите лимиты WIP</strong>: Установите разумные ограничения на количество задач в процессе.</li>
                  <li><strong>Регулярно анализируйте результаты</strong>: Проводите встречи для обсуждения прогресса и возможностей для улучшения.</li>
                  <li><strong>Используйте инструменты</strong>: Рассмотрите возможность использования цифровых инструментов для управления канбан-досками.</li>
                </ul>
              `,
            },
          ],
        },
        {
          title: "OOP",
          children: [
            {
              title:
                "Объектно-ориентированное программирование (ООП) — это парадигма программирования, основанная на концепции 'объектов', которые могут содержать данные и код. Основные принципы ООП:",
              type: "list",
              description: `
              <li>Инкапсуляция: Сокрытие состояния объекта и управление доступом к нему через методы. Это помогает защитить внутренние данные и предотвратить их неправильное использование.</li>
              <li>Наследование: Возможность создавать новые классы на основе существующих. Новый класс (потомок) наследует свойства и методы родительского класса, что позволяет повторно использовать и расширять код.</li>
              <li>Полиморфизм: Способность объектов разных классов обрабатывать данные через одинаковый интерфейс. Это позволяет использовать один и тот же метод для объектов разных типов, что увеличивает гибкость кода.</li>
              <li>Абстракция: Упрощение сложных систем путем определения общих интерфейсов и скрытия деталей реализации. Это помогает сосредоточиться на взаимодействии между объектами, не вникая в их внутренние механизмы.</li>
              <p>Эти принципы помогают создавать более структурированные, удобочитаемые и поддерживаемые приложения.</p>
              `,
            },
          ],
        },
        {
          title: "SOLID",
          children: [
            {
              title: "S - Single Responsibility Principle",
              type: "list",
              description: `
                <p>Принцип единственной ответственности:</p>
                <ul>
                  <li><strong>Определение</strong>: Каждый класс должен иметь одну единственную ответственность.</li>
                  <li><strong>Цель</strong>: Упрощение тестирования и модификации кода.</li>
                </ul>
              `,
            },
            {
              title: "O - Open/Closed Principle",
              type: "list",
              description: `
                <p>Принцип открытости/закрытости:</p>
                <ul>
                  <li><strong>Определение</strong>: Классы должны быть открыты для расширения, но закрыты для изменения.</li>
                  <li><strong>Цель</strong>: Позволяет добавлять новую функциональность без изменения существующего кода.</li>
                </ul>
              `,
            },
            {
              title: "L - Liskov Substitution Principle",
              type: "list",
              description: `
                <p>Принцип подстановки Лисков:</p>
                <ul>
                  <li><strong>Определение</strong>: Объекты подкласса должны быть взаимозаменяемыми с объектами суперкласса.</li>
                  <li><strong>Цель</strong>: Поддержание корректности программы при замене объектов.</li>
                </ul>
              `,
            },
            {
              title: "I - Interface Segregation Principle",
              type: "list",
              description: `
                <p>Принцип сегрегации интерфейсов:</p>
                <ul>
                  <li><strong>Определение</strong>: Клиенты не должны зависеть от интерфейсов, которые они не используют.</li>
                  <li><strong>Цель</strong>: Избежать ненужных зависимостей и создать узкоспециализированные интерфейсы.</li>
                </ul>
              `,
            },
            {
              title: "D - Dependency Inversion Principle",
              type: "list",
              description: `
                <p>Принцип инверсии зависимостей:</p>
                <ul>
                  <li><strong>Определение</strong>: Модули верхнего уровня не должны зависеть от модулей нижнего уровня; обе группы должны зависеть от абстракций.</li>
                  <li><strong>Цель</strong>: Уменьшение связанности между компонентами системы.</li>
                </ul>
              `,
            },
          ],
        },
        {
          title: "YAGNI",
          children: [
            {
              title: "",
              type: "list",
              description:
                "<strong>YAGNI (You Aren't Gonna Need It)</strong> - Принцип, который гласит, что не следует добавлять функциональности, пока не возникнет реальная необходимость, чтобы избежать излишней сложности.",
            },
          ]
        },
      ]
    },
    {
      title: "Interview",
      children: [
        {
          title: "Theme Frontend",
          children: [
            {
              title: "Common questions",
              children: [
                {
                  title: "Основные структуры данных и их организация",
                  children: [
                    {
                      title:
                        "В фронтенд-разработке используются различные структуры данных для организации и хранения информации",
                      type: "list",
                      description: `
                      <p>Вот некоторые из них:</p>
                        <li>Массивы (Arrays): Упорядоченные коллекции элементов, которые могут быть любого типа. Массивы позволяют хранить списки данных и обеспечивают доступ к элементам по индексу.</li>
                        <li>Объекты (Objects): Непорядочные коллекции пар "ключ-значение". Объекты используются для хранения связанных данных и представляют собой более сложные структуры, чем массивы.</li>
                        <li>Строки (Strings): Последовательности символов, которые используются для представления текстовой информации.</li>
                        <li>Множества (Sets): Коллекции уникальных значений. Множества полезны для хранения данных, когда важно избегать дубликатов.</li>
                        <li>Словари (Maps): Коллекции пар "ключ-значение", где ключи могут быть любого типа. Словари обеспечивают быстрый доступ к значениям по ключам.</li>
                        <p>Эти структуры данных могут быть организованы в более сложные структуры, такие как деревья и графы, в зависимости от требований приложения.</p>
                      `,
                    },
                  ],
                },
                {
                  title: "Двоичная система счисления",
                  children: [
                    {
                      title:
                        "Двоичная система счисления — это система, основанная на двух символах: 0 и 1",
                      type: "list",
                      description: `
                      <p>Она является основой для работы всех цифровых компьютеров, так как они используют двоичную логику для обработки данных. В двоичной системе каждое число представляется как последовательность битов (binary digits), где каждый бит может принимать значение 0 или 1.
                      Например, число 5 в десятичной системе представляется как 101 в двоичной системе:</p>
                        <li>1  2^2 (4) + 0  2^1 (0) + 1 * 2^0 (1) = 5</li>
                      <p>Двоичная система используется для представления данных, выполнения арифметических операций и управления логикой в компьютерах.</p>
                      `,
                    },
                  ],
                },
                {
                  title: "как работает браузер",
                  children: [
                    {
                      title:
                        "Браузер — это программа, которая выполняет следующие основные функции:",
                      type: "list",
                      description: `
                        <li>Запрос ресурсов: Браузер отправляет HTTP(S)-запросы к веб-серверу для получения HTML, CSS, JavaScript, изображений и других ресурсов.</li>
                        <li>Парсинг HTML: После получения ответа от сервера браузер начинает парсить HTML-код, создавая DOM (Document Object Model) — дерево объектов, представляющее структуру документа.</li>
                        <li>Парсинг CSS: Браузер обрабатывает CSS-файлы и создает CSSOM (CSS Object Model), который содержит правила стилей для элементов.</li>
                        <li>Создание страницы: Браузер объединяет DOM и CSSOM, чтобы создать Render Tree (дерево отображения), которое содержит только видимые элементы и их стили.</li>
                        <li>Рендеринг: Браузер вычисляет, как элементы должны быть отображены на экране (положение, размеры и так далее), и выполняет ученение — отрисовку страницы на экране устройства.</li>
                        <li>Обработка событий: Браузер отслеживает пользовательские действия (нажатия кнопок, движения мыши и т. д.) и обрабатывает события, вызывая соответствующий JavaScript-код.</li>
                      `,
                    },
                  ],
                },
                {
                  title: "Что такое DOM",
                  children: [
                    {
                      title:
                        "DOM (Document Object Model) — это программный интерфейс для классов документов HTML и XML. Он представляет структуру документа в виде дерева узлов, где каждый узел соответствует элементу или тексту на странице. DOM позволяет программно изменять структуру, содержимое и стиль документа.",
                      type: "list",
                      description: `
                      <p>С помощью DOM разработчики могут:</p>
                        <li>Добавлять, удалять и изменять элементы на странице.</li>
                        <li>Изменять атрибуты и стиль элементов.</li>
                        <li>Реагировать на события, происходящие в документе.</li>
                      <p>DOM позволяет языкам программирования, таким как JavaScript, эффективно взаимодействовать с HTML и динамически изменять пользовательский интерфейс без перезагрузки страницы.</p>
                      `,
                    },
                  ],
                },
                {
                  title: "Что такое BOM",
                  children: [
                    {
                      title: "Определение BOM",
                      type: "list",
                      description: `
                      <p>BOM (Browser Object Model) — это интерфейс, который предоставляет JavaScript доступ к объектам, представляющим браузер и его окружение. С помощью BOM разработчики могут взаимодействовать с элементами браузера, такими как окно, история, адресная строка и другие аспекты, не относящиеся непосредственно к документу.</p>
                      `,
                    },
                    {
                      title: "Основные объекты BOM",
                      type: "list",
                      description: `
                        <ul>
                          <li><strong>window:</strong> Главный объект, представляющий окно браузера. Все другие объекты BOM являются его свойствами.</li>
                          <li><strong>document:</strong> Объект, представляющий текущий HTML-документ, к которому можно получить доступ через 'window.document'.</li>
                          <li><strong>navigator:</strong> Объект, предоставляющий информацию о браузере и операционной системе пользователя.</li>
                          <li><strong>location:</strong> Объект, содержащий информацию о текущем URL и позволяющий изменять его.</li>
                          <li><strong>history:</strong> Объект, позволяющий взаимодействовать с историей браузера (например, переход назад и вперед).</li>
                        </ul>
                      `,
                    },
                    {
                      title: "Примеры использования BOM",
                      type: "list",
                      description: `
                        <ul>
                          <li><strong>Изменение URL:</strong> С помощью 'location.href' можно менять адрес текущей страницы.</li>
                          <li><strong>Получение информации о браузере:</strong> 'navigator.userAgent' позволяет узнать информацию о браузере пользователя.</li>
                          <li><strong>Управление историей:</strong> 'history.back()' и 'history.forward()' позволяют навигировать по истории посещенных страниц.</li>
                        </ul>
                      `,
                    },
                    {
                      title: "Преимущества и недостатки BOM",
                      type: "list",
                      description: `
                        <ul>
                          <li><strong>Преимущества:</strong> Позволяет взаимодействовать с браузером, что дает возможность создавать более динамичные и интерактивные веб-приложения.</li>
                          <li><strong>Недостатки:</strong> BOM не стандартизирован, поэтому могут быть различия в реализации между разными браузерами.</li>
                        </ul>
                      `,
                    },
                    {
                      title: "Заключение",
                      type: "paragraph",
                      description: `
                        <p>BOM является важной частью разработки веб-приложений, предоставляя доступ к объектам браузера и позволяя создавать более интерактивные интерфейсы. Понимание BOM поможет разработчикам лучше использовать возможности браузера для улучшения пользовательского опыта.</p>
                      `,
                    },
                  ],
                },
                {
                  title: "Фазы событий в DOM",
                  children: [
                    {
                      title: "1. Фаза захвата (Capturing Phase)",
                      type: "text",
                      description: `
                        <p>Событие начинает движение от верхнего уровня DOM-дерева к целевому элементу.</p>
                        <p>Событие "захватывается" верхними элементами, начиная с объекта <code>window</code> и проходя через все родительские элементы.</p>
                      `,
                    },
                    {
                      title: "2. Фаза целевого элемента (Target Phase)",
                      type: "text",
                      description: `
                        <p>Событие достигает целевого элемента, на который было инициировано.</p>
                        <p>В этой фазе событие обрабатывается непосредственно целевым элементом.</p>
                      `,
                    },
                    {
                      title: "3. Фаза всплытия (Bubbling Phase)",
                      type: "text",
                      description: `
                        <p>После обработки события целевым элементом оно начинает всплывать обратно к родительским элементам.</p>
                        <p>Событие проходит через всех родителей целевого элемента, начиная с непосредственного родителя и до корня документа.</p>
                      `,
                    },
                    {
                      title: "Пример работы фаз событий",
                      type: "text",
                      description: `
                        <p>1. Пользователь кликает на кнопку внутри <code>&lt;div&gt;</code>.<br>
                        2. Событие "клик" проходит от объекта <code>window</code> вниз к <code>&lt;div&gt;</code>, затем к кнопке (фаза захвата).<br>
                        3. Событие обрабатывается кнопкой (фаза целевого элемента).<br>
                        4. Затем событие "всплывает" обратно к <code>&lt;div&gt;</code> и выше (фаза всплытия).</p>
                      `,
                    },
                    {
                      title: "Обработка событий",
                      type: "code",
                      description: `
                        <p>Можно указать, в какой фазе будет срабатывать обработчик, используя третий аргумент в <code>addEventListener</code>.</p>
                      `,
                      code: `
element.addEventListener('click', handler, true); // Фаза захвата
element.addEventListener('click', handler, false); // Фаза всплытия
                      `
                    },
                  ],
                },
                {
                  title: "Из чего состоит HTTP запрос",
                  children: [
                    {
                      title: "HTTP-запрос состоит из нескольких частей:",
                      type: "list",
                      description: `
                      <p>Метод: Указывает тип запроса, например:</p>
                        <li>GET: Запрос на получение данных.</li>
                        <li>POST: Отправка данных на сервер.</li>
                        <li>PUT, DELETE и другие методы.</li>
                        <li>URL (Uniform Resource Locator): Указывает адрес ресурса, к которому осуществляется обращение.</li>
                        <li>Версия протокола: Например, HTTP/1.1 или HTTP/2.</li>
                      <p>Заголовки (Headers): Дополнительные метаданные о запросе, которые могут включать:</p>
                        <li>Content-Type: Указывает формат передаваемых данных.</li>
                        <li>Authorization: Используется для передачи учетных данных и токенов.</li>
                        <li>Другие заголовки, определяющие поведение кэширования, управление сессиями и т.д.</li>
                        <li>Тело (Body): Опциональная часть запроса, которая содержит данные, отправляемые на сервер (обычно в запросах POST, PUT и PATCH).</li>
                      `,
                    },
                  ],
                },
                {
                  title: "Разница между cookie, sessionStorage и localStorage",
                  children: [
                    {
                      title: "Cookie",
                      type: "list",
                      description: `
                        <p>Основные характеристики cookie:</p>
                        <li><strong>Применение</strong>: Хранит данные на стороне клиента, отправляемые на сервер при каждом запросе.</li>
                        <li><strong>Размер</strong>: Ограничен примерно 4 КБ.</li>
                        <li><strong>Время жизни</strong>: Может иметь заданное время жизни и храниться до его истечения.</li>
                        <li><strong>Доступ</strong>: Доступен для сервера и клиента.</li>
                      `,
                    },
                    {
                      title: "sessionStorage",
                      type: "list",
                      description: `
                        <p>Основные характеристики sessionStorage:</p>
                        <li><strong>Применение</strong>: Хранит данные, специфичные для одной сессии.</li>
                        <li><strong>Размер</strong>: Обычно ограничен до 5-10 МБ.</li>
                        <li><strong>Время жизни</strong>: Данные существуют лишь в течение одной вкладки.</li>
                        <li><strong>Доступ</strong>: Доступен только из текущей вкладки.</li>
                      `,
                    },
                    {
                      title: "localStorage",
                      type: "list",
                      description: `
                        <p>Основные характеристики localStorage:</p>
                        <li><strong>Применение</strong>: Хранит данные, доступные между сессиями.</li>
                        <li><strong>Размер</strong>: Обычно ограничен до 5-10 МБ.</li>
                        <li><strong>Время жизни</strong>: Данные сохраняются до тех пор, пока пользователь их не удалит.</li>
                        <li><strong>Доступ</strong>: Доступен только для клиентских скриптов.</li>
                      `,
                    },
                  ],
                },
                {
                  title: "Жизненный цикл страницы: три ключевых события",
                  children: [
                    {
                      title: "Загрузка и парсинг HTML",
                      type: "list",
                      description: `
                        <p>Основные характеристики загрузки и парсинга HTML:</p>
                        <ul>
                          <li><strong>Событие</strong>: Браузер загружает HTML-документ и начинает его парсить.</li>
                          <li><strong>Результат</strong>: Создается дерево элементов (DOM — Document Object Model).</li>
                          <li><strong>Зависимости</strong>: В процессе могут обнаруживаться внешние ресурсы (CSS, JavaScript).</li>
                          <li><strong>Ключевое событие</strong>: <code>DOMContentLoaded</code> срабатывает, когда HTML полностью загружен и разобран.</li>
                        </ul>
                      `,
                    },
                    {
                      title: "Загрузка и парсинг CSS",
                      type: "list",
                      description: `
                        <p>Основные характеристики загрузки и парсинга CSS:</p>
                        <ul>
                          <li><strong>Событие</strong>: Браузер загружает и парсит файлы CSS.</li>
                          <li><strong>Результат</strong>: Создается дерево стилей (CSSOM — CSS Object Model).</li>
                          <li><strong>Блокировка</strong>: Этот этап может блокировать рендеринг страницы.</li>
                        </ul>
                      `,
                    },
                    {
                      title: "Создание и рендеринг страницы",
                      type: "list",
                      description: `
                        <p>Основные характеристики создания и рендеринга страницы:</p>
                        <ul>
                          <li><strong>Событие</strong>: Браузер создает дерево рендеринга и отображает страницу.</li>
                          <li><strong>Результат</strong>: Объединение DOM и CSSOM для создания визуального представления.</li>
                          <li><strong>Ключевое событие</strong>: <code>load</code> срабатывает, когда вся страница и ее зависимости загружены.</li>
                        </ul>
                      `,
                    },
                    {
                      title: "Закрытие (beforeunload)",
                      type: "list",
                      description: `
                        <p>Событие 'beforeunload' срабатывает, когда пользователь пытается покинуть страницу или обновить ее. Оно позволяет разработчикам предупреждать пользователей о том, что у них есть несохраненные изменения, и дает возможность предотвратить случайное закрытие страницы.</p>
                      `,
                    },
                  ],
                },
              ],
            },
            {
              title: "HTML/CSS questions",
              children: [
                
              ]
            },
            {
              title: "JS questions",
              children: [
                {
                  title: "Основные алгоритмы сортировки и поиска",
                  children: [
                    {
                      title: "Алгоритмы сортировки",
                      type: "list",
                      description: `
                        <p>Вот некоторые из основных алгоритмов сортировки:</p>
                        <li><strong>Пузырьковая сортировка (Bubble Sort)</strong>: Простейший алгоритм сортировки с временной сложностью O(n^2).</li>
                        <li><strong>Сортировка выбором (Selection Sort)</strong>: Делит массив на отсортированную и неотсортированную части, временная сложность O(n^2).</li>
                        <li><strong>Сортировка вставками (Insertion Sort)</strong>: Строит отсортированный массив по одному элементу, временная сложность O(n^2).</li>
                        <li><strong>Сортировка слиянием (Merge Sort)</strong>: Рекурсивный алгоритм с временной сложностью O(n log n).</li>
                        <li><strong>Быстрая сортировка (Quick Sort)</strong>: Делит массив на элементы меньше и больше опорного элемента, временная сложность O(n log n).</li>
                        <li><strong>Сортировка кучей (Heap Sort)</strong>: Использует структуру данных "куча", временная сложность O(n log n).</li>
                      `,
                    },
                    {
                      title: "Алгоритмы поиска",
                      type: "list",
                      description: `
                        <p>Вот некоторые из основных алгоритмов поиска:</p>
                        <li><strong>Линейный поиск (Linear Search)</strong>: Проходит по каждому элементу массива, временная сложность O(n).</li>
                        <li><strong>Бинарный поиск (Binary Search)</strong>: Работает на отсортированных массивах, временная сложность O(log n).</li>
                        <li><strong>Поиск с использованием хеш-таблиц</strong>: Использует хеширование для быстрого поиска, временная сложность O(1) в среднем.</li>
                      `,
                    },
                  ],
                },
                {
                  title: "Реализация простого алгоритма на JavaScript",
                  children: [
                    {
                      title: "Факториал числа",
                      type: "code",
                      description: `
                        <p>Задача: Реализовать функцию, вычисляющую факториал числа.</p>
                        <ul>
                          <li>Факториал числа n (обозначается n!) равен произведению всех положительных целых чисел от 1 до n.</li>
                          <li>Пример: 5! = 5 * 4 * 3 * 2 * 1 = 120</li>
                        </ul>
                      `,
                      code: `
function factorial(n) {
  if (n < 0) return -1; // факториал не существует для отрицательных чисел
  if (n === 0) return 1; // 0! = 1
  return n * factorial(n - 1); // рекурсивный вызов
}
                      `,
                    },
                  ],
                },
              ],
            },
            {
              title: "React questions",
              children: [],
            },
            {
              title: "TypeScript questions",
              children: [

              ],
            },
            {
              title: "Темы интервью 📚",
              children: [
                {
                  title: "Общие вопросы",
                  children: [
                    {
                      title: "Основные концепции",
                      type: "list",
                      description: `
                        <ul>
                          <li>SOLID.</li>
                          <li>Как работает браузер?</li>
                          <li>Что такое DOM?</li>
                          <li>Из чего состоит HTTP запрос?</li>
                          <li>Основы ООП.</li>
                        </ul>
                      `,
                    },
                    {
                      title: "Структуры данных и алгоритмы",
                      type: "list",
                      description: `
                        <ul>
                          <li>Основные структуры данных и их организация (массив, список, стек, очередь, дерево, хеш-таблица и т.д.).</li>
                          <li>Основные алгоритмы сортировки и поиска.</li>
                          <li>Что такое двоичная система счисления?</li>
                        </ul>
                      `,
                    },
                    {
                      title: "Хранение данных",
                      type: "list",
                      description: `
                        <ul>
                          <li>Разница между cookie, sessionStorage и localStorage.</li>
                          <li>Что такое линтеры?</li>
                          <li>Что такое Prettier?</li>
                        </ul>
                      `,
                    },
                    {
                      title: "Программирование и методологии",
                      type: "list",
                      description: `
                        <ul>
                          <li>Функциональное программирование.</li>
                          <li>Шаблоны проектирования.</li>
                          <li>Антипаттерны.</li>
                          <li>Continuous Integration (CI) vs Continuous Deployment (CD) vs Delivery Pipeline (DP).</li>
                          <li>Методология Agile.</li>
                          <li>Методология Scrum.</li>
                          <li>Методология Kanban.</li>
                        </ul>
                      `,
                    },
                  ],
                },
                {
                  title: "HTML/CSS",
                  children: [
                    {
                      title: "Основные концепции",
                      type: "list",
                      description: `
                        <ul>
                          <li>Структура HTML документа.</li>
                          <li>Способы подключения стилей в HTML.</li>
                          <li>На что нужно обратить внимание при разработке мультиязычных сайтов?</li>
                          <li>Что такое DOCTYPE и зачем он нужен?</li>
                          <li>Что такое BEM?</li>
                        </ul>
                      `,
                    },
                    {
                      title: "CSS",
                      type: "list",
                      description: `
                        <ul>
                          <li>Вес селектора или что такое специфичность в CSS.</li>
                          <li>Псевдоклассы и псевдоэлементы.</li>
                          <li>Коробчатая модель (box-sizing).</li>
                          <li>em против rem, относительные и абсолютные значения.</li>
                          <li>Разница между блочными и строчными элементами.</li>
                          <li>Флексбокс.</li>
                          <li>CSS Grid (Сетка).</li>
                          <li>Как использовать CSS-переменные?</li>
                        </ul>
                      `,
                    },
                    {
                      title: "Семантика",
                      type: "list",
                      description: `
                        <ul>
                          <li>Какие существуют принципы семантической верстки?</li>
                          <li>Что такое #shadow-root в инспекторе HTML-страницы?</li>
                          <li>Как правильно использовать HTML5-теги?</li>
                        </ul>
                      `,
                    },
                    {
                      title: "Прочее",
                      type: "list",
                      description: `
                        <ul>
                          <li>Что такое прогрессивная развертка?</li>
                          <li>Объясни разницу между script, script async и script defer.</li>
                          <li>Как изменить цвет в SVG файле?</li>
                          <li>Что такое адаптивный и отзывчивый дизайн?</li>
                          <li>Как использовать медиа-запросы в CSS?</li>
                        </ul>
                      `,
                    },
                  ],
                },
                {
                  title: "JS",
                  children: [
                    {
                      title: "Основные концепции",
                      type: "list",
                      description: `
                        <ul>
                          <li>Типы данных.</li>
                          <li>NaN.</li>
                          <li>Разница и схожесть между null и undefined.</li>
                          <li>Как объекты превращаются в примитивы?</li>
                          <li>Оператор typeof.</li>
                          <li>Преобразования типов данных.</li>
                          <li>Переменные let, const, var.</li>
                          <li>this.</li>
                          <li>Descriptors, Getters, and Setters.</li>
                        </ul>
                      `,
                    },
                    {
                      title: "Функции",
                      type: "list",
                      description: `
                        <ul>
                          <li>Функция declaration and expression, arrow function.</li>
                          <li>Что такое функции высшего порядка.</li>
                          <li>Для чего используется директива «use strict».</li>
                          <li>Почему результатом сравнения двух похожих объектов является false.</li>
                          <li>Как создать объект, не имеющий прототипа.</li>
                          <li>Что такое замыкания и как они работают?</li>
                          <li>Что такое this в JavaScript?</li>
                          <li>Что такое стрелочные функции?</li>
                          <li>Какие существуют способы передачи функции в качестве аргумента?</li>
                          <li>Что такое «call()» и как они работают?</li>
                          <li>Что такое «apply()» и как они работают?</li>
                          <li>Что такое «bind()» и как они работают?</li>
                          <li>Какие аргументы у addEventListener()?</li>
                        </ul>
                      `,
                    },
                    {
                      title: "Наследование и замыкания",
                      type: "list",
                      description: `
                        <ul>
                          <li>Посредством чего в JS реализуются наследования?</li>
                          <li>Что такое замыкание (closure) и какие сценарии его использования?</li>
                          <li>Как определить наличие свойства в объекте?</li>
                          <li>Что такое прототипное наследование?</li>
                        </ul>
                      `,
                    },
                    {
                      title: "Promise и колбэки",
                      type: "list",
                      description: `
                        <ul>
                          <li>Promise.</li>
                          <li>Что такое async/await.</li>
                          <li>Как работают колбэки.</li>
                          <li>Как обрабатывать ошибки в Promise?</li>
                        </ul>
                      `,
                    },
                    {
                      title: "Структуры данных",
                      type: "list",
                      description: `
                        <ul>
                          <li>Чем отличается Map от WeakMap?</li>
                          <li>Чем отличается Set от WeakSet?</li>
                          <li>Как работает сборщик мусора в JS?</li>
                          <li>Живые и неживые коллекции?</li>
                        </ul>
                      `,
                    },
                    {
                      title: "Взаимодействие с DOM",
                      type: "list",
                      description: `
                        <ul>
                          <li>Как получить доступ к элементу DOM?</li>
                          <li>Как отследить изменения поля объекта в функциональном компоненте?</li>
                          <li>Как добавить и удалить элементы из DOM?</li>
                          <li>Фазы событий в DOM?</li>
                        </ul>
                      `,
                    },
                    {
                      title: "Алгоритмы и модели",
                      type: "list",
                      description: `
                        <ul>
                          <li>В чем разница между spread-оператором и rest-оператором?</li>
                          <li>Случай переключателя — примеры, где это может быть полезно.</li>
                          <li>Циклы - for, while, do while.</li>
                          <li>Строгое и нестрогое сравнение.</li>
                          <li>Тернарные, нулевое объединение, необязательное связывание и логические операторы – синтаксис и варианты использования.</li>
                          <li>Императивное и декларативное программирование.</li>
                        </ul>
                      `,
                    },
                    {
                      title: "Безопасность",
                      type: "list",
                      description: `
                        <ul>
                          <li>Что такое XSS (Cross-Site Scripting)?</li>
                          <li>В чем разница между методами call, apply, bind?</li>
                          <li>Что такое CSRF (Cross-Site Request Forgery)?</li>
                        </ul>
                      `,
                    },
                    {
                      title: "Частые вопросы",
                      type: "list",
                      description: `
                        <ul>
                          <li>Как работает механизм замыкания?</li>
                          <li>Каковы особенности работы с асинхронным кодом?</li>
                          <li>Что такое Event Loop в JavaScript?</li>
                          <li>Отмена всплытия и погружения событий?</li>
                          <li>Как работает прототипная подстановка?</li>
                          <li>Отмена действий браузера по умолчанию?</li>
                          <li>Делегирование событий?</li>
                          <li>CRP (Cross-Origin Resource Policy)?</li>
                          <li>Как работают заголовки CORS?</li>
                          <li>Глобальный объект window и его свойства и методы?</li>
                          <li>Что такое Scope?</li>
                          <li>Что такое hoisting и как он работает?</li>
                          <li>Что такое Temporal Dead Zone?</li>
                        </ul>
                      `,
                    },
                    {
                      title: "Остальные вопросы",
                      type: "list",
                      description: `
                        <ul>
                          <li>Bind, call, apply можно использовать на стрелочных функциях ?</li>
                          <li>Какой контекст берет стрелочная функция в объекте / в классе?</li>
                          <li></li>
                          <li></li>
                        </ul>
                      `
                    }
                  ],
                },
                {
                  title: "Network",
                  children: [
                    {
                      title: "Основы протоколов",
                      type: "list",
                      description: `
                        <ul>
                          <li>HTTP и HTTPS</li>
                          <li>версии протокола HTTP 1.x и разница между ними</li>
                          <li>протокол TCP и UDP</li>
                          <li>модель OSI</li>
                        </ul>
                      `,
                    },
                    {
                      title: "Методы HTTP",
                      type: "list",
                      description: `
                        <ul>
                          <li>какие методы есть?</li>
                          <li>GET и POST</li>
                          <li>PATCH и PUT</li>
                          <li>DELETE</li>
                          <li>OPTIONS</li>
                          <li>метод CONNECT</li>
                          <li>идемпотентные методы HTTP</li>
                        </ul>
                      `,
                    },
                    {
                      title: "Запросы и ответы",
                      type: "list",
                      description: `
                        <ul>
                          <li>request / response</li>
                          <li>Response codes</li>
                          <li>заголовки HTTP</li>
                        </ul>
                      `,
                    },
                    {
                      title: "Технологии взаимодействия",
                      type: "list",
                      description: `
                        <ul>
                          <li>JWT</li>
                          <li>простые и сложные запросы</li>
                          <li>Long Polling / Short Polling requests</li>
                          <li>Websocket</li>
                          <li>SSE</li>
                          <li>CORS</li>
                          <li>CRP</li>
                          <li>REST</li>
                        </ul>
                      `,
                    },
                    {
                      title: "Безопасность и угрозы",
                      type: "list",
                      description: `
                        <ul>
                          <li>Web-угрозы</li>
                        </ul>
                      `,
                    },
                    {
                      title: "Частые вопросы",
                      type: "list",
                      description: `
                        <ul>
                          <li>Что такое CORS и как он работает?</li>
                          <li>В чем разница между GET и POST?</li>
                          <li>Что такое RESTful API?</li>
                          <li>Как работает механизм JWT?</li>
                          <li>Что такое идемпотентность и когда она важна?</li>
                          <li>Как обрабатывать ошибки в HTTP?</li>
                          <li>Что происходит когда пользователь переходит по ссылке?</li>
                        </ul>
                      `,
                    },
                    {
                      title: "Обязательные темы для собеседований",
                      type: "list",
                      description: `
                        <ul>
                          <li>Основы HTTP/HTTPS</li>
                          <li>Различия между методами HTTP</li>
                          <li>Коды ответов HTTP</li>
                          <li>Принципы REST и архитектура API</li>
                          <li>Безопасность веб-приложений</li>
                          <li>CORS и его применение</li>
                        </ul>
                      `,
                    },
                  ],
                },
                {
                  title: "React",
                  children: [
                    {
                      title: "Основные концепции",
                      type: "list",
                      description: `
                        <ul>
                          <li>Что такое JSX?</li>
                          <li>Что такое JSX-компоненты?</li>
                          <li>Что такое виртуальный DOM?</li>
                          <li>Что такое реквизиты в React?</li>
                          <li>Что такое фрагмент React?</li>
                          <li>Что такое children в React?</li>
                        </ul>
                      `,
                    },
                    {
                      title: "Компоненты",
                      type: "list",
                      description: `
                        <ul>
                          <li>Что такое Portal?</li>
                          <li>В чем разница между классовыми и функциональными компонентами?</li>
                          <li>Чем управляемые компоненты отличаются от неуправляемых?</li>
                          <li>Как выполнить рендеринг элементов массива?</li>
                          <li>Что такое методы жизненного цикла компонента?</li>
                          <li>Как работают условный рендеринг элементов?</li>
                          <li>Как отследить размонтирование функционального компонента?</li>
                          <li>Что такое пользовательский хук?</li>
                          <li>Перечислите правила создания пользовательского хука.</li>
                        </ul>
                      `,
                    },
                    {
                      title: "Хуки",
                      type: "list",
                      description: `
                        <ul>
                          <li>Какие хуки вы знаете?</li>
                          <li>В чем заключаются особенности использования useState?</li>
                          <li>В чем заключаются особенности использования useEffect?</li>
                          <li>Для чего и как используется useMemo?</li>
                          <li>Для чего используется useCallback и как он работает?</li>
                          <li>В чем разница между useMemo и useCallback?</li>
                          <li>Для чего используется useRef и как он работает?</li>
                          <li>Для чего используется useContext и как он работает?</li>
                        </ul>
                      `,
                    },
                    {
                      title: "Состояние",
                      type: "list",
                      description: `
                        <ul>
                          <li>Что такое менеджер состояний и с какими из них вы работали?</li>
                          <li>В каких случаях можно использовать локальное состояние, а когда следует использовать глобальное состояние?</li>
                          <li>Что такое reducer в Redux и какие параметры он принимает?</li>
                          <li>Какой паттерн реализует Redux?</li>
                          <li>Что такое Redux?</li>
                          <li>В чем разница между Redux и MobX?</li>
                          <li>Что такое store?</li>
                          <li>Что такое action?</li>
                          <li>Что такое reducer?</li>
                          <li>Что такое middleware?</li>
                          <li>Что такое dispatch?</li>
                          <li>Что такое subscribe?</li>
                          <li>Что такое bindActionCreators?</li>
                          <li>Что такое действие и как можно изменить состояние в Redux?</li>
                        </ul>
                      `,
                    },
                    {
                      title: "Архитектура",
                      type: "list",
                      description: `
                        <ul>
                          <li>Как бы вы построили хорошую архитектуру проекта на React?</li>
                          <li>Что такое Feature-Sliced Design?</li>
                          <li>Как выполняется валидация данных в React-приложении?</li>
                          <li>Какие архитектурные решения для React вы знаете?</li>
                          <li>Расскажите об основных библиотеках React, которые вы знаете. Какие у них плюсы и минусы?</li>
                        </ul>
                      `,
                    },
                    {
                      title: "Другие аспекты",
                      type: "list",
                      description: `
                        <ul>
                          <li>Как отследить изменения поля объекта в функциональном компоненте?</li>
                          <li>Как получить доступ к элементу DOM?</li>
                          <li>Как обрабатывать асинхронные действия в Redux Thunk?</li>
                          <li>Зачем нужны ключи в списках при использовании map()?</li>
                          <li>Что такое React.memo()?</li>
                          <li>Что такое React Reconciliation?</li>
                          <li>Что такое публичный API?</li>
                          <li>Как оптимизировать производительность React-приложения?</li>
                        </ul>
                      `,
                    },
                    {
                      title: "Частые вопросы",
                      type: "list",
                      description: `
                        <ul>
                          <li>В чем разница между controlled и uncontrolled компонентами?</li>
                          <li>Как работает механизм контекста в React?</li>
                          <li>Что такое HOC (Higher-Order Component)?</li>
                          <li>Как использовать React Router?</li>
                        </ul>
                      `,
                    },
                  ],
                },
                {
                  title: "TypeScript",
                  children: [
                    {
                      title: "Основные концепции",
                      type: "list",
                      description: `
                        <ul>
                          <li>Что такое TypeScript и чем он отличается от JavaScript?</li>
                          <li>Преимущества использования TypeScript.</li>
                          <li>Типы данных в TypeScript: примитивные и сложные.</li>
                          <li>Что такое интерфейсы и как они работают?</li>
                          <li>Что такое типы объединения (Union Types) и пересечения (Intersection Types)?</li>
                        </ul>
                      `,
                    },
                    {
                      title: "Типизация",
                      type: "list",
                      description: `
                        <ul>
                          <li>Как объявить типы переменных?</li>
                          <li>Что такое типы по умолчанию?</li>
                          <li>Как использовать типы для функций?</li>
                          <li>Как создать пользовательские типы?</li>
                          <li>Типизация массивов и кортежей.</li>
                        </ul>
                      `,
                    },
                    {
                      title: "Классы и интерфейсы",
                      type: "list",
                      description: `
                        <ul>
                          <li>Что такое классы в TypeScript?</li>
                          <li>Как работает наследование классов?</li>
                          <li>Что такое модификаторы доступа (public, private, protected)?</li>
                          <li>Как использовать интерфейсы для описания структуры объектов?</li>
                          <li>Что такое абстрактные классы?</li>
                        </ul>
                      `,
                    },
                    {
                      title: "Функции и дженерики",
                      type: "list",
                      description: `
                        <ul>
                          <li>Как объявить функции с типами параметров и возвращаемым типом?</li>
                          <li>Что такое дженерики и как они работают?</li>
                          <li>Как использовать дженерики с интерфейсами и классами?</li>
                          <li>Типизация колбеков и промисов.</li>
                        </ul>
                      `,
                    },
                    {
                      title: "Интеграция с JavaScript",
                      type: "list",
                      description: `
                        <ul>
                          <li>Как использовать JavaScript-библиотеки в TypeScript?</li>
                          <li>Что такое DefinitelyTyped и как его использовать?</li>
                          <li>Как писать декларации типов для сторонних библиотек?</li>
                        </ul>
                      `,
                    },
                    {
                      title: "Инструменты и конфигурация",
                      type: "list",
                      description: `
                        <ul>
                          <li>Как настроить TypeScript в проекте?</li>
                          <li>Что такое tsconfig.json и какие параметры можно настроить?</li>
                          <li>Интеграция TypeScript с инструментами сборки (Webpack, Parcel и др.).</li>
                        </ul>
                      `,
                    },
                    {
                      title: "Частые вопросы",
                      type: "list",
                      description: `
                        <ul>
                          <li>Каковы основные различия между TypeScript и Flow?</li>
                          <li>Как обрабатывать ошибки типов в TypeScript?</li>
                          <li>Как использовать TypeScript с React?</li>
                          <li>Что такое "type assertion" и когда его использовать?</li>
                        </ul>
                      `,
                    },
                  ],
                },
              ],
            },
          ],
        },
        {
          title: "Theme Backend",
          children: [
            {
              title: "new topic",
              // type: "title",
            },
          ],
        },
        {
          title: "Definitions",
          children: [
            {
              title: "",
              type: "list",
              description: `<strong>BEM</strong> — это парадигма, которая используется для описания структуры элементов интерфейса.`,
            },
            {
              title: "",
              type: "list",
              description: `<strong>Functional programming</strong> — это парадигма программирования, в которой основное внимание уделяется использованию функций и избеганию изменения состояния и данных.`
            },
            {
              title: "",
              type: "list",
              description:
                "<strong>Reducer</strong> - чистая функция, которая принимает старый 'state' и 'action', и возвращает новое модифицированное состояние если это нужно. По правилам иммутабельности работает лишь с копией state.",
            },
            {
              title: "",
              type: "list",
              description:
                "<strong>Actions</strong> - объект, который содержит тип и payload, которые передаются в reducer.",
            },
            {
              title: "",
              type: "list",
              description:
                "<strong>Thunk</strong> - функция, которая возвращает другую функцию.",
            },
            {
              title: "",
              type: "list",
              description:
                "<strong>Middleware</strong> - функция, которая принимает store и next и возвращает функцию, которая принимает action и вызывает next(action).",
            },
            {
              title: "",
              type: "list",
              description:
                "<strong>Selectors</strong> - функция, которая принимает state и возвращает его часть.",
            },
            {
              title: "",
              type: "list",
              description:
                "<strong>HOC</strong> - Higher Order Component - функция, которая принимает компонент и возвращает новый компонент.",
            },
            {
              title: "",
              type: "list",
              description:
                "<strong>Hooks</strong> - функции, которые позволяют использовать состояние и действия в функциональном компоненте.",
            },
            {
              title: "",
              type: "list",
              description:
                '<strong>Promise</strong> - объект, который представляет асинхронное выполнение. Он может быть в состояниях "pending", "fulfilled" и "rejected."',
            },
            {
              title: "",
              type: "list",
              description:
                "<strong>Callback</strong> - функция, которая вызывается после завершения асинхронного действия.",
            },
            {
              title: "",
              type: "list",
              description:
                "<strong>BLL</strong> - Business Logic Layer (слой бизнес логики).",
            },
            {
              title: "",
              type: "list",
              description:
                "<strong>DAL</strong> - Data Access Layer (слой доступа к данным).",
            },
            {
              title: "",
              type: "list",
              description:
                "<strong>UI</strong> - User Interface (пользовательский интерфейс).",
            },
            {
              title: "",
              type: "list",
              description:
                "<strong>API</strong> - Application Programming Interface (интерфейс программного обеспечения).",
            },
            {
              title: "",
              type: "list",
              description:
                "<strong>REST API</strong> - Representational State Transfer API (REST API).",
            },
            {
              title: "",
              type: "list",
              description:
                "<strong>Side Effects</strong> - эффекты, которые происходят в результате выполнения асинхронного действия.",
            },
            {
              title: "",
              type: "list",
              description:
                "<strong>OOP</strong> - Объектно-ориентированное программирование.",
            },
            {
              title: "",
              type: "list",
              description:
                "<strong>Encapsulation</strong> - инкапсуляция, которая предотвращает доступ к необходимому коду извне.",
            },
            {
              title: "",
              type: "list",
              description:
                "<strong>Polymorphism</strong> - полиморфизм, который позволяет обрабатывать различные объекты в одном коде.",
            },
            {
              title: "",
              type: "list",
              description:
                "<strong>Inheritance</strong> - наследование, которое позволяет создавать новые классы на основе существующих.",
            },
            {
              title: "",
              type: "list",
              description:
                "<strong>Constructor</strong> - конструктор, который вызывается при создании объекта.",
            },
            {
              title: "",
              type: "list",
              description:
                "<strong>Super</strong> - ключевое слово, которое вызывается в конструкторе родительского класса.",
            },
            {
              title: "",
              type: "list",
              description:
                "<strong>This</strong> - ключевое слово, которое ссылается на текущий объект.",
            },
            {
              title: "",
              type: "list",
              description:
                "<strong>Prototype</strong> - объект, который хранит ссылки на другие объекты.",
            },
            {
              title: "",
              type: "list",
              description:
                "<strong>Bind</strong> - метод, который привязывает функцию к объекту.",
            },
            {
              title: "",
              type: "list",
              description:
                "<strong>Component</strong> - это функциональный компонент React, который возвращает JSX.",
            },
            {
              title: "",
              type: "list",
              description:
                "<strong>ComponentDidMount</strong> - это жизненный цикл компонента, который вызывается после его рендеринга.",
            },
            {
              title: "",
              type: "list",
              description:
                "<strong>__proto__</strong> - это свойство объекта, которое хранит ссылки на другие объекты.",
            },
            {
              title: "",
              type: "list",
              description:
                "<strong>SOLID</strong> - это принципы ООП, которые помогают разработчикам создавать простые и удобные программы.",
            },
            {
              title: "",
              type: "list",
              description:
                "<strong>KISS (Keep It Simple, Stupid)</strong> - это принцип, который подразумевает, что системы следует проектировать максимально просто; избегать ненужной сложности.",
            },
            {
              title: "",
              type: "list",
              description:
                "<strong>DRY (Don't Repeat Yourself)</strong> - Принцип, согласно которому информация и логика не должны повторяться в коде, чтобы уменьшить дублирование и облегчить поддержку.",
            },
            {
              title: "",
              type: "list",
              description:
                "<strong>YAGNI (You Aren't Gonna Need It)</strong> - Принцип, который гласит, что не следует добавлять функциональности, пока не возникнет реальная необходимость, чтобы избежать излишней сложности.",
            },
            {
              title: "",
              type: "list",
              description:
                "<strong>Clean code</strong> - Это код, который легко читать, понимать и поддерживать. Он следует стандартам стиля, хорошо структурирован и документирован.",
            },
            {
              title: "",
              type: "list",
              description:
                "<strong>Continuous Integration (CI)</strong> -  Это практика разработки, при которой изменения в коде автоматически интегрируются и тестируются в основном репозитории, что позволяет выявлять и устранять ошибки на ранних стадиях.",
            },
            {
              title: "",
              type: "list",
              description:
                "<strong>Delivery (Continuous Delivery)</strong> - Это подход, при котором код всегда готов к выпуску в продакшн. Это позволяет быстро и предсказуемо разворачивать обновления.",
            },
            {
              title: "",
              type: "list",
              description:
                "<strong>Deployments</strong> - Этот процесс включает в себя развертывание приложения или обновлений на продуктивном сервере для его использования конечными пользователями.",
            },
            {
              title: "",
              type: "list",
              description:
                "<strong>Agile</strong> - Методология разработки программного обеспечения, ориентированная на гибкость и адаптивность, которая подчеркивает необходимость быстрой поставки частичных и готовых продуктов.",
            },
            {
              title: "",
              type: "list",
              description:
                "<strong>Scrum</strong> - Фреймворк для управления проектами в Agile, который организует команды в спринты для быстрой разработки, обратной связи и улучшения процессов.",
            },
            {
              title: "",
              type: "list",
              description:
                "<strong>Kanban</strong> - Метод управления, который использует визуальные доски и карточки для отслеживания и управления потоком работы, акцентируя внимание на оптимизации процессов и сокращении времени выполнения задач.",
            },
          ],
        },
      ],
    },
    {
      title: "IDE",
      children: [
        {
          title: "VS Code",
          children: [
            {
              title: "Visual Studio Code Справка по горячим клавишам",
              type: "link",
              url: "https://hotkeycheatsheet.com/ru/hotkey-cheatsheet/vscode",
            },
          ],
        },
        {
          title: "WebStorm",
          children: [
            {
              title: "WebStorm Справка по горячим клавишам",
              type: "link",
              url: "https://hotkeycheatsheet.com/ru/hotkey-cheatsheet/webstorm",
            },
          ],
        },
        {
          title: "Sublime Text 3",
          children: [
            {
              title: "Sublime Text 3 Справка по горячим клавишам",
              type: "link",
              url: "https://hotkeycheatsheet.com/ru/hotkey-cheatsheet/sublime-text-3",
            },
          ],
        },
        {
          title: "PyCharm",
          children: [
            {
              title: "PyCharm Справка по горячим клавишам",
              type: "link",
              url: "https://hotkeycheatsheet.com/ru/hotkey-cheatsheet/pycharm",
            },
          ],
        },
      ],
    },
  ],
};
