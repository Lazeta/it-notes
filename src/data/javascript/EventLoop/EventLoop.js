export const EventLoop = {
  id: 142,
  title: "Event Loop / Цикл событий",
  children: [
    {
      title: "Цикл событий (Event Loop)",
      type: "text",
      description: `
        <p>Цикл событий — это механизм, который позволяет JavaScript выполнять асинхронные операции, не блокируя основной поток выполнения. Он состоит из следующих ключевых компонентов:</p>
        
        <h3>1. Call Stack (Стек вызовов)</h3>
        <ul>
          <li>Содержит текущий стек выполнения функций</li>
          <li>Когда функция вызывается, она добавляется в стек вызовов</li>
          <li>Когда выполнение функции завершается, она удаляется из стека</li>
          <li>JavaScript однопоточный - одновременно выполняется только одна функция из стека</li>
        </ul>
        <p><strong>Принцип: LIFO (Last In, First Out)</strong> — последняя вошедшая функция выполняется первой.</p>
        
        <h3>2. Task Queue | Macro Tasks | Callback Queue</h3>
        <ul>
          <li>Когда асинхронная операция (setTimeout, запрос к серверу и т.д.) завершается, её callback-функция помещается в эту очередь</li>
          <li>Очередь работает по принципу FIFO (First In - First Out)</li>
          <li>Содержит callback'и от различных Web API (DOM events, сетевые запросы, таймеры)</li>
        </ul>

        <p><strong>Принцип: FIFO (First In, First Out)</strong> — первая добавленная задача выполняется первой.</p>
        
        <h3>3. Micro Tasks (Микро задачи</h3>
        <ul>
          <li>Когда асинхронная операция (Promise, process.nextTick) завершается, она помещается в очередь микро задач</li>
          <li>Микро задачи выполняются сразу после текущего стека, перед макро задачами</li>
        </ul>
        <p><strong>Принцип: FIFO (First In, First Out)</strong> — первая добавленная микрозадача выполняется первой.</p>

        <h3>4. Event Loop (Цикл событий)</h3>
        <ul>
          <li>Непрерывно проверяет состояние стека вызовов</li>
          <li>Если стек пуст, берёт первую функцию из очереди обратных вызовов и помещает её в стек для выполнения</li>
          <li>Таким образом обеспечивается неблокирующее выполнение асинхронного кода</li>
        </ul>
        
        <h3>Пример работы:</h3>
        <ol>
          <li>Синхронный код выполняется сразу, попадая в стек вызовов</li>
          <li>Асинхронный код (например, setTimeout) передаётся Web API</li>
          <li>Когда Web API завершает операцию, callback попадает в очередь</li>
          <li>Event Loop переносит callback в стек (когда тот пуст) для выполнения</li>
        </ol>
        
        <p>Эта модель позволяет JavaScript эффективно обрабатывать пользовательские взаимодействия и сетевые операции без блокировки основного потока.</p>
      `,
    },
    {
      title: "Микротаски и макротаски",
      type: "text",
      description: `
        <ul>
          <li><strong>Микротаски</strong> (Promise, process.nextTick) имеют высший приоритет и выполняются сразу после текущего стека, перед макротасками</li>
          <li><strong>Макротаски</strong> (setTimeout, setInterval, I/O) попадают в очередь обратных вызовов</li>
          <li>Event Loop сначала обрабатывает все микротаски, прежде чем взять следующую макротаску</li>
        </ul>
      `,
    },
    {
      title: "Визуализация работы Event Loop",
      type: "text",
      description: `
        <p>Порядок выполнения:</p>
        <ol>
          <li>Выполняется весь синхронный код (Call Stack)</li>
          <li>Выполняются все доступные микротаски</li>
          <li>Выполняется одна макротаска из очереди</li>
          <li>Снова проверяются микротаски (и выполняются, если есть)</li>
          <li>Цикл повторяется</li>
        </ol>
      `,
    },
  ],
};
