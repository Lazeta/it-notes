export const testEventLoop = {
  id: 100025,
  title: "Eventloop",
  questions: [
    {
      id: 100026,
      question: "Что такое Eventloop?",
      answer: `Цикл событий (event loop) — это механизм, который позволяет JavaScript выполнять асинхронные 
      операции, не блокируя основной поток выполнения. Он обеспечивает обработку событий и выполнение 
      колбеков (callback functions) в ответ на события, такие как клики мыши, нажатия клавиш и завершение 
      асинхронных операций.`,
    },
    {
      id: 100027,
      question: "Как работает цикл событий?",
      answer: `Event Loop работает следующим образом:
      1. **Call Stack (Стек вызовов):** Содержит текущие выполняемые функции. Когда функция вызывается, она 
      добавляется в стек, а после завершения — удаляется.
      2. **Callback Queue (Очередь обратных вызовов):** Когда асинхронная операция завершается, её колбэк 
      помещается в очередь.
      3. **Microtasks Queue (Очередь микрозадач):** Колбэки Promises обрабатываются здесь и имеют приоритет 
      перед макрозадачами.
      4. **Event Loop:** Проверяет, пуст ли Call Stack. Если да, то выполняет задачи из очередей: сначала 
      микрозадачи, затем макрозадачи.
      
      Пример:
      \`\`\`javascript
      console.log("Start");
      setTimeout(() => console.log("Timeout"), 0);
      Promise.resolve().then(() => console.log("Promise"));
      console.log("End");

      // Вывод: Start, End, Promise, Timeout
      \`\`\`
      `,
    },
    {
      id: 100028,
      question: "Что такое макро и микро задачи?",
      answer: `**Микрозадачи (Microtasks):**
      - Выполняются сразу после текущего скрипта, но до обработки макрозадач.
      - Примеры: \`Promise.then\`, \`MutationObserver\`.
      
      **Макрозадачи (Macrotasks):**
      - Выполняются в рамках отдельных циклов Event Loop.
      - Примеры: \`setTimeout\`, \`setInterval\`, события DOM.
      
      Пример:
      \`\`\`javascript
      console.log("Start");
      setTimeout(() => console.log("Timeout"), 0); // Macrotask
      Promise.resolve().then(() => console.log("Promise")); // Microtask
      console.log("End");

      // Вывод: Start, End, Promise, Timeout
      \`\`\`
      `,
    },
    {
      id: 100029,
      question: "Для чего нужен eventloop в js?",
      answer: `Event Loop позволяет JavaScript обрабатывать асинхронные операции, такие как сетевые запросы, 
      таймеры и события, не блокируя основной поток выполнения. Это обеспечивает отзывчивость приложения, 
      даже когда происходят длительные операции.`,
    },
    {
      id: 100030,
      question: "В чём разница между макро и микро задачами?",
      answer: `Различия:
      1. **Приоритет:** Микрозадачи выполняются перед макрозадачами.
      2. **Циклы Event Loop:** Макрозадачи обрабатываются в рамках отдельных циклов, а микрозадачи — внутри 
      одного цикла.
      3. **Пример:**
      \`\`\`javascript
      console.log("Start");
      setTimeout(() => console.log("Timeout"), 0); // Macrotask
      Promise.resolve().then(() => console.log("Promise")); // Microtask
      console.log("End");

      // Вывод: Start, End, Promise, Timeout
      \`\`\`
      `,
    },
    {
      id: 100031,
      question: "В чём разница в работе eventloop на сервере и в браузере?",
      answer: `В браузере Event Loop управляет интерфейсом пользователя, DOM и сетевыми запросами в однопоточной 
      среде. В Node.js Event Loop также является основой асинхронности, но он использует дополнительные потоки 
      для операций ввода-вывода, что делает его более эффективным для серверных задач.`,
    },
    {
      id: 100032,
      question: "Что такое Call stack?",
      answer: `Call Stack (Стек вызовов) — это структура данных, которая хранит текущие выполняемые функции. 
      Когда функция вызывается, она добавляется в стек, а после завершения — удаляется. Если стек переполняется, 
      возникает ошибка \`RangeError: Maximum call stack size exceeded\`.`,
    },
    {
      id: 100033,
      question: "Какие проблемы решает eventloop?",
      answer: `Event Loop решает проблему одновременной обработки асинхронных операций и поддержания отзывчивости 
      пользовательского интерфейса в однопоточной среде. Он позволяет избежать блокировки основного потока 
      выполнения при выполнении длительных задач, таких как сетевые запросы или таймеры.`,
    },
    {
      id: 100034,
      question: "Сколько в один кадр eventloop'а может войти reflow и repaint?",
      answer: `В рамках одного кадра Event Loop'а может произойти несколько операций reflow и repaint, если 
      изменения требуют пересчета макета или перерисовки страницы. Однако частые reflow и repaint могут 
      негативно сказаться на производительности.

      **Refactor:** Происходит при изменении геометрии элементов (например, ширины, высоты).
      **Repaint:** Происходит при изменении визуальных свойств (например, цвета фона).`,
    },
    {
      id: 100035,
      question: "Как работает eventloop в web api?",
      answer: `Web API (например, \`setTimeout\`, \`fetch\`) перемещают колбэки асинхронных функций в свои 
      внутренние очереди. После завершения операции колбэк передается в очередь Event Loop. Сам движок 
      JavaScript продолжает выполнять другие операции, пока колбэк находится под управлением Web API.`,
    },
  ],
};