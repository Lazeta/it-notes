export const testGarbageCollector = {
  id: 102175,
  title: "Garbage Collector (сборщик мусора)",
  questions: [
    {
      id: 102176,
      question: "Что такое Garbage Collector (сборщик мусора)?",
      answer: `
**Garbage Collector (Сборщик мусора):**
- Это механизм в JavaScript, который автоматически управляет памятью, освобождая ресурсы, которые больше не используются программой.
- Он отслеживает объекты и переменные в памяти и удаляет те, на которые нет ссылок.

**Как это работает:**
1. **Выделение памяти:** Когда вы создаете переменную, объект или функцию, JavaScript выделяет для них память.
2. **Использование памяти:** Пока переменная или объект используются (есть ссылки на них), они остаются в памяти.
3. **Очистка памяти:** Когда ссылки на объект исчезают (например, переменная выходит из области видимости), сборщик мусора освобождает память.

**Пример:**
\`\`\`javascript
let user = { name: "Alice" }; // Выделение памяти для объекта
user = null; // Удаление ссылки на объект
// Сборщик мусора освободит память, занятую объектом { name: "Alice" }
\`\`\`
`,
    },
    {
      id: 102177,
      question: "Как работает алгоритм подсчета ссылок?",
      answer: `
**Алгоритм подсчета ссылок:**
- Основной принцип: объект удаляется из памяти, если на него нет ссылок.
- Каждый объект имеет счетчик ссылок. Когда ссылка добавляется, счетчик увеличивается; когда ссылка удаляется, счетчик уменьшается.
- Если счетчик ссылок становится равным нулю, объект удаляется.

**Проблемы:**
- Не справляется с циклическими ссылками (например, два объекта ссылаются друг на друга, но больше никто на них не ссылается).

**Пример:**
\`\`\`javascript
let obj1 = {};
let obj2 = {};
obj1.ref = obj2; // obj1 ссылается на obj2
obj2.ref = obj1; // obj2 ссылается на obj1
obj1 = null;
obj2 = null;
// Несмотря на удаление ссылок, объекты остаются в памяти (проблема циклических ссылок)
\`\`\`
`,
    },
    {
      id: 102178,
      question: "Что такое алгоритм Mark-and-Sweep (метка и очистка)?",
      answer: `
**Mark-and-Sweep (Метка и очистка):**
- Современный алгоритм сборки мусора, используемый в JavaScript.
- Работает в два этапа:
  1. **Mark (Метка):** Все достижимые объекты помечаются как используемые.
  2. **Sweep (Очистка):** Все непомеченные объекты удаляются.

**Преимущества:**
- Эффективно обрабатывает циклические ссылки.
- Автоматически освобождает память, на которую больше нет ссылок.

**Пример:**
\`\`\`javascript
let user = { name: "Alice" };
user = null; // Объект становится недостижимым
// На этапе Mark объект не будет помечен как достижимый
// На этапе Sweep объект будет удален
\`\`\`
`,
    },
    {
      id: 102179,
      question: "Какие типы данных управляются сборщиком мусора?",
      answer: `
**Управляемые типы данных:**
- Все типы данных, которые хранятся в куче (heap):
  - Объекты (\`{ }\`)
  - Массивы (\`[ ]\`)
  - Функции
  - Прочие сложные структуры данных

**Неуправляемые типы данных:**
- Простые типы данных (числа, строки, булевы значения, \`null\`, \`undefined\`) хранятся в стеке (stack) и управляются автоматически без участия сборщика мусора.
`,
    },
    {
      id: 102180,
      question: "Как принудительно вызвать сборку мусора?",
      answer: `
**Нельзя принудительно вызвать сборку мусора:**
- JavaScript автоматически управляет памятью, и разработчики не могут напрямую управлять сборщиком мусора.
- Однако можно использовать метод \`global.gc()\` в Node.js (только при запуске с флагом \`--expose-gc\`).

**Пример (Node.js):**
\`\`\`javascript
if (global.gc) {
  global.gc(); // Принудительный вызов сборки мусора
} else {
  console.log("Garbage collection is not exposed");
}
\`\`\`

**Важно:**
- В браузерах такой возможности нет.
- Не рекомендуется полагаться на принудительный вызов сборки мусора.
`,
    },
    {
      id: 102181,
      question: "Как избежать утечек памяти?",
      answer: `
**Способы избежать утечек памяти:**
1. **Удаляйте ненужные ссылки:**
   - Убедитесь, что переменные, которые больше не нужны, установлены в \`null\` или перезаписаны.
2. **Избегайте глобальных переменных:**
   - Глобальные переменные остаются в памяти до завершения работы программы.
3. **Осторожно используйте замыкания:**
   - Замыкания могут сохранять ссылки на внешние переменные, что приводит к утечкам.
4. **Отписывайтесь от событий:**
   - Убедитесь, что обработчики событий удалены, если они больше не нужны.
5. **Используйте WeakMap и WeakSet:**
   - Они позволяют хранить ссылки на объекты, которые автоматически удаляются сборщиком мусора.

**Пример утечки памяти:**
\`\`\`javascript
let cache = [];
function leakMemory() {
  cache.push(new Array(1000000).fill(Math.random()));
}
setInterval(leakMemory, 1000); // Постоянное выделение памяти
\`\`\`
`,
    },
    {
      id: 102182,
      question: "Что такое WeakMap и WeakSet?",
      answer: `
**WeakMap и WeakSet:**
- Это коллекции, которые хранят ссылки на объекты, но не предотвращают их удаление сборщиком мусора.

**WeakMap:**
- Ключами могут быть только объекты.
- Значения автоматически удаляются, если ключ больше не используется.

**WeakSet:**
- Хранит только объекты.
- Объекты автоматически удаляются, если на них больше нет ссылок.

**Пример WeakMap:**
\`\`\`javascript
let weakMap = new WeakMap();
let obj = {};
weakMap.set(obj, "data");
console.log(weakMap.has(obj)); // true
obj = null; // Удаление ссылки
console.log(weakMap.has(obj)); // false (объект удален сборщиком мусора)
\`\`\`
`,
    },
    {
      id: 102183,
      question: "Как проверить использование памяти в JavaScript?",
      answer: `
**Проверка использования памяти:**
1. **В браузере:**
   - Используйте инструменты разработчика (DevTools).
   - Откройте вкладку "Memory" для анализа распределения памяти.
2. **В Node.js:**
   - Используйте модуль \`process.memoryUsage()\`.

**Пример (Node.js):**
\`\`\`javascript
console.log(process.memoryUsage());
// {
//   rss: ..., // Resident Set Size (общее использование памяти)
//   heapTotal: ..., // Общий объем кучи
//   heapUsed: ..., // Используемая память кучи
//   external: ..., // Память, используемая внешними библиотеками
// }
\`\`\`
`,
    },
  ],
};
