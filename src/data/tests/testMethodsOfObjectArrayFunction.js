export const testMethodsOfObjectArrayFunction = {
  id: 100100,
  title: "Methods of Object, Array, Function.prototype",
  questions: [
    {
      id: 100101,
      question:
        "Объясните, как работает метод Object.keys и приведите пример его использования.",
      answer: `
      Метод Object.keys() возвращает массив строк с именами всех собственных перечисляемых (enumerable) свойств объекта.
      const person = {
        name: 'Alice',
        age: 25,
        city: 'Berlin'
      };
      const keys = Object.keys(person);
      console.log(keys); // ['name', 'age', 'city']
      `,
    },
    {
      id: 100102,
      question:
        "Как с помощью метода reduce можно получить сумму всех чисел в массиве? Напишите пример кода.",
      answer: `
      Метод reduce() последовательно обрабатывает элементы массива и сводит их к одному значению (например, сумме).
      array.reduce((accumulator, currentValue) => {
        return accumulator + currentValue;
      }, initialValue);

      accumulator — накопленное значение (на каждом шаге добавляется currentValue).
      currentValue — текущий элемент массива.
      initialValue (опционально) — начальное значение аккумулятора (если не указано, берётся первый элемент массива).
      `,
    },
    {
      id: 100103,
      question:
        "Опишите разницу между методами клонирования объектов в JavaScript и как можно изолировать ссылки при клонировании.",
      answer: `
      Разница между методами клонирования:
      Поверхностное клонирование (...spread, Object.assign())
      Копирует только первый уровень объекта.
      Вложенные объекты остаются ссылками (изменения в клоне влияют на оригинал).
      Глубокое клонирование (JSON.parse(JSON.stringify()), рекурсивное копирование, lodash.cloneDeep)
      Полностью копирует объект, включая вложенные структуры.
      Изолирует все ссылки (изменения в клоне не затрагивают оригинал).
      Как изолировать ссылки?
      Использовать глубокое клонирование, особенно для объектов с вложенными свойствами.
      Для простых объектов хватит spread или Object.assign().
      Лучший вариант — lodash.cloneDeep (работает с любыми типами данных).
      Вывод:
      Поверхностное = быстро, но не для вложенных объектов.
      Глубокое = надежно, но сложнее (может не поддерживать функции и Date).
      Библиотеки (lodash) = универсальное решение.
      `,
    },
    {
      id: 100104,
      question: "Какие есть встроенные методы у объектов?",
      answer: `У объектов есть встроенные методы, такие как hasOwnProperty(), toString(), 
      valueOf() и другие. 
      Эти методы предоставляют стандартные операции для работы с объектами. `,
    },
    {
      id: 100105,
      question: "метод Object.entries()",
      answer: `Метод Object.entries() в JavaScript возвращает массив, содержащий собственные 
      перечисляемые свойства объекта в виде пар [ключ, значение]. Этот метод полезен для 
      перебора свойств объекта и их значений, а также для преобразования объекта в другие 
      структуры данных, такие как Map. `,
    },
    {
      id: 100106,
      question: "Какие знаешь способы клонирования объектов?",
      answer: `Существует два основных способа клонирования объектов: поверхностное 
      (shallow cloning) и глубокое (deep cloning). Поверхностное клонирование создает копию, 
      где вложенные объекты или массивы ссылаются на те же самые объекты в памяти, что и 
      оригинальный объект. Глубокое клонирование, напротив, создает полностью независимые копии 
      всех вложенных объектов и массивов. 
      
      Поверхностное клонирование:
      Оператор spread (...):
      . С его помощью можно копировать свойства объекта, но не вложенные объекты или массивы, 
      которые будут ссылаться на оригинал. 
      Object.assign():
      . Аналогично spread, он также создает поверхностную копию, не копируя вложенные объекты. 
      Присвоение (=):
      . Простое присваивание создает ссылку, а не копию. 
      Глубокое клонирование:
      structuredClone() (в JavaScript):
      . Это наиболее современный и надежный способ глубокого клонирования, который поддерживает 
      различные типы данных, включая циклические ссылки. 
      JSON (с использованием JSON.stringify() и JSON.parse()):
      . Этот способ хорошо работает для объектов, содержащих только простые типы данных (числа, 
      строки, булевы значения), но не поддерживает функции, символы, или вложенные циклические 
      ссылки. 
      Библиотеки (Lodash, Immutable.js):
      . Эти библиотеки предоставляют функции для глубокого клонирования, которые могут быть 
      полезны для работы с более сложными структурами данных. 
      Рекурсивные функции (в ручном программировании):
      . можно написать рекурсивную функцию, которая будет копировать объект и все его вложенные 
      объекты. `,
    },
    {
      id: 100107,
      question: "Назови основные методы перебора массивов и объектов",
      answer: `Перебор массивов:
      forEach(callback(currentValue, index, array)):
      Выполняет заданную функцию один раз для каждого элемента массива. Не возвращает новый массив. 
      map(callback(currentValue, index, array)):
      Создаёт новый массив с результатами вызова переданной функции для каждого элемента массива. 
      filter(callback(currentValue, index, array)):
      Создаёт новый массив со всеми элементами, прошедшими проверку, заданную в передаваемой функции. 
      reduce(callback(accumulator, currentValue, index, array), initialValue):
      Применяет функцию-редьюсер к каждому элементу массива, приводя его к единственному выходному значению. 
      every(callback(currentValue, index, array)):
      Проверяет, удовлетворяют ли все элементы массива условию, заданному в функции. Возвращает true или false. 
      some(callback(currentValue, index, array)):
      Проверяет, удовлетворяет ли хотя бы один элемент массива условию, заданному в функции. Возвращает true или false. 
      Цикл for:
      Классический цикл, позволяющий перебирать элементы по индексу. 
      Цикл for...of:
      Позволяет перебирать значения элементов массива. 
      Перебор объектов:
      Цикл for...in:
      Перебирает перечисляемые свойства объекта.
      Цикл for...of:
      Позволяет перебирать значения свойств объекта, если свойства объекта являются итерируемыми.
      Object.keys(object):
      Возвращает массив, содержащий имена (ключи) собственных перечисляемых свойств объекта.
      Object.values(object):
      Возвращает массив, содержащий значения собственных перечисляемых свойств объекта.
      Object.entries(object):
      Возвращает массив, содержащий массивы пар [ключ, значение] для собственных перечисляемых свойств объекта. `,
    },
    {
      id: 100108,
      question: "В чём разница между Object.GetOwnPropertyNames и Object.Keys?",
      answer: `Object.getOwnPropertyNames() и Object.keys() оба возвращают массив 
      ключей объекта, но есть ключевое различие: Object.getOwnPropertyNames() возвращает все 
      собственные (непосредственно принадлежащие объекту) свойства, в то время как Object.keys() 
      возвращает только перечисляемые собственные свойства. `,
    },
    {
      id: 100109,
      question: "Что такое метод объекта?",
      answer: `Метод объекта - это функция, которая является свойством объекта. 
      Он может выполнять действия, связанные с данными объекта, используя this для доступа к 
      его свойствам.`,
    },
    {
      id: 100110,
      question: "Как определить метод в объекте?",
      answer: `Методы определяются как свойства объекта, значениями которых являются функции. 
      Например: obj = { method: function() { ... } }. `,
    },
    {
      id: 100111,
      question: "Как вызвать метод объекта?",
      answer: `Методы вызываются с помощью оператора точки (.) после имени объекта и имени метода. 
      Например: obj.method()`,
    },
    {
      id: 100112,
      question: "В чем разница между свойством и методом?",
      answer: `Свойство - это пара "ключ: значение" в объекте, где значением может быть любое 
      значение, включая функцию. 
      Метод - это функция, которая является свойством объекта. 
      Свойство хранит данные, а метод выполняет действия. `,
    },
    {
      id: 100113,
      question: "Как проверить наличие метода в объекте?",
      answer: `Можно использовать оператор in или метод hasOwnProperty() для проверки 
      существования свойства (включая методы) в объекте. 
      Например: if ('method' in obj) { ... } или if (obj.hasOwnProperty('method')) { ... }. `,
    },
    {
      id: 100114,
      question: "Могут ли методы содержать другие методы?",
      answer: `Да, метод может содержать вызовы других методов, в том числе и методов этого же объекта. 
      Это позволяет создавать сложные иерархии методов и логику обработки данных. `,
    },
    {
      id: 100115,
      question: "Может ли метод быть переопределен?",
      answer: `Да, метод объекта может быть переопределен, если его имя совпадает с именем 
      существующего метода в прототипе объекта. 
      При переопределении важно учитывать область видимости и порядок наследования. `,
    },
    {
      id: 100116,
      question: "Как передать аргументы в метод?",
      answer: `Аргументы передаются в метод, как в обычную функцию, после имени метода и 
      в скобках, разделяя их запятыми. 
      Например: obj.method(arg1, arg2). `,
    },
    {
      id: 100117,
      question: "Методы объектов",
      answer: `Object.keys(obj): Возвращает массив ключей объекта. 
      Object.values(obj): Возвращает массив значений объекта. 
      Object.entries(obj): Возвращает массив пар [ключ, значение] объекта. 
      Object.assign(target, ...sources): Копирует значения из одного или нескольких исходных объектов в целевой объект. 
      Object.create(proto[, propertiesObject]): Создает новый объект с указанным прототипом и (необязательно) дескрипторами свойств. 
      Object.freeze(obj): Замораживает объект, предотвращая добавление, удаление или изменение его свойств. 
      Object.seal(obj): Запечатывает объект, предотвращая добавление новых свойств, но позволяя изменять существующие. 
      Object.getPrototypeOf(obj): Возвращает прототип указанного объекта. 
      `,
    },
    {
      id: 100118,
      question: "",
      answer: ``,
    },
  ],
};
