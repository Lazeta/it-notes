export const testMethodsOfObjectArrayFunction = {
  id: 100099,
  title: "Methods of Object, Array, Function.prototype",
  questions: [
    {
      id: 100100,
      question: "Объясните, как работает метод Object.keys и приведите пример его использования.",
      answer: `
Метод Object.keys() возвращает массив строк с именами всех собственных перечисляемых (enumerable) свойств объекта.
const person = {
  name: 'Alice',
  age: 25,
  city: 'Berlin'
};
const keys = Object.keys(person);
console.log(keys); // ['name', 'age', 'city']
      `,
    },
    {
      id: 100101,
      question: "Как с помощью метода reduce можно получить сумму всех чисел в массиве? Напишите пример кода.",
      answer: `
Метод reduce() последовательно обрабатывает элементы массива и сводит их к одному значению (например, сумме).
array.reduce((accumulator, currentValue) => {
  return accumulator + currentValue;
}, initialValue);

accumulator — накопленное значение (на каждом шаге добавляется currentValue).
currentValue — текущий элемент массива.
initialValue (опционально) — начальное значение аккумулятора (если не указано, берётся первый элемент массива).
      `,
    },
    {
      id: 100102,
      question: "Опишите разницу между методами клонирования объектов в JavaScript и как можно изолировать ссылки при клонировании.",
      answer: `
Разница между методами клонирования:
Поверхностное клонирование (...spread, Object.assign())
Копирует только первый уровень объекта.
Вложенные объекты остаются ссылками (изменения в клоне влияют на оригинал).
Глубокое клонирование (JSON.parse(JSON.stringify()), рекурсивное копирование, lodash.cloneDeep)
Полностью копирует объект, включая вложенные структуры.
Изолирует все ссылки (изменения в клоне не затрагивают оригинал).
Как изолировать ссылки?
Использовать глубокое клонирование, особенно для объектов с вложенными свойствами.
Для простых объектов хватит spread или Object.assign().
Лучший вариант — lodash.cloneDeep (работает с любыми типами данных).
Вывод:
Поверхностное = быстро, но не для вложенных объектов.
Глубокое = надежно, но сложнее (может не поддерживать функции и Date).
Библиотеки (lodash) = универсальное решение.
      `,
    }
  ],
};