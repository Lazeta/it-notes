export const testOOP = {
  id: 100350,
  title: "ООП",
  questions: [
    {
      id: 100351,
      question: "Что такое ООП?",
      answer: `Объектно-ориентированное программирование (ООП) — это парадигма программирования, 
      основанная на концепции 'объектов', которые могут содержать данные (свойства) и код (методы). 
      Основные принципы ООП:
      - **Инкапсуляция:** Сокрытие данных и управление доступом через методы.
      - **Наследование:** Создание новых классов на основе существующих.
      - **Полиморфизм:** Использование одного интерфейса для разных типов объектов.
      - **Абстракция:** Упрощение сложных систем через общие интерфейсы.`,
    },
    {
      id: 100352,
      question: "Что такое инкапсуляция?",
      answer: `**Инкапсуляция** — это механизм сокрытия внутреннего состояния объекта и предоставление 
      контролируемого доступа к нему через методы. Это помогает:
      - Защитить данные от несанкционированного доступа.
      - Обеспечить целостность объекта.
      
      Пример:
      \`\`\`javascript
      class User {
        #password; // Приватное поле
        constructor(name, password) {
          this.name = name;
          this.#password = password;
        }
        getPassword() {
          return this.#password;
        }
      }
      const user = new User("Alice", "secret");
      console.log(user.getPassword()); // "secret"
      \`\`\`
      `,
    },
    {
      id: 100353,
      question: "Что такое наследование?",
      answer: `**Наследование** — это возможность создавать новые классы на основе существующих. Новый 
      класс (потомок) наследует свойства и методы родительского класса, что позволяет повторно 
      использовать и расширять код.
      
      Пример:
      \`\`\`javascript
      class Animal {
        speak() {
          console.log("Animal speaks");
        }
      }
      class Dog extends Animal {
        speak() {
          console.log("Dog barks");
        }
      }
      const dog = new Dog();
      dog.speak(); // "Dog barks"
      \`\`\`
      `,
    },
    {
      id: 100354,
      question: "Что такое полиморфизм?",
      answer: `**Полиморфизм** — это способность объектов разных классов обрабатывать данные через 
      одинаковый интерфейс. Это позволяет использовать один и тот же метод для объектов разных типов, 
      что увеличивает гибкость кода.
      
      Пример:
      \`\`\`javascript
      class Shape {
        draw() {
          console.log("Drawing a shape");
        }
      }
      class Circle extends Shape {
        draw() {
          console.log("Drawing a circle");
        }
      }
      class Square extends Shape {
        draw() {
          console.log("Drawing a square");
        }
      }
      const shapes = [new Circle(), new Square()];
      shapes.forEach(shape => shape.draw());
      // Output: "Drawing a circle", "Drawing a square"
      \`\`\`
      `,
    },
    {
      id: 100355,
      question: "Что такое абстракция?",
      answer: `**Абстракция** — это упрощение сложных систем путем определения общих интерфейсов и 
      скрытия деталей реализации. Это помогает сосредоточиться на взаимодействии между объектами, 
      не вникая в их внутренние механизмы.
      
      Пример:
      \`\`\`javascript
      class Database {
        connect() {
          throw new Error("Method 'connect()' must be implemented.");
        }
      }
      class MySQLDatabase extends Database {
        connect() {
          console.log("Connecting to MySQL database...");
        }
      }
      const db = new MySQLDatabase();
      db.connect(); // "Connecting to MySQL database..."
      \`\`\`
      `,
    },
    {
      id: 100356,
      question: "Что выбираешь: ООП или функциональное программирование?",
      answer: `Выбор зависит от задачи:
      - **ООП** лучше подходит для моделирования сложных систем с множеством взаимосвязанных сущностей.
      - **Функциональное программирование (ФП)** лучше подходит для задач, связанных с чистыми 
      вычислениями и обработкой данных.
      
      В реальности часто используются оба подхода в зависимости от контекста.`,
    },
    {
      id: 100357,
      question: "Чем ООП в JS отличается от ООП в других языках?",
      answer: `В JavaScript ООП реализовано через прототипное наследование, а не через классическое 
      наследование (как в Java или C++):
      - Вместо классов используются прототипы.
      - Наследование реализуется через цепочку прототипов (\`__proto__\`).
      - С версии ES6 появились классы, но они являются синтаксическим сахаром над прототипами.
      
      Пример:
      \`\`\`javascript
      function Person(name) {
        this.name = name;
      }
      Person.prototype.greet = function () {
        console.log(\`Hello, my name is \${this.name}\`);
      };
      const person = new Person("Alice");
      person.greet(); // "Hello, my name is Alice"
      \`\`\`
      `,
    },
    {
      id: 100358,
      question: "Преимущества ООП?",
      answer: `Преимущества ООП:
      - **Модульность:** Код организован в виде объектов, что упрощает его понимание и поддержку.
      - **Повторное использование кода:** Через наследование и полиморфизм.
      - **Гибкость:** Легко расширять и модифицировать систему.
      - **Моделирование реальных систем:** Объекты могут представлять реальные сущности.`,
    },
    {
      id: 100359,
      question: "Недостатки ООП?",
      answer: `Недостатки ООП:
      - **Сложность:** Может привести к избыточному усложнению кода в небольших проектах.
      - **Производительность:** В некоторых случаях может потреблять больше ресурсов (памяти).
      - **Кривая обучения:** Требует понимания концепций ООП, таких как абстракция, инкапсуляция и т.д.`,
    },
    {
      id: 100360,
      question: "Что такое SOLID-принципы?",
      answer: `SOLID — это набор принципов проектирования, которые помогают создавать гибкие и 
      поддерживаемые системы:
      - **S (Single Responsibility):** Каждый класс должен иметь одну ответственность.
      - **O (Open/Closed):** Классы должны быть открыты для расширения, но закрыты для изменения.
      - **L (Liskov Substitution):** Подклассы должны быть заменяемы своими базовыми классами.
      - **I (Interface Segregation):** Лучше много маленьких интерфейсов, чем один большой.
      - **D (Dependency Inversion):** Модули должны зависеть от абстракций, а не от конкретных реализаций.`,
    },
  ],
};
