export const testPureFunction = {
  id: 101550,
  title: "PureFunction (чистая функция)",
  questions: [
    {
      id: 101551,
      question: "Что такое чистая функция?",
      answer: `
      **Чистая функция (pure function):**
      - Это функция, которая для одинаковых входных данных всегда возвращает один и тот же результат.
      - Не имеет побочных эффектов (не изменяет глобальные переменные, не модифицирует переданные аргументы).

      **Пример чистой функции:**
      \`\`\`javascript
      function add(a, b) {
        return a + b;
      }

      console.log(add(2, 3)); // 5
      console.log(add(2, 3)); // 5 (всегда одинаковый результат)
      \`\`\`

      **Пример нечистой функции:**
      \`\`\`javascript
      let counter = 0;

      function increment() {
        counter++;
        return counter;
      }

      console.log(increment()); // 1
      console.log(increment()); // 2 (результат зависит от внешнего состояния)
      \`\`\`
      `,
    },
    {
      id: 101552,
      question: "Что такое PureComponent?",
      answer: `
      **React.PureComponent:**
      - Это базовый класс для компонентов React, который автоматически реализует метод \`shouldComponentUpdate\` с использованием поверхностного сравнения пропсов и состояния.
      - Если пропсы или состояние не изменились, компонент не будет перерисовываться.

      **Пример использования:**
      \`\`\`javascript
      class MyComponent extends React.PureComponent {
        render() {
          return <div>{this.props.value}</div>;
        }
      }

      // Перерисовка произойдет только при изменении \`value\`.
      \`\`\`

      **Важно:**
      - PureComponent выполняет только поверхностное сравнение, поэтому он не подходит для сложных структур данных (например, вложенных объектов).
      `,
    },
    {
      id: 101553,
      question: "Чем отличается PureComponent от обычной функции?",
      answer: `
      **Различия:**
      1. **PureComponent:**
         - Это классовый компонент React.
         - Автоматически реализует поверхностное сравнение пропсов и состояния.
         - Предотвращает ненужные перерисовки.

      2. **Обычная функция:**
         - Просто исполняемый блок кода.
         - Может быть как чистой, так и нечистой.
         - Не имеет встроенной логики сравнения пропсов или состояния.

      **Пример:**
      \`\`\`javascript
      // PureComponent
      class Counter extends React.PureComponent {
        render() {
          return <div>{this.props.count}</div>;
        }
      }

      // Обычная функция
      function multiply(a, b) {
        return a * b;
      }
      \`\`\`
      `,
    },
    {
      id: 101554,
      question: "Чем отличается чистая функция от нечистой функции?",
      answer: `
      **Различия:**
      1. **Чистая функция:**
         - Всегда возвращает одинаковый результат для одних и тех же входных данных.
         - Не имеет побочных эффектов (не изменяет внешние переменные, не взаимодействует с внешними ресурсами).

      2. **Нечистая функция:**
         - Может возвращать разные результаты для одних и тех же входных данных (например, зависит от времени или случайных чисел).
         - Может иметь побочные эффекты (изменение глобальных переменных, взаимодействие с API, запись в файлы).

      **Пример:**
      \`\`\`javascript
      // Чистая функция
      function square(x) {
        return x * x;
      }

      // Нечистая функция
      let total = 0;
      function addToTotal(amount) {
        total += amount;
        return total;
      }
      \`\`\`
      `,
    },
    {
      id: 101555,
      question: "Основные признаки чистой функции",
      answer: `
      **Признаки чистой функции:**
      1. **Детерминированность:**
         - Для одинаковых входных данных всегда возвращает одинаковый результат.
      2. **Отсутствие побочных эффектов:**
         - Не изменяет глобальные переменные, не взаимодействует с внешними ресурсами (API, файлы, базы данных).
      3. **Зависимость только от входных данных:**
         - Результат определяется только входными аргументами.
      4. **Упрощение тестирования:**
         - Легко тестировать, так как результат предсказуем.
      5. **Модульность и переиспользование:**
         - Легко использовать повторно в разных частях программы.

      **Пример:**
      \`\`\`javascript
      // Чистая функция
      function calculateArea(width, height) {
        return width * height;
      }

      console.log(calculateArea(5, 10)); // 50
      \`\`\`
      `,
    },
    {
      id: 101556,
      question: "В каких случаях использовать PureComponent?",
      answer: `
      **Когда использовать:**
      1. **Компоненты с простыми пропсами и состоянием:**
         - Например, отображение текста или чисел.
      2. **Оптимизация производительности:**
         - Когда нужно избежать ненужных перерисовок.
      3. **Автоматическое сравнение:**
         - Когда поверхностное сравнение достаточно для обработки изменений.

      **Пример:**
      \`\`\`javascript
      class DisplayValue extends React.PureComponent {
        render() {
          return <p>{this.props.value}</p>;
        }
      }
      \`\`\`
      `,
    },
    {
      id: 101557,
      question: "В каких случаях не использовать PureComponent?",
      answer: `
      **Когда не использовать:**
      1. **Сложные вложенные структуры данных:**
         - Поверхностное сравнение не работает с вложенными объектами или массивами.
      2. **Глубокое сравнение:**
         - Если требуется проверка на глубокое равенство.
      3. **Изменяемое состояние:**
         - Если компонент изменяет свои пропсы или состояние в методах жизненного цикла.

      **Пример проблемы:**
      \`\`\`javascript
      class ProblematicComponent extends React.PureComponent {
        state = { data: { value: 0 } };

        updateData = () => {
          this.state.data.value++;
          this.setState({ data: this.state.data });
        };

        render() {
          return <div>{this.state.data.value}</div>;
        }
      }

      // PureComponent не заметит изменения, так как ссылка на \`data\` не меняется.
      \`\`\`
      `,
    },
    {
      id: 101558,
      question: "Как проверить, является ли функция чистой?",
      answer: `
      **Проверка чистоты функции:**
      1. **Детерминированность:**
         - Убедитесь, что функция всегда возвращает одинаковый результат для одних и тех же входных данных.
      2. **Отсутствие побочных эффектов:**
         - Проверьте, что функция не изменяет внешние переменные, не вызывает API или другие побочные эффекты.

      **Пример проверки:**
      \`\`\`javascript
      function isFunctionPure(fn, inputs, expectedOutput) {
        const output = fn(...inputs);
        return output === expectedOutput;
      }

      const add = (a, b) => a + b;
      console.log(isFunctionPure(add, [2, 3], 5)); // true
      \`\`\`
      `,
    },
    {
      id: 101559,
      question: "Как сделать функцию чистой?",
      answer: `
      **Создание чистой функции:**
      1. **Убрать побочные эффекты:**
         - Убедитесь, что функция не изменяет внешние переменные или переданные аргументы.
      2. **Использовать только входные данные:**
         - Функция должна зависеть только от своих параметров.
      3. **Возвращать новый объект вместо изменения существующего:**
         - Используйте иммутабельность.

      **Пример:**
      \`\`\`javascript
      // Нечистая функция
      function addItem(array, item) {
        array.push(item); // Изменяет исходный массив
        return array;
      }

      // Чистая функция
      function addItemPure(array, item) {
        return [...array, item]; // Создает новый массив
      }

      const arr = [1, 2, 3];
      console.log(addItemPure(arr, 4)); // [1, 2, 3, 4]
      console.log(arr); // [1, 2, 3] (не изменился)
      \`\`\`
      `,
    },
  ],
};
