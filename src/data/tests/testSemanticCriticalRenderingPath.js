export const testSemanticCriticalRenderingPath = {
  id: 100113,
  title: "Semantic, Critical Rendering path, block/inline elements",
  questions: [
    {
      id: 100114,
      question: "Объясните, какова базовая структура HTML-документа и какие основные теги в нее входят?",
      answer: `
Обязательные:
<!DOCTYPE html> — объявление типа документа (HTML5).
<html> — корневой элемент.
<head> — служебная информация (метаданные, стили, скрипты).
<body> — видимое содержимое страницы.
В <head>:
<meta charset="UTF-8"> — кодировка.
<title> — заголовок вкладки браузера.
<meta name="viewport"> — адаптивность для мобильных устройств.
      `,
    },
    {
      id: 100115,
      question: "Какие основные различия между блочными и строчными элементами в HTML?",
      answer: `
Блочные элементы (block):
Начинаются с новой строки (как абзац в тексте).
Занимают всю доступную ширину родителя, даже если контент узкий.
Полностью поддерживают CSS-бокс-модель (width, height, margin, padding, border).
Могут содержать другие блочные и строчные элементы (например, <div> внутри <section>).


Строчные элементы (inline):
Располагаются в строку (как слова в тексте).
Ширина и высота зависят от контента, игнорируют width и height.
Вертикальные margin и padding не влияют на поток документа (не "раздвигают" соседние элементы).
Обычно содержат только текст или другие строчные элементы (например, <span> внутри <a>).
      `,
    },
    {
      id: 100116,
      question: "Что такое критический путь рендеринга и как его можно оптимизировать?",
      answer: `
Это последовательность шагов, которые браузер выполняет для преобразования HTML, CSS и JavaScript в пиксели на экране. Оптимизация CRP ускоряет отображение контента, улучшая воспринимаемую производительность.

Этапы критического пути:
Загрузка HTML → Построение DOM (Document Object Model).
Загрузка CSS → Построение CSSOM (CSS Object Model).
Объединение DOM и CSSOM → Формирование Render Tree (только видимые элементы).
Расчёт макета (Layout) → Определение размеров и позиций элементов.
Отрисовка (Paint) → Преобразование в пиксели.
Композиция (Composite) → Слои и анимации (если есть).


Как оптимизировать CRP?
1.Минимизация блокирующих ресурсов 
1)CSS: Используйте <link rel="stylesheet" media="print"> для неключевых стилей.
Разделяйте CSS на критический (в <head>) и асинхронный (загружаемый через preload).
Минифицируйте CSS (cssnano, purgecss).
2)JavaScript: Делайте скрипты асинхронными (async/defer)
Переносите скрипты в конец <body> (если не нужны для рендеринга).


2.Ускорение построения DOM/CSSOM
Оптимизация HTML:
Удаляйте лишние теги, комментарии.
Используйте прогрессивный рендеринг (например, ленивую загрузку).
Inline критического CSS
Встраивайте стили, необходимые для первого экрана, прямо в <head>


3.Оптимизация Layout и Paint
Избегайте "layout thrashing" — частых пересчётов макета из-за JS.
Используйте transform и opacity для анимаций (не затрагивают Layout/Paint).


4.Приоритезация контента
Ленивая загрузка изображений
Предзагрузка ключевых ресурсов


5.Server-Side Optimizations
Сжатие (Gzip/Brotli) для HTML/CSS/JS.
HTTP/2 для параллельной загрузки.
SSR (Server-Side Rendering) для быстрого первого рендера.


Коротко: Оптимизация CRP сокращает время до первого рендера, улучшая UX и SEO. Ключевые методы — минификация, асинхронная загрузка, приоритезация контента и избегание лишних перерасчётов.
      `,
    }
  ],
};